SCHEMA ISO13584_g_m_iim_library_implicit_schema;


CONSTANT

	version_len: INTEGER := 9;

	sep_cv: STRING := '-';

	revision_len: INTEGER := 3;

	value_format_len: INTEGER := 80;

	class_code_len: INTEGER := 14;

	sep_id: STRING := '.';

	data_type_code_len:INTEGER := 14;

	DET_classification_len: INTEGER := 3;

	source_doc_len: INTEGER := 80;

	pref_name_len: INTEGER := 70;

	syn_name_len: INTEGER := pref_name_len;

	short_name_len: INTEGER := 30;

	property_code_len: INTEGER := 14; 

	supplier_code_len: INTEGER := 70;

	value_code_len: INTEGER :=18; 

	dictionary_code_len: INTEGER := 80;

	element_code_len: INTEGER := 14;

	external_item_code_length: INTEGER := 128;

	external_file_address_length: INTEGER := 18;

	http_directory_name_length: INTEGER := 128;

	http_file_name_length: INTEGER := 128;


END_CONSTANT;




TYPE DET_classification_type = identifier;
WHERE
	WR1: LENGTH(SELF) = DET_classification_len; 
END_TYPE; -- DET_classification_type




TYPE integer_type = INTEGER; 
END_TYPE; -- integer_type




TYPE level = ENUMERATION OF(
	min,		
	nom,		
	typ,		
	max);	
END_TYPE; -- level 




TYPE value_code_type = identifier;
WHERE
	WR1: LENGTH(SELF) <= value_code_len; 
END_TYPE; -- value_code_type

	
 



TYPE language_code = identifier; 
END_TYPE; -- language_code




TYPE boolean_value = BOOLEAN;
END_TYPE; -- boolean_value





TYPE integer_value = INTEGER;
END_TYPE; -- integer_value




TYPE real_value = REAL;
END_TYPE; -- real_value




TYPE string_value = STRING;
END_TYPE; -- string_value





TYPE property_semantics_or_path = SELECT(
	property_semantics,
	sub_property_path);
END_TYPE; -- property_semantics_or_path



TYPE amount_of_substance_measure = REAL;
END_TYPE;



TYPE area_measure = REAL;
END_TYPE;



TYPE context_dependent_measure = REAL;
END_TYPE;



TYPE count_measure = NUMBER;
END_TYPE;



TYPE descriptive_measure = STRING;
END_TYPE;



TYPE electric_current_measure = REAL;
END_TYPE;



TYPE length_measure = REAL;
END_TYPE;



TYPE luminous_intensity_measure = REAL;
END_TYPE;



TYPE mass_measure = REAL;
END_TYPE;



TYPE measure_value = SELECT
  (length_measure,
   mass_measure,
   time_measure,
   electric_current_measure,
   thermodynamic_temperature_measure,
   amount_of_substance_measure,
   luminous_intensity_measure,
   plane_angle_measure,
   solid_angle_measure,
   area_measure,
   volume_measure,
   ratio_measure,
   parameter_value,
   numeric_measure,
   context_dependent_measure,
   descriptive_measure,
   positive_length_measure,
   positive_plane_angle_measure,
   positive_ratio_measure,
   count_measure);
END_TYPE;



TYPE numeric_measure = NUMBER;
END_TYPE;



TYPE parameter_value = REAL;
END_TYPE;



TYPE plane_angle_measure = REAL;
END_TYPE;



TYPE positive_length_measure = length_measure;
WHERE
  WR1: SELF > 0;
END_TYPE;



TYPE positive_plane_angle_measure = plane_angle_measure;
WHERE
  WR1: SELF > 0;
END_TYPE;



TYPE positive_ratio_measure = ratio_measure;
WHERE
  WR1: SELF > 0;
END_TYPE;



TYPE ratio_measure = REAL;
END_TYPE;



TYPE solid_angle_measure = REAL;
END_TYPE;



TYPE thermodynamic_temperature_measure = REAL;
END_TYPE;



TYPE time_measure = REAL;
END_TYPE;



TYPE volume_measure = REAL;
END_TYPE;




TYPE code_type = identifier;
WHERE
	WR1: NOT(SELF LIKE '*.*');
	WR2: NOT(SELF LIKE '*-*');
	WR3: NOT(SELF LIKE '* *');
	WR4: NOT(SELF = '');
END_TYPE; -- code_type



TYPE identifier = STRING; 
END_TYPE; 




TYPE version_type = code_type;
WHERE
	WR1: LENGTH(SELF) <= version_len;
	WR2: EXISTS(VALUE(SELF)) AND ('INTEGER' IN TYPEOF(VALUE(SELF)))
		AND (VALUE(SELF) >= 0);
END_TYPE; -- version_type




TYPE revision_type = code_type; 
WHERE 
	WR1: LENGTH(SELF) <= revision_len; 
END_TYPE; -- revision_type




TYPE value_format_type = identifier;
WHERE
	WR1: LENGTH(SELF) <= value_format_len; 
END_TYPE; -- value_format_type




TYPE class_code_type = code_type; 
WHERE 
	WR1: LENGTH(SELF) <= class_code_len;
END_TYPE; -- class_code_type




TYPE definition_type = translatable_text;
END_TYPE; -- definition_type




TYPE translatable_text = SELECT(text, translated_text);
END_TYPE; -- translatable_text




TYPE note_type = translatable_text;
END_TYPE; -- note_type




TYPE remark_type = translatable_text; 
END_TYPE; -- remark_type




TYPE data_type_code_type = code_type; 
WHERE 
	WR1: LENGTH(SELF) = data_type_code_len;
END_TYPE; -- data_type_code_type




TYPE date_type = STRING(10) FIXED;
END_TYPE; -- date_type



TYPE unit = SELECT 
  (named_unit, 
   derived_unit);
END_TYPE;



TYPE value_type = SELECT(value_code_type, integer_type); 
END_TYPE; -- value_type




TYPE source_doc_type = identifier; 
WHERE
	WR1: LENGTH(SELF) <= source_doc_len; 
END_TYPE; -- source_doc_type




TYPE currency_code = identifier;
WHERE
	WR1: LENGTH(SELF) = 3;
END_TYPE; -- currency_code




TYPE pref_name_type = translatable_label;
WHERE
	WR1: check_label_length(SELF, pref_name_len);
END_TYPE; -- pref_name_type




TYPE translatable_label = SELECT(label, translated_label);
END_TYPE; -- translatable_label




TYPE syn_name_type = SELECT(label_with_language, label);
WHERE
	WR1: check_syn_length(SELF, syn_name_len); 
END_TYPE; -- syn_name_type




TYPE short_name_type = translatable_label;
WHERE
	WR1: check_label_length(SELF, short_name_len); 
END_TYPE; -- short_name_type



TYPE label = STRING; 
END_TYPE;



TYPE text = STRING; 
END_TYPE;




TYPE property_code_type = code_type; 
WHERE 
	WR1: LENGTH(SELF) <= property_code_len;
END_TYPE; -- property_code_type




TYPE supplier_code_type = code_type;
WHERE
	WR1: LENGTH(SELF) <= supplier_code_len; 
END_TYPE; -- supplier_code_type




TYPE primitive_value = SELECT(
	simple_value,
	complex_value);
END_TYPE; -- primitive_value




TYPE property_or_data_type_BSU = SELECT(
	property_BSU,
	data_type_BSU);
END_TYPE; -- property_or_data_type_BSU




TYPE library_expression = SELECT(
	expression,
	level_spec_expression,
	entity_instance_expression,
	class_instance_expression);
END_TYPE; -- library_expression




 TYPE ENTITY_INSTANCE_VALUE = SELECT (
   CONTROLLED_ENTITY_INSTANCE_VALUE
);
END_TYPE;


TYPE controlled_entity_instance_value = SELECT(
	PLIB_entity_instance_value,
	STEP_entity_instance_value);
END_TYPE; -- controlled_entity_instance_value



TYPE PLIB_entity_instance_value = SELECT(
	property_value_external_item);
END_TYPE; -- PLIB_entity_instance_value



TYPE STEP_entity_instance_value = SELECT(
	person_organization_select,
	date,
	date_and_time,
	local_time,
	calendar_date,
	ordinal_date,
	week_of_year_and_day_date,
	person,
	organization,
	person_and_organization,
	address,
	personal_address,
	organizational_address );
END_TYPE; -- STEP_entity_instance_value





TYPE library_variable = SELECT(
	variable,
	level_spec_variable,
	entity_instance_variable,
	class_instance_variable);
END_TYPE; -- library_variable




TYPE null_or_primitive_value = SELECT(
	null_value,
	primitive_value);
END_TYPE; -- null_or_primitive_value




TYPE null_or_simple_value = SELECT(
	null_value,
	simple_value);
END_TYPE; -- null_or_simple_value




TYPE null_or_boolean_value = SELECT(
	null_value,
	boolean_value);
END_TYPE; -- null_or_boolean_value




TYPE null_or_complex_value = SELECT(
	null_value,
	complex_value);
END_TYPE; -- null_or_complex_value




TYPE null_or_dic_class_instance = SELECT(
	null_value,
	dic_class_instance);
END_TYPE; -- null_or_dic_class_instance




TYPE null_or_entity_instance_value = SELECT(
	null_value,
	entity_instance_value);
END_TYPE; -- null_or_entity_instance_value




TYPE null_or_number_value = SELECT(
	null_value,
	number_value);
END_TYPE; -- nunmber_value




TYPE null_or_integer_value = SELECT(
	null_value,
	integer_value);
END_TYPE; -- null_or_integer_value




TYPE null_or_level_spec_value = SELECT(
	null_value,
	level_spec_value);
END_TYPE; -- null_or_level_spec_value




TYPE null_or_int_level_spec_value = SELECT(
	null_value,
	int_level_spec_value);
END_TYPE; -- null_or_int_level_spec_value




TYPE null_or_real_value = SELECT(
	null_value,
	real_value);
END_TYPE; -- null_or_real_value




TYPE null_or_real_level_spec_value = SELECT(
	null_value,
	real_level_spec_value);
END_TYPE; -- null_or_real_level_spec_value




TYPE null_or_translatable_string_value = SELECT(
	null_value,
	translatable_string_value);
END_TYPE; -- null_or_translatable_string_value




TYPE boolean_expression_or_others = SELECT(
	boolean_expression,
	others);
END_TYPE; -- boolean_expression_or_others



TYPE year_number = INTEGER;
END_TYPE; 




TYPE dictionary_code_type = code_type;
WHERE
	WR1: LENGTH(SELF) <= dictionary_code_len;
END_TYPE; -- dictionary_code_type




TYPE document_code_type = code_type;
WHERE
	WR1: LENGTH(SELF) <= element_code_len;
END_TYPE; -- document_code_type




TYPE absolute_URL_type = identifier;
WHERE
	WR1: SELF LIKE '*://*';
END_TYPE; -- absolute_URL_type




TYPE table_code_type = code_type;
WHERE
	WR1: LENGTH(SELF) <= element_code_len;
END_TYPE; -- table_code_type




TYPE external_item_code_type = identifier;
WHERE
	WR1: LENGTH(SELF) <= external_item_code_length;
	WR2: NOT(SELF LIKE '* *');
END_TYPE; -- external_item_code_type




TYPE classification_value = INTEGER;
END_TYPE; -- classification_value




TYPE illustration_type = ENUMERATION OF(
	schematic_drawing, realistic_picture, not_static_picture);
END_TYPE; -- illustration_type




TYPE external_file_address = identifier;
WHERE
	WR1: LENGTH(SELF) <= external_file_address_length;
	WR2: NOT(SELF LIKE '* *');
END_TYPE; -- external_file_address




TYPE content_encoding_type = identifier;
WHERE
	WR1: (SELF = '7bit' ) OR (SELF = '8bit' ) OR (SELF = 'binary' )
		OR (SELF = 'quoted-printable' ) OR (SELF = 'base64' );
END_TYPE; -- content_encoding_type




TYPE http_directory_name_type = identifier;
WHERE
	WR1: LENGTH(SELF) <= http_directory_name_length;
	WR2: NOT(SELF LIKE '* *');
END_TYPE; -- http_directory_name_type




TYPE MIME_type = identifier;
WHERE
	WR1: NOT(SELF LIKE '* *');
END_TYPE; -- MIME_type




TYPE MIME_subtype = identifier;
WHERE
	WR1: NOT(SELF LIKE '* *');
END_TYPE; -- MIME_subtype




TYPE IAB_RFC = INTEGER;
WHERE
	WR1: SELF > 0;
END_TYPE; -- IAB_RFC




TYPE http_file_name_type = identifier;
WHERE
	WR1: LENGTH(SELF) <= http_file_name_length;
	WR2: NOT(SELF LIKE '* *');
	WR3: NOT(SELF LIKE '*.*.*');
	WR4: ((NOT(SELF LIKE '*.*'))
		AND (LENGTH(SELF) <= http_file_name_length - 4))
		OR ((SELF LIKE '*.?')
		AND (LENGTH(SELF) <= http_file_name_length - 2))
		OR ((SELF LIKE '*.??')
		AND (LENGTH(SELF) <= http_file_name_length - 1))
		OR (SELF LIKE '*.???');
END_TYPE; -- http_file_name_type




TYPE character_set_type = identifier;
END_TYPE; -- character_set_type



TYPE si_prefix = ENUMERATION OF
  (exa, 
   peta, 
   tera, 
   giga, 
   mega, 
   kilo, 
   hecto, 
   deca, 
   deci,
   centi, 
   milli, 
   micro, 
   nano, 
   pico, 
   femto, 
   atto);
END_TYPE;



TYPE si_unit_name = ENUMERATION OF
  (metre, 
   gram, 
   second, 
   ampere, 
   kelvin, 
   mole, 
   candela, 
   radian, 
   steradian,
   hertz, 
   newton, 
   pascal, 
   joule, 
   watt, 
   coulomb, 
   volt, 
   farad, 
   ohm, 
   siemens, 
   weber, 
   tesla, 
   henry, 
   degree_Celsius, 
   lumen, 
   lux, 
   becquerel, 
   gray, 
   sievert);
END_TYPE;



TYPE dimension_count = INTEGER;
WHERE
  WR1: SELF > 0;
END_TYPE;




TYPE simple_value = SELECT(
	number_value,
	translatable_string_value,
	boolean_value);
END_TYPE; -- simple_value




TYPE number_value = SELECT(
	integer_value,
	real_value);
END_TYPE; -- nunmber_value




TYPE translatable_string_value = SELECT(string_value,
	translated_string_value);
END_TYPE; -- translatable_string_value




TYPE complex_value = SELECT(
	entity_instance_value,
	level_spec_value,
	dic_class_instance);
END_TYPE; -- complex_value



ENTITY environment;
	syntactic_representation: generic_variable;
	semantics: variable_semantics;
END_ENTITY;




ENTITY abs_function
SUBTYPE OF (unary_function_call);
END_ENTITY;




ENTITY acos_function
SUBTYPE OF (unary_function_call);
END_ENTITY;




ENTITY and_expression
SUBTYPE OF (multiple_arity_boolean_expression);
END_ENTITY;




ENTITY asin_function
SUBTYPE OF (unary_function_call);
END_ENTITY;




ENTITY atan_function
SUBTYPE OF (binary_function_call);
END_ENTITY;




ENTITY boolean_literal
SUBTYPE OF (simple_Boolean_expression, generic_literal);
	the_value: BOOLEAN;
END_ENTITY;




ENTITY boolean_variable
SUBTYPE OF (simple_Boolean_expression, variable);
END_ENTITY;




ENTITY comparison_equal
SUBTYPE OF (comparison_expression);
END_ENTITY;




ENTITY comparison_greater
SUBTYPE OF (comparison_expression);
END_ENTITY;




ENTITY comparison_greater_equal
SUBTYPE OF (comparison_expression);
END_ENTITY;




ENTITY comparison_less
SUBTYPE OF (comparison_expression);
END_ENTITY;




ENTITY comparison_less_equal
SUBTYPE OF (comparison_expression);
END_ENTITY;




ENTITY comparison_not_equal
	SUBTYPE OF (comparison_expression);
END_ENTITY;




ENTITY concat_expression
SUBTYPE OF (string_expression, multiple_arity_generic_expression);
	SELF\multiple_arity_generic_expression.operands: 
				LIST [2 : ?] OF string_expression;
END_ENTITY;




ENTITY cos_function
SUBTYPE OF (unary_function_call);
END_ENTITY;




ENTITY div_expression
SUBTYPE OF (binary_numeric_expression);
END_ENTITY;




ENTITY equals_expression
SUBTYPE OF (binary_boolean_expression);
END_ENTITY;




ENTITY exp_function
SUBTYPE OF (unary_function_call);
END_ENTITY;




ENTITY format_function
SUBTYPE OF (string_expression, binary_generic_expression);
DERIVE
	value_to_format: generic_expression:=
			SELF\binary_generic_expression.operands[1];
	format_string:generic_expression:=
			SELF\binary_generic_expression.operands[2];
WHERE
	WR1: (('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.NUMERIC_EXPRESSION')
					IN TYPEOF(value_to_format)) 
			AND (('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.STRING_EXPRESSION')

					IN TYPEOF(format_string));
END_ENTITY;




ENTITY index_expression
SUBTYPE OF (string_expression, binary_generic_expression);
DERIVE
	operand:generic_expression:=
SELF\binary_generic_expression.operands[1];
	index:generic_expression:= 
SELF\binary_generic_expression.operands[2];
WHERE
	WR1: ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.STRING_EXPRESSION'
			IN TYPEOF(operand))
		AND ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.NUMERIC_EXPRESSION'

			IN TYPEOF(index));
	WR2: is_int_expr (index);
END_ENTITY;




ENTITY interval_expression
SUBTYPE OF (boolean_expression, multiple_arity_generic_expression) ;
DERIVE
	interval_low: generic_expression
			:= SELF\multiple_arity_generic_expression.operands[1];
	interval_item:generic_expression
			:= SELF\multiple_arity_generic_expression.operands[2];
	interval_high:generic_expression
			:= SELF\multiple_arity_generic_expression.operands[3];
WHERE
	WR1:('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.EXPRESSION'
				IN TYPEOF(interval_low))
		AND ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.EXPRESSION'
				IN TYPEOF(interval_item) )
		AND ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.EXPRESSION'
				IN TYPEOF(interval_high));
	WR2:(('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.STRING_EXPRESSION'
				IN TYPEOF (SELF.interval_low)) 
			AND ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.STRING_EXPRESSION'
				IN TYPEOF (SELF.interval_high)) 
			AND ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.STRING_EXPRESSION'
				IN TYPEOF (SELF.interval_item))) 
		OR
		(('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.STRING_EXPRESSION'
				IN TYPEOF(SELF.interval_low)) 
			AND ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.NUMERIC_EXPRESSION'
				IN TYPEOF(SELF.interval_item)) 
			AND ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.NUMERIC_EXPRESSION'

				IN TYPEOF(SELF.interval_high)));
END_ENTITY; 




ENTITY int_literal
SUBTYPE OF (literal_number);
	SELF\literal_number.the_value: INTEGER;
END_ENTITY;




ENTITY int_numeric_variable
SUBTYPE OF (numeric_variable);
END_ENTITY;




ENTITY int_value_function
SUBTYPE OF (value_function);
END_ENTITY;




ENTITY length_function
SUBTYPE OF (numeric_expression, unary_generic_expression);
	SELF\unary_generic_expression.operand: string_expression;
END_ENTITY;




ENTITY like_expression
SUBTYPE OF (comparison_expression);
WHERE
	WR1: ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.STRING_EXPRESSION'
		IN TYPEOF(SELF\comparison_expression.operands[1])) AND 
		('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.STRING_EXPRESSION'

		IN TYPEOF(SELF\comparison_expression.operands[2]));
END_ENTITY;




ENTITY log_function
SUBTYPE OF (unary_function_call);
END_ENTITY;




ENTITY log2_function
SUBTYPE OF (unary_function_call);
END_ENTITY;




ENTITY log10_function
SUBTYPE OF (unary_function_call);
END_ENTITY;




ENTITY maximum_function
SUBTYPE OF (multiple_arity_function_call);
END_ENTITY;




ENTITY minimum_function
SUBTYPE OF (multiple_arity_function_call);
END_ENTITY;




ENTITY minus_expression
SUBTYPE OF (binary_numeric_expression);
END_ENTITY;




ENTITY minus_function
SUBTYPE OF (unary_function_call);
END_ENTITY;




ENTITY mod_expression
SUBTYPE OF (binary_numeric_expression);
END_ENTITY;




ENTITY mult_expression
SUBTYPE OF (multiple_arity_numeric_expression);
END_ENTITY;




ENTITY not_expression
SUBTYPE OF (unary_Boolean_expression);
SELF\unary_generic_expression.operand: boolean_expression;
END_ENTITY;




ENTITY odd_function
SUBTYPE OF (unary_Boolean_expression);
	SELF\unary_generic_expression.operand: numeric_expression;
WHERE
	WR1: is_int_expr(SELF);
END_ENTITY;




ENTITY or_expression
SUBTYPE OF (multiple_arity_boolean_expression);
END_ENTITY;




ENTITY plus_expression
SUBTYPE OF (multiple_arity_numeric_expression);
END_ENTITY;




ENTITY power_expression
SUBTYPE OF (binary_numeric_expression);
END_ENTITY;




ENTITY real_literal
SUBTYPE OF (literal_number); 
	SELF\literal_number.the_value: REAL;
END_ENTITY;




ENTITY real_numeric_variable
SUBTYPE OF (numeric_variable);
END_ENTITY;




ENTITY sin_function
SUBTYPE OF (unary_function_call);
END_ENTITY;




ENTITY slash_expression
SUBTYPE OF (binary_numeric_expression);
END_ENTITY;




ENTITY square_root_function
SUBTYPE OF (unary_function_call);
END_ENTITY;




ENTITY string_literal
SUBTYPE OF (simple_string_expression, generic_literal);
	the_value: STRING;
END_ENTITY;




ENTITY string_variable
SUBTYPE OF (simple_string_expression, variable);
END_ENTITY;




ENTITY substring_expression
SUBTYPE OF (string_expression, multiple_arity_generic_expression);
DERIVE
	operand:generic_expression:=
			SELF\multiple_arity_generic_expression.operands[1];
	index1:generic_expression:=
			SELF\multiple_arity_generic_expression.operands[2];
	index2:generic_expression:=
			SELF\multiple_arity_generic_expression.operands[3]; 
WHERE
	WR1: ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.STRING_EXPRESSION'
					IN TYPEOF(operand))
			AND ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.NUMERIC_EXPRESSION'
					IN TYPEOF(index1))
			AND ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.NUMERIC_EXPRESSION'

					IN TYPEOF(index2));
	WR2: SIZEOF(SELF\multiple_arity_generic_expression.operands)=3;
	WR3: is_int_expr (index1);
	WR4: is_int_expr (index2);
END_ENTITY;




ENTITY tan_function
SUBTYPE OF (unary_function_call);
END_ENTITY;




ENTITY value_function
SUPERTYPE OF (
              INT_VALUE_FUNCTION)

SUBTYPE OF (numeric_expression, unary_generic_expression);
	SELF\unary_generic_expression.operand: string_expression;
END_ENTITY;




ENTITY xor_expression
SUBTYPE OF (binary_boolean_expression);
	SELF\binary_generic_expression.operands: 
				LIST [2:2] OF boolean_expression;
END_ENTITY;



ENTITY basic_semantic_unit
ABSTRACT SUPERTYPE OF (ONEOF (
                       SUPPLIER_BSU,
                       CLASS_BSU,
                       PROPERTY_BSU,
                       DATA_TYPE_BSU,
                       SUPPLIER_RELATED_BSU,
                       CLASS_RELATED_BSU));
	
	code: code_type;
	version: version_type;
DERIVE
	dic_identifier: identifier := code + sep_cv + version;
INVERSE
	definition: SET [0:1] OF dictionary_element FOR 
	identified_by;
	referenced_by: SET [0:1] OF content_item 
		FOR dictionary_definition;
END_ENTITY; -- basic_semantic_unit




ENTITY boolean_type
SUBTYPE OF(simple_type);
END_ENTITY; -- boolean_type




ENTITY class_BSU
SUBTYPE OF(basic_semantic_unit);
	SELF\basic_semantic_unit.code: class_code_type;
	defined_by: supplier_BSU;
DERIVE
	absolute_id: identifier 
		:= defined_by.absolute_id + sep_id + dic_identifier;
	known_visible_properties : SET [0:?]OF property_BSU
		:=compute_known_visible_properties(SELF);
	known_visible_data_types: SET [0:?]OF data_type_BSU
		:=compute_known_visible_data_types(SELF);
INVERSE
	subclasses: SET [0:?] OF class FOR its_superclass;
	added_visible_properties:SET [0:?] OF property_BSU 
		FOR name_scope;
	added_visible_data_types:SET [0:?] OF data_type_BSU 
		FOR name_scope;
UNIQUE
	UR1: absolute_id; 
END_ENTITY; -- class_BSU




ENTITY class_instance_type
SUBTYPE OF(complex_type);
	domain: class_BSU;
END_ENTITY; -- class_instance_type




ENTITY class_value_assignment;
	super_class_defined_property: property_BSU;
	assigned_value: value_code_type;
WHERE
	WR1: definition_available_implies(super_class_defined_property,
		('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA'
		+'.NON_QUANTITATIVE_CODE_TYPE' IN TYPEOF(
		super_class_defined_property.
		definition[1]\property_DET.domain)));
	WR2: definition_available_implies(super_class_defined_property,
		(SIZEOF(QUERY(v <* 
		super_class_defined_property.
		definition[1]\property_DET.domain
		\non_quantitative_code_type.domain.its_values |
		assigned_value = v.value_code)) = 1));
END_ENTITY; -- class_value_assignment




ENTITY component_class 
SUBTYPE OF(item_class);
END_ENTITY; -- component_class




ENTITY condition_DET
SUBTYPE OF(property_DET);
END_ENTITY; -- condition_DET




ENTITY data_type_BSU
SUBTYPE OF(basic_semantic_unit);
	SELF\basic_semantic_unit.code: data_type_code_type;
	name_scope: class_BSU;
DERIVE
	absolute_id: identifier := 
		name_scope.defined_by.absolute_id 	
		+ sep_id + name_scope.dic_identifier 	
		+ sep_id + dic_identifier; 			
INVERSE
	defining_class: SET OF class FOR defined_types;
UNIQUE
	absolute_id;
WHERE
	WR1: is_subclass(defining_class[1], name_scope.definition[1]); 
END_ENTITY; -- data_type_BSU




ENTITY data_type_element
SUBTYPE OF(dictionary_element);
	SELF\dictionary_element.identified_by: data_type_BSU;
	names: item_names;
	type_definition: data_type;
END_ENTITY; -- data_type_element




ENTITY dates;
	date_of_original_definition: date_type;
	date_of_current_version: date_type;
	date_of_current_revision: OPTIONAL date_type;
END_ENTITY; -- dates




ENTITY dependent_P_DET
SUBTYPE OF(property_DET);
	depends_on: SET [1:?] OF property_BSU;
WHERE
	WR1: QUERY(p <* depends_on | NOT(definition_available_implies(
		p, ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.CONDITION_DET'

		IN TYPEOF(p.definition[1]))))) = [];
END_ENTITY; -- dependent_P_DET




ENTITY dic_unit;
	structured_representation: unit;
	string_representation: OPTIONAL mathematical_string;
END_ENTITY; -- dic_unit




ENTITY dic_value;
	value_code: value_type;
	meaning: item_names;
	source_doc_of_value: OPTIONAL document;
END_ENTITY; -- dic_value




ENTITY entity_instance_type
SUBTYPE OF(complex_type);
	type_name: SET OF STRING;
END_ENTITY; -- entity_instance_type




ENTITY identified_document
SUBTYPE OF(document);
	document_identifier: source_doc_type;
END_ENTITY; -- identified_document




ENTITY int_currency_type
SUBTYPE OF(int_type);
	currency: OPTIONAL currency_code; 
END_ENTITY; -- int_currency_type




ENTITY int_measure_type
SUBTYPE OF(int_type);
	unit: dic_unit;
END_ENTITY; -- int_measure_type




ENTITY int_type
SUPERTYPE OF (ONEOF (
              INT_MEASURE_TYPE,
              INT_CURRENCY_TYPE,
              NON_QUANTITATIVE_INT_TYPE))

SUBTYPE OF(number_type);
END_ENTITY; -- int_type




ENTITY item_class 
SUPERTYPE OF (ONEOF (
              COMPONENT_CLASS,
              MATERIAL_CLASS))

SUBTYPE OF(class);
	simplified_drawing: OPTIONAL graphics;
	sub_class_properties: SET [0:?] OF property_BSU;
	class_constant_values: SET [0:?] 
		OF class_value_assignment;
	coded_name: OPTIONAL value_code_type;
WHERE
	WR1: QUERY(p <* sub_class_properties
		| NOT(p IN SELF.described_by)) = [];
	WR2: NOT all_class_descriptions_reachable(SELF.identified_by) OR
		(QUERY(va <* class_constant_values | SIZEOF(QUERY(c <*
		va.super_class_defined_property.describes_classes |
		is_subclass(SELF, c) 
		AND (va.super_class_defined_property 
		IN c\item_class.sub_class_properties))) <> 1) = []);
END_ENTITY; -- item_class




ENTITY item_names;
	preferred_name: pref_name_type;
	synonymous_names: SET OF syn_name_type;
	short_name: OPTIONAL short_name_type;
	languages: OPTIONAL present_translations;
	icon : OPTIONAL graphics;
WHERE
	WR1: NOT(EXISTS(languages )) OR (
		('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA'
		+ '.TRANSLATED_LABEL' IN TYPEOF(preferred_name))
		AND (languages :=: preferred_name\translated_label.languages)
		AND (NOT(EXISTS(short_name)) OR ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA'
		+ '.TRANSLATED_LABEL' IN TYPEOF(short_name))
		AND (languages :=: short_name\translated_label.languages))
		AND (QUERY(s <* synonymous_names |
		NOT('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA' +
		'.LABEL_WITH_LANGUAGE' IN TYPEOF(s))) = []));
	WR2: NOT EXISTS(languages) OR (QUERY(s <* synonymous_names |
		EXISTS(s.language) AND NOT(s.language IN
		QUERY(l <* languages.language_codes | TRUE
		))) = []);
	WR3: EXISTS(languages) OR
		(('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.LABEL' IN
		TYPEOF(preferred_name))
		AND (NOT(EXISTS(short_name)) OR
		('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.LABEL' IN
		TYPEOF(short_name)))
		AND (QUERY(s <* synonymous_names |
		'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.LABEL_WITH_LANGUAGE' IN
		TYPEOF(s)) = []));
END_ENTITY; -- item_names




ENTITY label_with_language;
	l: label;
	language: language_code;
END_ENTITY; -- label_with_language




ENTITY level_type
SUBTYPE OF(complex_type);
	levels: LIST [1:4] OF UNIQUE level;
	value_type: simple_type;
WHERE
	WR1: 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.NUMBER_TYPE'

		IN TYPEOF(value_type);
END_ENTITY; -- level_type




ENTITY material_class 
SUBTYPE OF(item_class);
END_ENTITY; -- material_class




ENTITY mathematical_string;
	text_representation: text;
	SGML_representation: OPTIONAL text;
END_ENTITY; -- mathematical_string




ENTITY named_type
SUBTYPE OF(data_type );
	referred_type: data_type_BSU;
END_ENTITY; -- named_type




ENTITY non_dependent_P_DET
SUBTYPE OF(property_DET);
END_ENTITY; -- non_dependent_P_DET




ENTITY non_quantitative_code_type
SUBTYPE OF(string_type);
	domain: value_domain;
WHERE
	WR1: QUERY(v <* domain.its_values | 
		NOT('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.VALUE_CODE_TYPE' IN

		TYPEOF(v.value_code))) = [];
END_ENTITY; -- non_quantitative_code_type




ENTITY non_quantitative_int_type
SUBTYPE OF(int_type);
	domain: value_domain;
WHERE
	WR1: QUERY(v <* domain.its_values | 
		'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.VALUE_CODE_TYPE' IN

		TYPEOF(v.value_code)) = [];
END_ENTITY; -- non_quantitative_int_type




ENTITY non_si_unit
SUBTYPE OF(named_unit);
	name: label;
END_ENTITY; -- non_si_unit




ENTITY number_type
SUPERTYPE OF (ONEOF (
              INT_TYPE,
              REAL_TYPE))

SUBTYPE OF(simple_type); 
END_ENTITY; -- number_type



ENTITY property_BSU
SUBTYPE OF(basic_semantic_unit);
	SELF\basic_semantic_unit.code: property_code_type;
	name_scope: class_BSU;
DERIVE
	absolute_id: identifier :=
		name_scope.defined_by.absolute_id
		+ sep_id + name_scope.dic_identifier
		+ sep_id + dic_identifier;
INVERSE
	describes_classes: SET OF class FOR described_by;
UNIQUE
	UR1: absolute_id;
WHERE
	WR1: QUERY(c <* describes_classes |
		NOT(is_subclass(c, name_scope.definition[1])))= [];
END_ENTITY; -- property_BSU




ENTITY real_currency_type
SUBTYPE OF(real_type);
	currency: OPTIONAL currency_code; 
END_ENTITY; -- real_currency_type




ENTITY real_measure_type
SUBTYPE OF(real_type);
	unit: dic_unit;
END_ENTITY; -- real_measure_type




ENTITY real_type
SUPERTYPE OF (ONEOF (
              REAL_MEASURE_TYPE,
              REAL_CURRENCY_TYPE))

SUBTYPE OF(number_type);
END_ENTITY; -- real_type




ENTITY string_type
SUBTYPE OF(simple_type);
END_ENTITY; -- string_type




ENTITY supplier_BSU 
SUBTYPE OF(basic_semantic_unit); 
	SELF\basic_semantic_unit.code: supplier_code_type; 
DERIVE 
	SELF\basic_semantic_unit.version: version_type := '1';
	absolute_id: identifier := SELF\basic_semantic_unit.code; 
UNIQUE 
	UR1: absolute_id; 
END_ENTITY; -- supplier_BSU




ENTITY supplier_element
SUBTYPE OF(dictionary_element);
	SELF\dictionary_element.identified_by: supplier_BSU;
	org: organization;
	addr: address;
INVERSE
	associated_items: SET [0:?] OF supplier_BSU_relationship 
		FOR relating_supplier;
END_ENTITY; -- supplier_element




ENTITY value_domain;
	its_values: LIST [1:?] OF dic_value;
	source_doc_of_value_domain: OPTIONAL document;
	languages: OPTIONAL present_translations;
	terms: LIST [0:?] OF item_names;
WHERE
	WR1: NOT EXISTS(languages) OR (QUERY(v <* its_values |
		languages :<>: v.meaning.languages) = []);
	WR2: codes_are_unique(its_values);
    WR3: EXISTS(languages) OR (QUERY(v <* its_values |
		EXISTS(v.meaning.languages)) = []);
END_ENTITY; -- value_domain




ENTITY global_language_assignment;
	language: language_code;
END_ENTITY; -- global_language_assignment




ENTITY present_translations; 
	language_codes: LIST [1:?] OF UNIQUE language_code;
UNIQUE
	UR1: language_codes;
END_ENTITY; -- present_translations




ENTITY translated_label; 
	labels: LIST [1:?] OF label;
	languages: present_translations; 
WHERE
	WR1: SIZEOF(labels) = SIZEOF(languages.language_codes);
END_ENTITY; -- translated_label




ENTITY translated_text; 
	texts: LIST [1:?] OF text;
	languages: present_translations; 
WHERE
	WR1: SIZEOF(texts) = SIZEOF(languages.language_codes);
END_ENTITY; -- translated_text




ENTITY context_dependent_property_value
SUBTYPE OF(property_value);
	the_context: LIST[1:?] OF property_value;
WHERE
	WR1: QUERY(c <* SELF.the_context | NOT(is_condition_det(c)))
		= [];
	WR2: is_dependent_p_det(SELF\property_value.prop_def);
	WR3: all_context_parameters_referenced(SELF);
END_ENTITY; -- context_dependent_property_value




ENTITY dic_component_instance
SUPERTYPE OF (
              LIB_COMPONENT_INSTANCE)

SUBTYPE OF(dic_item_instance);
WHERE
	WR1: check_class_type_for_dic_item_instance(SELF);
END_ENTITY; -- dic_component_instance




ENTITY dic_feature_instance
SUPERTYPE OF (
              LIB_FEATURE_INSTANCE)

SUBTYPE OF(dic_item_instance);
WHERE
	WR1: check_class_type_for_dic_item_instance(SELF);
END_ENTITY; -- dic_feature_instance




ENTITY dic_material_instance
SUPERTYPE OF (
              LIB_MATERIAL_INSTANCE)

SUBTYPE OF(dic_item_instance);
WHERE
	WR1: check_class_type_for_dic_item_instance(SELF);
END_ENTITY; -- dic_material_instance




ENTITY int_level_spec_value
SUBTYPE OF(level_spec_value);
	SELF\level_spec_value.values: ARRAY [1:4] OF OPTIONAL INTEGER;
END_ENTITY; -- int_level_spec_value




ENTITY level_spec_value
ABSTRACT SUPERTYPE OF (ONEOF (
                       INT_LEVEL_SPEC_VALUE,
                       REAL_LEVEL_SPEC_VALUE));
	values: ARRAY [1:4] OF OPTIONAL NUMBER;
END_ENTITY; -- level_spec_value




ENTITY lib_component_instance
SUBTYPE OF(dic_component_instance, lib_item_instance);
END_ENTITY; -- lib_component_instance




ENTITY lib_feature_instance
SUBTYPE OF(dic_feature_instance, lib_item_instance);
END_ENTITY; -- lib_feature_instance




ENTITY lib_material_instance
SUBTYPE OF(dic_material_instance, lib_item_instance);
END_ENTITY; -- lib_material_instance




ENTITY null_value;
END_ENTITY; -- null_value




ENTITY property_value;
	its_value: OPTIONAL primitive_value;
	prop_def: property_BSU;
WHERE
	WR1: (EXISTS(SELF.its_value) AND (compatible_type_and_value
		(SELF.prop_def, SELF.its_value) ))
		OR NOT EXISTS(SELF.its_value);
END_ENTITY; -- property_value




ENTITY real_level_spec_value
SUBTYPE OF(level_spec_value);
	SELF\level_spec_value.values: ARRAY [1:4] OF OPTIONAL REAL;
END_ENTITY; -- real_level_spec_value




ENTITY translated_string_value;
	string_values: LIST [1:?] OF string_value;
	languages: present_translations;
WHERE
	WR1: SIZEOF(string_values) = SIZEOF(languages.language_codes);
END_ENTITY; -- translated_string_value




ENTITY binary_class_instance_constructor
SUBTYPE OF(class_instance_constructor,
	binary_class_instance_expression);
	SELF\class_instance_constructor.properties:
		SET [2:2] OF property_assignment;
DERIVE
	SELF\binary_generic_expression.operands:
		LIST [2:2] OF library_expression
		:= collects_referenced_library_expressions(SELF.properties);
WHERE
	WR1: SIZEOF(list_to_set(collects_assigned_properties(
		SELF.properties)))
		= SIZEOF(collects_assigned_properties(SELF.properties));
END_ENTITY; -- binary_class_instance_constructor




ENTITY class_instance_literal
SUBTYPE OF(simple_class_instance_expression, generic_literal);
	the_value: dic_class_instance;
WHERE
	WR1: compatible_class_and_class(
		SELF\class_instance_expression.expr_type,
		SELF.the_value\dic_class_instance.class_def);
END_ENTITY; -- class_instance_literal




ENTITY class_instance_variable
SUBTYPE OF(simple_class_instance_expression, generic_variable);
END_ENTITY; -- class_instance_variable




ENTITY entity_instance_literal
SUBTYPE OF(simple_entity_instance_expression, generic_literal);
	the_value: entity_instance_value;
WHERE
	WR1: (SELF\entity_instance_expression.type_name
		<= TYPEOF(SELF.the_value))
		OR (('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA'
		+ '.UNCONTROLLED_ENTITY_INSTANCE_VALUE')
		IN TYPEOF(SELF.the_value));
END_ENTITY; -- entity_instance_literal




ENTITY entity_instance_variable
SUBTYPE OF(simple_entity_instance_expression, generic_variable);
END_ENTITY; -- entity_instance_variable




ENTITY exists_value
SUBTYPE OF(unary_generic_expression, boolean_defined_function);
	for_variable: library_variable;
DERIVE
	SELF\unary_generic_expression.operand: generic_expression
		:= SELF.for_variable;
END_ENTITY; -- exists_value




ENTITY instance_comparison_equal
SUBTYPE OF(binary_generic_expression, boolean_defined_function);
WHERE
	WR1: ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.LIBRARY_EXPRESSION' IN
		TYPEOF (SELF\binary_generic_expression.operands[1]))
		AND ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.LIBRARY_EXPRESSION'
		IN TYPEOF(SELF\binary_generic_expression.operands[2]));
END_ENTITY; -- instance_comparison_equal




ENTITY int_level_spec_literal
SUBTYPE OF(level_spec_literal);
	SELF\level_spec_literal.the_value: int_level_spec_value;
WHERE
	WR1: 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.INT_TYPE'
		IN TYPEOF(SELF\level_spec_expression.value_type);
	WR2: compatible_level_type_and_instance(
		SELF\level_spec_expression.levels,
		['ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.INT_TYPE'],

		SELF.the_value);
END_ENTITY; -- int_level_spec_literal




ENTITY int_level_spec_variable
SUBTYPE OF(level_spec_variable);
WHERE
	WR1: 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.INT_TYPE'

		IN TYPEOF(SELF\level_spec_expression.value_type);
END_ENTITY; -- int_level_spec_variable




ENTITY multiple_arity_class_instance_constructor
SUBTYPE OF(class_instance_constructor,
	multiple_arity_class_instance_expression);
	SELF\class_instance_constructor.properties:
		SET [2:?] OF property_assignment;
DERIVE
	SELF\multiple_arity_generic_expression.operands:
		LIST [2:?] OF library_expression
		:= collects_referenced_library_expressions(SELF.properties);
WHERE
	WR1: SIZEOF(list_to_set(collects_assigned_properties(
		SELF.properties)))
		= SIZEOF(collects_assigned_properties(SELF.properties));
END_ENTITY; -- multiple_arity_class_instance_constructor




ENTITY property_assignment;
	its_value: OPTIONAL library_expression;
	prop_def: property_BSU;
WHERE
	WR1: (EXISTS(SELF.its_value) AND
		(compatible_type_and_library_expression(
		SELF.prop_def, SELF.its_value)))
		OR NOT EXISTS(SELF.its_value);
END_ENTITY; -- property_assignment




ENTITY real_level_spec_literal
SUBTYPE OF(level_spec_literal);
	SELF\level_spec_literal.the_value: real_level_spec_value;
WHERE
	WR1: 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.REAL_TYPE'
		IN TYPEOF(SELF\level_spec_expression.value_type);
	WR2: compatible_level_type_and_instance(
		SELF\level_spec_expression.levels,
		['ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.REAL_TYPE'],

		SELF.the_value);
END_ENTITY; -- real_level_spec_literal




ENTITY real_level_spec_variable
SUBTYPE OF(level_spec_variable);
WHERE
	WR1: 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.REAL_TYPE'

		IN TYPEOF(SELF\level_spec_expression.value_type);
END_ENTITY; -- real_level_spec_variable




ENTITY unary_class_instance_constructor
SUBTYPE OF(class_instance_constructor,
	unary_class_instance_expression);
	SELF\class_instance_constructor.properties:
		SET [1:1] OF property_assignment;
DERIVE
	SELF\unary_generic_expression.operand: library_expression
		:= collects_referenced_library_expressions(
		SELF.properties)[1];
END_ENTITY; -- unary_class_instance_constructor




ENTITY boolean_column
SUBTYPE OF(simple_column);
	SELF\column.values: LIST [1:?] OF null_or_boolean_value;
END_ENTITY; -- boolean_column




ENTITY class_instance_column
SUBTYPE OF(complex_column);
	class_ref: class_BSU;
	SELF\column.values: LIST [1:?] OF null_or_dic_class_instance;
WHERE
	WR1: QUERY(inst <* SELF\column.values
		| (NOT('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.NULL_VALUE'

		IN TYPEOF(inst)))
		AND (NOT compatible_class_and_class(SELF.class_ref,
		inst\dic_class_instance.class_def))) = [];
END_ENTITY; -- class_instance_column




ENTITY column_traversal_variable_semantics
SUBTYPE OF(variable_semantics);
	ctxt: table_expression;
	domain: variable_semantics;
WHERE
	WR1: SELF.domain IN SELF.ctxt.its_columns;
	WR2: (SIZEOF(USEDIN(SELF,'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA'
		+'.ENVIRONMENT.SEMANTICS')) = 0)
		OR compatible_variable_semantics_and_expression(
		SELF.domain,USEDIN(SELF,'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA'
		+'.ENVIRONMENT.SEMANTICS')[1].syntactic_representation);
END_ENTITY; -- column_traversal_variable_semantics




ENTITY difference_table_expression
SUBTYPE OF(set_table_expression);
END_ENTITY; -- difference_table_expression




ENTITY entity_instance_column
SUBTYPE OF(complex_column );
	type_name: SET [1:?] OF STRING;
	SELF\column.values: LIST [1:?] OF null_or_entity_instance_value;
WHERE
	WR1: QUERY(inst <* SELF\column.values
		| (NOT('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.NULL_VALUE'

		IN TYPEOF(inst)))
		AND (NOT(SELF.type_name <= TYPEOF(inst)))) = [];
END_ENTITY; -- entity_instance_column




ENTITY integer_column
SUBTYPE OF(number_column);
	SELF\column.values: LIST [1:?] OF null_or_integer_value;
WHERE
	WR1: NOT(EXISTS(SELF\formatted_column.value_format)) OR(
		(SELF\formatted_column.value_format) LIKE 'NR1*');
END_ENTITY; -- integer_column




ENTITY intersect_table_expression
SUBTYPE OF(set_table_expression);
END_ENTITY; -- intersect_table_expression




ENTITY int_level_spec_column
SUBTYPE OF(level_spec_column);
	SELF\column.values: LIST [1:?] OF null_or_int_level_spec_value;
END_ENTITY; -- int_level_spec_column




ENTITY in_RDB_table_boolean_expression
SUBTYPE OF(multiple_arity_generic_expression,
		boolean_defined_function,
		SQL_mappable_defined_function);
DERIVE
	from_table: generic_expression :=
		SELF\multiple_arity_generic_expression.operands[1];
	tuple: LIST[1:?] OF generic_expression
		:= QUERY(element <* SELF\multiple_arity_generic_expression
		.operands | 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.EXPRESSION'
		IN TYPEOF(element));
WHERE
	WR1: ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.TABLE_EXPRESSION'
		IN TYPEOF(from_table))
		AND is_sql_mappable_table_expression(from_table);
	WR2: SIZEOF(QUERY(simple_expr <*
		QUERY(expr <* SELF\multiple_arity_generic_expression.operands
		| ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.EXPRESSION'

		IN TYPEOF(expr))) | is_sql_mappable(simple_expr)))
		= SIZEOF(SELF\multiple_arity_generic_expression.operands)- 1;
	WR3: SIZEOF(from_table\table_expression.its_columns)
		= SIZEOF(tuple);
	WR4: compatible_list_variable_semantics_and_expressions
		(SELF.from_table\table_expression.its_columns, SELF.tuple);
	WR5: QUERY(e <* tuple | QUERY(v <* used_variables(e)
		| ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA'
		+ '.COLUMN_TRAVERSAL_VARIABLE_SEMANTICS')
		IN TYPEOF(v.interpretation.semantics)) <> [] ) = [];
END_ENTITY; -- in_RDB_table_boolean_expression




ENTITY multiple_arity_cartesian_product
SUBTYPE OF(multiple_arity_table_expression);
	SELF\multiple_arity_generic_expression.operands:
		LIST [2:?] OF table_expression;
END_ENTITY; -- multiple_arity_cartesian_product




ENTITY natural_join_expression
SUBTYPE OF(binary_table_expression);
DERIVE
	table_1: table_expression :=
		SELF\binary_table_expression.operands[1];
	table_2: table_expression :=
		SELF\binary_table_expression.operands[2];
WHERE
	WR1: SIZEOF(list_to_set(table_1\table_expression.its_columns) *
		list_to_set(table_2\table_expression.its_columns)) > 0;
END_ENTITY; -- natural_join_expression




ENTITY projection_expression
SUBTYPE OF(unary_table_expression);
	argts_var: SET[1:?] OF variable_semantics;
DERIVE
	from_table: table_expression :=
		SELF\unary_table_expression.operand;
WHERE
	WR1: SELF.argts_var <= list_to_set(SELF\unary_table_expression.
		operand.its_columns);
END_ENTITY; -- projection_expression




ENTITY RDB_table_extension
SUBTYPE OF(table_extension);
	SELF\table_extension.content: LIST[1:?] OF UNIQUE simple_column;
WHERE
	WR1: (SIZEOF(USEDIN(SELF\table_extension.table_identifier,
		'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.TABLE_SPECIFICATION' +
		'.TABLE_IDENTIFIER')) = 0) OR
		('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.RDB_TABLE_SPECIFICATION'
		IN TYPEOF(USEDIN(SELF\table_extension.table_identifier,
		'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.TABLE_SPECIFICATION' +

		'.TABLE_IDENTIFIER')[1]));
END_ENTITY; -- RDB_table_extension




ENTITY RDB_table_specification
SUBTYPE OF(table_specification);
WHERE
	WR1: QUERY(col <* SELF\table_specification.column_meaning |
		QUERY(v <* syntax_of(col) |
		NOT('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.VARIABLE'
			IN TYPEOF(v))) <> []) = [];
	WR2: (SIZEOF(USEDIN(SELF\table_specification.table_identifier,
		'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.TABLE_EXTENSION' +
		'.TABLE_IDENTIFIER')) = 0)
		OR ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.RDB_TABLE_EXTENSION'
		IN TYPEOF(USEDIN(SELF\table_specification.table_identifier,
		'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.TABLE_EXTENSION'+

		'.TABLE_IDENTIFIER')[1]));
END_ENTITY; -- RDB_table_specification




ENTITY RDB_table_variable
SUBTYPE OF(table_variable);
WHERE
	WR1: QUERY(col <* SELF\table_expression.its_columns |
		QUERY(v <* syntax_of(col) |
		NOT('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.VARIABLE'

		IN TYPEOF(v))) <> []) = [];
END_ENTITY; -- RDB_table_variable




ENTITY real_column
SUBTYPE OF(number_column);
	SELF\column.values: LIST [1:?] OF null_or_real_value;
WHERE
	WR1: NOT(EXISTS(SELF\formatted_column.value_format)) OR(
		(SELF\formatted_column.value_format) LIKE 'NR2*');
END_ENTITY; -- real_column




ENTITY real_level_spec_column
SUBTYPE OF(level_spec_column);
	SELF\column.values: LIST [1:?] OF null_or_real_level_spec_value;
END_ENTITY; -- real_level_spec_column




ENTITY select_expression
SUBTYPE OF(table_expression, binary_generic_expression);
DERIVE
	from_table: generic_expression :=
		SELF\binary_generic_expression.operands[1];
	condition: generic_expression :=
		SELF\binary_generic_expression.operands[2];
WHERE
	WR1: 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.TABLE_EXPRESSION'
		IN TYPEOF(SELF.from_table);
	WR2: 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.BOOLEAN_EXPRESSION'
		IN TYPEOF(SELF.condition);
	WR3: QUERY(va <* used_variables(SELF.condition) |
		NOT('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.VARIABLE'

		IN TYPEOF(va))) = [];
	WR4: QUERY(v <* used_variables(SELF.condition) |
		(NOT(check_iterator_context(SELF, v)) OR NOT
		check_iterator_domain_uniqueness(SELF, v))) = [];
END_ENTITY; -- select_expression




ENTITY string_column
SUBTYPE OF(formatted_column);
	SELF\column.values: LIST [1:?] OF
			null_or_translatable_string_value;
WHERE
	WR1: NOT (EXISTS(SELF\formatted_column.value_format)) OR (
		(((SELF\formatted_column.value_format) LIKE 'A*')
		OR ((SELF\formatted_column.value_format) LIKE 'M*')
		OR ((SELF\formatted_column.value_format) LIKE 'N*')
		OR ((SELF\formatted_column.value_format) LIKE 'X*'))
		AND NOT((SELF\formatted_column.value_format) LIKE 'NR*'));
	WR2: same_translations_for_string_values(SELF\column.values);
END_ENTITY; -- string_column




ENTITY table_extension
SUPERTYPE OF (
              RDB_TABLE_EXTENSION);
	table_identifier: table_identification;
	content: LIST[1:?] OF UNIQUE column;
	revision_of_content: revision_type;
	content_revision_date: date_type;
WHERE
	WR1: QUERY(col <* SELF.content | SIZEOF(col.values) <>
		SIZEOF(SELF.content[1].values)) = [];
	WR2: (SIZEOF(USEDIN(SELF.table_identifier,
		'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA' +
		'.TABLE_SPECIFICATION.TABLE_IDENTIFIER')) = 0) OR
		compatible_list_variable_semantics_and_columns(
		USEDIN(SELF.table_identifier,
		'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA' +
		'.TABLE_SPECIFICATION.TABLE_IDENTIFIER')[1].
		column_meaning, SELF.content);
	WR3: (SIZEOF(USEDIN(SELF.table_identifier,
		'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA' +
		'.TABLE_SPECIFICATION.TABLE_IDENTIFIER')) = 0) OR
		no_null_values_in_key_columns(USEDIN(SELF.table_identifier,
		'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA' +
		'.TABLE_SPECIFICATION.TABLE_IDENTIFIER')[1].
		column_meaning, USEDIN(SELF.table_identifier,
		'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA' +
		'.TABLE_SPECIFICATION.TABLE_IDENTIFIER')[1].
		key, SELF.content);
        WR4: same_translations_for_table_extension(SELF.content);
END_ENTITY; -- table_extension




ENTITY table_literal
SUBTYPE OF(simple_table_expression, generic_literal);
	the_value: table_identification;
WHERE
	WR1: SIZEOF(USEDIN(SELF.the_value,
		'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.TABLE_SPECIFICATION'

		+ '.TABLE_IDENTIFIER')) = 1;
END_ENTITY; -- table_literal




ENTITY table_specification
SUPERTYPE OF (
              RDB_TABLE_SPECIFICATION);
	table_identifier: table_identification;
	column_meaning: LIST[1:?] OF UNIQUE variable_semantics;
	key: SET[1:?] OF variable_semantics;
WHERE
	WR1: SELF.key <= list_to_set(SELF.column_meaning);
END_ENTITY; -- table_specification




ENTITY table_variable
SUPERTYPE OF (
              RDB_TABLE_VARIABLE)

SUBTYPE OF(simple_table_expression, generic_variable);
	structure: LIST [1:?] OF variable_semantics;
	its_key: SET [1:?] OF variable_semantics;
WHERE
	WR1: SELF.its_key <= list_to_set(SELF.structure);
END_ENTITY; -- table_variable




ENTITY union_table_expression
SUBTYPE OF(set_table_expression);
END_ENTITY; -- union_table_expression




ENTITY self_class_code_semantics
SUBTYPE OF(self_class_name_semantics);
END_ENTITY; -- self_class_code_semantics




ENTITY self_class_preferred_name_semantics
SUBTYPE OF(self_class_name_semantics);
END_ENTITY; -- self_class_preferred_name_semantics




ENTITY self_class_short_name_semantics
SUBTYPE OF(self_class_name_semantics);
END_ENTITY; -- self_class_short_name_semantics




ENTITY self_class_supplier_code_semantics
SUBTYPE OF(self_class_name_semantics);
END_ENTITY; -- self_class_supplier_code_semantics




ENTITY self_class_version_semantics
SUBTYPE OF(self_class_name_semantics);
END_ENTITY; -- self_class_version_semantics




ENTITY self_property_class_code_semantics
SUBTYPE OF(self_property_name_semantics );
END_ENTITY; -- self_property_class_code_semantics




ENTITY self_property_class_version_semantics
SUBTYPE OF(self_property_name_semantics );
END_ENTITY; -- self_property_class_version_semantics




ENTITY self_property_code_semantics
SUBTYPE OF(self_property_name_semantics );
END_ENTITY; -- self_property_code_semantics




ENTITY self_property_preferred_name_semantics
SUBTYPE OF(self_property_name_semantics );
END_ENTITY; -- self_property_preferred_name_semantics




ENTITY self_property_short_name_semantics
SUBTYPE OF(self_property_name_semantics );
END_ENTITY; -- self_property_short_name_semantics




ENTITY self_property_value_semantics
SUBTYPE OF(self_property_semantics);
WHERE
	WR1: QUERY(v <* syntax_of(SELF)
		| NOT compatible_type_and_library_expression(
		BSU_of_property_semantics(SELF), v)) = [];
END_ENTITY; -- self_property_value_semantics




ENTITY self_property_version_semantics
SUBTYPE OF(self_property_name_semantics );
END_ENTITY; -- self_property_version_semantics




ENTITY sub_property_path;
	the_property: property_BSU;
	its_own_property: OPTIONAL sub_property_path;
WHERE
	WR1: (NOT(EXISTS(SELF.its_own_property)))
		OR (data_type_typeof(SELF.the_property) = [])
		OR
		(('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.CLASS_INSTANCE_TYPE'

		IN data_type_typeof(SELF.the_property))
		AND applicable_properties(data_type_class_of(
		SELF.the_property)[1],[SELF.its_own_property.the_property]));
END_ENTITY; -- sub_property_path




ENTITY constant_range_defined_domain
SUBTYPE OF(simple_domain);
	minimal: literal_number;
	maximal: literal_number;
	step: OPTIONAL literal_number;
WHERE
	WR1: SIZEOF(SELF\simple_domain.referenced_by.item_of.defines)
		= 1;
	WR2: minimal.the_value <= maximal.the_value;
	WR3: QUERY(va <* collects_variables(
		SELF\simple_domain.referenced_by.item_of.defines) | NOT
		('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.NUMERIC_VARIABLE'

		IN TYPEOF(va))) = [];
	WR4: (NOT EXISTS(SELF.step)) OR (SELF.step.the_value > 0);
END_ENTITY; -- constant_range_defined_domain




ENTITY domain_restriction
SUPERTYPE OF (
              FUNCTIONAL_DOMAIN_RESTRICTION);
	defines: SET[1:?] OF variable_semantics;
	assumes: SET[0:?] OF variable_semantics;
	domains: SET[1:?] OF guarded_simple_domain;
	constraint_description: OPTIONAL message;
DERIVE
	base_tables: SET [0:?] OF table_identification
		:= used_tables_in_domain(SELF);
WHERE
	WR1: SIZEOF(QUERY(g <* SELF.domains |
		'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.OTHERS'

		IN TYPEOF(g.guard))) = 1;
END_ENTITY; -- domain_restriction




ENTITY functional_domain_restriction
SUBTYPE OF(domain_restriction);
	SELF\domain_restriction.domains:
		SET[1:?] OF guarded_functional_domain;
END_ENTITY; -- functional_domain_restriction




ENTITY guarded_functional_domain
SUBTYPE OF(guarded_simple_domain);
	SELF\guarded_simple_domain.domain: simple_functional_domain;
END_ENTITY; -- guarded_functional_domain




ENTITY guarded_simple_domain;
	guard: boolean_expression_or_others;
	domain: simple_domain;
INVERSE
	item_of: domain_restriction FOR domains;
WHERE
	WR1: variables_belong_to_assumes(SELF);
END_ENTITY; -- guarded_simple_domain




ENTITY library_expression_defined_value
SUBTYPE OF(simple_functional_domain);
	its_value: library_expression;
WHERE
	WR1: SIZEOF(SELF\simple_domain.referenced_by.item_of.defines)
		= 1;
	WR2: QUERY(va <* collects_variables
		(SELF\simple_domain.referenced_by.item_of.defines)
		| NOT compatible_variable_and_library_expression
		(va, SELF.its_value)) = [];
	WR3: collects_var_sem(used_variables(SELF.its_value))
		<= SELF\simple_domain.referenced_by.item_of.assumes;
END_ENTITY; -- library_expression_defined_value




ENTITY null_defined_value
SUBTYPE OF(simple_functional_domain);
WHERE
	WR1: SIZEOF(SELF\simple_domain.referenced_by.item_of.defines)
		= 1;
END_ENTITY; -- null_defined_value




ENTITY others;
END_ENTITY; -- others




ENTITY predicate_defined_domain
SUBTYPE OF(simple_domain);
	constraint: boolean_expression;
WHERE
	WR1: collects_var_sem(used_variables(SELF.constraint))
		<= SELF\simple_domain.referenced_by.item_of.defines +
		SELF\simple_domain.referenced_by.item_of.assumes;
END_ENTITY; -- predicate_defined_domain




ENTITY subclass_defined_domain
SUBTYPE OF(simple_domain);
	from_class: class_BSU;
WHERE
	WR1: SIZEOF(SELF\simple_domain.referenced_by.item_of.defines)
		= 1;
	WR2: QUERY(va <* collects_variables(
		SELF\simple_domain.referenced_by.item_of.defines)
		| NOT('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA'
		+ '.CLASS_INSTANCE_VARIABLE' IN TYPEOF(va))) = [];
	WR3: QUERY(va <* collects_variables(
		SELF\simple_domain.referenced_by.item_of.defines)
		| NOT is_subclass(SELF.from_class.definition[1],
		va\class_instance_expression.expr_type.definition[1])) = [];
END_ENTITY; -- subclass_defined_domain




ENTITY table_defined_domain
SUBTYPE OF(simple_domain);
	from_table: table_expression;
WHERE
	WR1: SELF\simple_domain.referenced_by.item_of.defines
		<= list_to_set(collects_columns(SELF.from_table));
	WR2: QUERY(sem <* collects_var_sem(
		used_variables(SELF.from_table))
		| NOT((sem IN
		(SELF\simple_domain.referenced_by.item_of.assumes
		+ SELF\simple_domain.referenced_by.item_of.defines))
		OR ((('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA'
		+ '.COLUMN_TRAVERSAL_VARIABLE_SEMANTICS')
		IN TYPEOF(sem))) AND
		(sem\column_traversal_variable_semantics.domain
		IN collects_columns(SELF.from_table)))) = [];
END_ENTITY; -- table_defined_domain




ENTITY table_defined_value
SUBTYPE OF(simple_functional_domain);
	from_table: table_expression;
WHERE
	WR1: SELF\simple_domain.referenced_by.item_of.defines
		<= list_to_set(SELF.from_table\table_expression.its_columns);
	WR2: SELF\simple_domain.referenced_by.item_of.assumes
		>= SELF.from_table\table_expression.the_key;
	WR3: QUERY(sem <* collects_var_sem(
		used_variables(SELF.from_table))
		| NOT((sem IN
		(SELF\simple_domain.referenced_by.item_of.assumes
		+ SELF\simple_domain.referenced_by.item_of.defines))
		OR ((('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA'
		+ '.COLUMN_TRAVERSAL_VARIABLE_SEMANTICS')
		IN TYPEOF(sem))) AND
		(sem\column_traversal_variable_semantics.domain
		IN collects_columns(from_table)))) = [];
END_ENTITY; -- table_defined_value




ENTITY type_defined_domain
SUBTYPE OF(simple_domain);
WHERE
	WR1: SIZEOF(SELF\simple_domain.referenced_by
		.item_of.defines) = 1;
END_ENTITY; -- type_defined_domain




ENTITY variable_range_defined_domain
SUBTYPE OF(simple_domain);
	minimal: numeric_expression;
	maximal: numeric_expression;
	step: OPTIONAL numeric_expression;
WHERE
	WR1: SIZEOF(SELF\simple_domain.referenced_by.item_of.defines)
		= 1;
	WR2: collects_var_sem(used_variables(SELF.minimal)
		+ used_variables(SELF.maximal))
		<= SELF\simple_domain.referenced_by.item_of.assumes;
	WR3: NOT(EXISTS(SELF.step)) OR
		(collects_var_sem(used_variables(SELF.step))
		<= SELF\simple_domain.referenced_by.item_of.assumes);
	WR4: QUERY(va <* collects_variables
		(SELF\simple_domain.referenced_by.item_of.defines)
		| NOT('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.NUMERIC_VARIABLE'

		IN TYPEOF(va))) = [];
END_ENTITY; -- variable_range_defined_domain




ENTITY a_posteriori_case_of
SUBTYPE OF(a_posteriori_semantic_relationship);
	source: class_BSU;
	is_case_of: class_BSU;
	corresponding_properties: SET [0:?] OF
		LIST [2:2] OF property_BSU;
WHERE
	WR1: definition_available_implies(SELF.source,
		('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.ITEM_CLASS'
		IN TYPEOF(SELF.source.definition[1]))
		OR (('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA'
		 + '.ABSTRACT_FUNCTIONAL_MODEL_CLASS')
		IN TYPEOF(SELF.source.definition[1])));
	WR2: definition_available_implies(SELF.source,
		(('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.ITEM_CLASS'
		IN TYPEOF(SELF.source.definition[1]))
		AND (definition_available_implies(SELF.is_case_of,
		('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.ITEM_CLASS'
		IN TYPEOF(SELF.source.definition[1])))))
		OR (('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA'
		 + '.ABSTRACT_FUNCTIONAL_MODEL_CLASS'
		IN TYPEOF(SELF.source.definition[1]))
		AND (definition_available_implies(SELF.is_case_of,
		('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA'
		 + '.ABSTRACT_FUNCTIONAL_MODEL_CLASS'
		IN TYPEOF(SELF.source.definition[1]))))));
	WR3: QUERY(couple <* SELF.corresponding_properties
		| NOT compatible_types(couple[1], couple[2])) = [];
	WR4: QUERY(couple <* SELF.corresponding_properties
		| (NOT applicable_properties(SELF.source,[couple[1]])
		OR NOT applicable_properties(SELF.is_case_of,[couple [2]])))
		= [];
END_ENTITY; -- a_posteriori_case_of




ENTITY class_document_relationship
SUBTYPE OF(class_BSU_relationship);
	SELF\class_BSU_relationship.related_tokens:
		SET [1:?] OF document_BSU;
WHERE
	WR1: visible_documents(
		SELF\class_BSU_relationship.relating_class.identified_by,
		SELF.related_tokens);
END_ENTITY; -- class_document_relationship




ENTITY class_table_relationship
SUBTYPE OF(class_BSU_relationship);
	SELF\class_BSU_relationship.related_tokens:
		SET [1:?] OF table_BSU;
WHERE
	WR1: applicable_properties_for_applicable_tables(SELF);
	WR2: visible_tables(SELF\class_BSU_relationship.relating_class.
		identified_by, SELF.related_tokens);
END_ENTITY; -- class_table_relationship




ENTITY component_class_case_of
SUBTYPE OF(item_class_case_of, component_class);
WHERE
	WR1: check_is_case_of_referenced_classes_definition(SELF);
END_ENTITY; -- component_class_case_of




ENTITY dictionary
SUPERTYPE OF (
              DICTIONARY_IN_STANDARD_FORMAT);
	identified_by: OPTIONAL dictionary_identification;
	is_complete: OPTIONAL BOOLEAN;
	updates: OPTIONAL dictionary_identification;
	update_agreement: OPTIONAL identifier;
	referenced_dictionaries: SET [0:?] OF dictionary_identification;
	responsible_supplier: supplier_BSU;
	library_structure: library_iim_identification;
	base_protocols: SET [0:?] OF external_file_protocol;
	supported_vep: SET [0:?] OF
		view_exchange_protocol_identification;
	referred_suppliers: SET [1:?] OF supplier_BSU;
	contained_classes: LIST [0:?] OF UNIQUE class_BSU;
	a_posteriori_semantic_relationships: SET [0:?] OF
		a_posteriori_semantic_relationship;
	names: item_names;
	note: OPTIONAL note_type;
	remark: OPTIONAL remark_type;
WHERE
	WR1: prefix_ordered_class_list(SELF.contained_classes);
	WR2: (EXISTS(identified_by) AND EXISTS(is_complete))
		OR (NOT(EXISTS(identified_by)) AND NOT(EXISTS(is_complete)));
	WR3: NOT(EXISTS(identified_by)) OR
		(SELF.identified_by.defined_by = SELF.responsible_supplier);
	WR4: NOT(EXISTS(updates)) OR
		(EXISTS(identified_by) AND (is_complete = FALSE));
	WR5: NOT(EXISTS(update_agreement)) OR EXISTS(updates);
	WR6: NOT(EXISTS(updates)) OR
		((updates.code = identified_by.code)
		AND (updates.defined_by = identified_by.defined_by)
		AND (updates.version <= identified_by.version)
		AND (NOT(updates.version = identified_by.version) OR
		(updates.revision < identified_by.revision)));
END_ENTITY; -- dictionary




ENTITY dictionary_identification;
	code: dictionary_code_type;
	version: version_type;
	revision: revision_type;
	defined_by: supplier_bsu;
DERIVE
	absolute_id: identifier :=
		defined_by.absolute_id + sep_id + code + sep_cv + version;
INVERSE
	definition: SET [0:1] OF dictionary FOR identified_by;
UNIQUE
	UR1: absolute_id;
END_ENTITY;




ENTITY dictionary_in_standard_format
SUBTYPE OF(dictionary);
WHERE
	WR1: QUERY(int <* SELF\dictionary.base_protocols
		| ((SIZEOF(QUERY(vep <* SELF\dictionary.supported_vep
		| int IN vep\data_exchange_specification_identification
		.external_file_protocols )) = 0) AND NOT(int IN
		SELF\dictionary.library_structure
		.external_file_protocols))) = [];
END_ENTITY; -- dictionary_in_standard_format




ENTITY document_BSU
SUBTYPE OF(class_related_BSU);
	name_scope: class_BSU;
	SELF\basic_semantic_unit.code: document_code_type;
DERIVE
	absolute_id: identifier :=
		name_scope.defined_by.dic_identifier + sep_id
		+ name_scope.dic_identifier + sep_id
		+ dic_identifier;
INVERSE
	associate_to_class: class_BSU_relationship FOR related_tokens;
UNIQUE
	UR1: absolute_id;
END_ENTITY; -- document_BSU




ENTITY document_element
SUPERTYPE OF (ONEOF (
              DOCUMENT_ELEMENT_WITH_HTTP_ACCESS,
              DOCUMENT_ELEMENT_WITH_TRANSLATED_HTTP_ACCESS))

SUBTYPE OF(class_related_dictionary_element);
	SELF\dictionary_element.identified_by: document_BSU;
	authors: OPTIONAL LIST [1:?] OF person;
	publishing_organisation: organization;
END_ENTITY; -- document_element




ENTITY document_element_with_http_access
SUBTYPE OF(document_element);
	remote_location: absolute_URL_type;
END_ENTITY; -- document_element_with_http_access




ENTITY document_element_with_translated_http_access
SUBTYPE OF(document_element);
	remote_locations: LIST [1:?] OF absolute_URL_type;
	languages: present_translations;
WHERE
	WR1: SIZEOF(remote_locations) = SIZEOF(languages.language_codes);
END_ENTITY; -- document_element_with_translated_http_access




ENTITY feature_class
SUBTYPE OF(item_class);
WHERE
	WR1: NOT(('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.'
		+ 'COMPONENT_CLASS') IN TYPEOF(SELF));
	WR2: NOT(('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.'

		+ 'MATERIAL_CLASS') IN TYPEOF(SELF));
END_ENTITY; -- feature_class




ENTITY feature_class_case_of
SUBTYPE OF(item_class_case_of, feature_class);
WHERE
	WR1: check_is_case_of_referenced_classes_definition(SELF);
END_ENTITY; -- feature_class_case_of



ENTITY item_class_case_of
SUPERTYPE OF (ONEOF (
              COMPONENT_CLASS_CASE_OF,
              MATERIAL_CLASS_CASE_OF,
              FEATURE_CLASS_CASE_OF))

SUBTYPE OF(item_class, a_priori_semantic_relationship);
	is_case_of: SET [1:?] OF class_BSU;
	imported_properties: LIST [0:?] OF property_BSU;
	imported_types: SET [0:?]OF data_type_BSU;
	imported_tables: SET [0:?] OF table_BSU;
	imported_documents: SET [0:?] OF document_BSU;
DERIVE
	SELF\a_priori_semantic_relationship.referenced_classes:
		SET [1:?] OF class_BSU
		:= SELF.is_case_of;
	SELF\a_priori_semantic_relationship.referenced_properties:
		LIST [0:?] OF property_BSU := SELF.imported_properties;
	SELF\a_priori_semantic_relationship.referenced_data_types:
		SET [0:?] OF data_type_BSU := SELF.imported_types;
	SELF\a_priori_semantic_relationship.referenced_tables:
		SET [0:?] OF table_BSU := SELF.imported_tables;
	SELF\a_priori_semantic_relationship.referenced_documents:
		SET [0:?] OF document_BSU := SELF.imported_documents;
WHERE
	WR1: superclass_of_item_is_item(SELF);
	WR2: check_is_case_of_referenced_classes_definition(SELF);
END_ENTITY; -- item_class_case_of




ENTITY library_iim_identification
SUBTYPE OF(data_exchange_specification_identification);
END_ENTITY; -- library_iim_identification




ENTITY material_class_case_of
SUBTYPE OF(item_class_case_of, material_class);
WHERE
	WR1: check_is_case_of_referenced_classes_definition(SELF);
END_ENTITY; -- material_class_case_of




ENTITY referenced_document
SUBTYPE OF(document);
	document_reference: document_BSU;
WHERE
	WR1: NOT('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA' +
		'.IDENTIFIED_DOCUMENT' IN TYPEOF(SELF));
END_ENTITY; -- referenced_document




ENTITY referenced_graphics
SUBTYPE OF(graphics);
	graphics_reference: document_BSU;
END_ENTITY; -- referenced_graphics




ENTITY RDB_table_content
SUBTYPE OF(table_content, RDB_table_extension);
WHERE
	WR1: definition_available_implies(
		SELF\content_item.dictionary_definition,
		'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.RDB_TABLE_ELEMENT'

		IN TYPEOF(SELF\content_item.dictionary_definition.
		definition[1]));
END_ENTITY; -- RDB_table_content




ENTITY RDB_table_element
SUBTYPE OF(table_element, RDB_table_specification);
WHERE
	WR1: QUERY(temp <* SELF.column_meaning
		| simple_type_data_type(temp\property_semantics.the_property)
		= FALSE) = [];
END_ENTITY; -- RDB_table_element



ENTITY table_BSU
SUBTYPE OF(class_related_BSU, table_identification);
	name_scope: class_BSU;
	SELF\basic_semantic_unit.code: table_code_type;
DERIVE
	absolute_id: identifier:= name_scope.
		defined_by.dic_identifier + sep_id
		+ name_scope.dic_identifier + sep_id
		+ dic_identifier;
UNIQUE
	UR1: absolute_id;
END_ENTITY; -- table_BSU




ENTITY table_content
SUBTYPE OF(content_item, table_extension);
	SELF\content_item.dictionary_definition: table_BSU;
DERIVE
	SELF\table_extension.table_identifier: table_bsu
		:= SELF\content_item.dictionary_definition;
WHERE
	WR1: definition_available_implies(
		SELF\content_item.dictionary_definition,
		'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.TABLE_ELEMENT'

		IN TYPEOF(SELF\content_item.dictionary_definition.
		definition[1]));
	WR2: compatible_content_and_specification(SELF);
END_ENTITY; -- table_content




ENTITY table_element
SUBTYPE OF(class_related_dictionary_element, table_specification);
	SELF\dictionary_element.identified_by: table_BSU;
	SELF\table_specification.column_meaning:
		LIST [1:?] OF UNIQUE self_property_semantics;
	SELF\table_specification.key:
		SET [1:?] OF self_property_semantics;
DERIVE
	SELF\table_specification.table_identifier: table_BSU
		:= SELF.identified_by;
WHERE
	WR1: QUERY (temp <* SELF.column_meaning
		| NOT visible_properties (
		SELF\dictionary_element.identified_by.name_scope,
		get_property_BSU_from_property_semantics([temp]))
		AND NOT applicable_properties(
		SELF\dictionary_element.identified_by.name_scope,
		list_to_set(get_property_BSU_from_property_semantics(
		[temp])))) = [];
END_ENTITY; -- table_element




ENTITY item_class_extension
SUBTYPE OF(implicit_model_class_extension);
	selection_context_parameters: LIST [0:?] OF UNIQUE
		opt_or_mand_property_BSU;
	identification_characteristics: LIST [0:?] OF UNIQUE
		opt_or_mand_property_BSU;
	derived_characteristics: LIST [0:?] OF UNIQUE
		opt_or_mand_property_BSU;
	context_dependent_characteristics: LIST [0:?] OF UNIQUE
		opt_or_mand_property_BSU;
	identified_item: BOOLEAN;
	supplier_identification: OPTIONAL string_expression;
	supplier_designation: OPTIONAL string_expression;
	access_icon: OPTIONAL A9_illustration;
	content_msg: OPTIONAL message;
	create_icon: LIST [0:?] OF A6_illustration;
	create_msg: OPTIONAL message;
	class_presentation_on_paper: LIST [0:?] OF illustration;
	class_presentation_on_screen: LIST [0:?] OF illustration;
DERIVE
	SELF\implicit_model_class_extension.selectable_properties:
		LIST [0:?] OF UNIQUE opt_or_mand_property_BSU
		:= SELF.selection_context_parameters
		+ SELF.identification_characteristics;
	SELF\implicit_model_class_extension.derived_properties:
		LIST [0:?] OF UNIQUE opt_or_mand_property_BSU
		:= SELF.derived_characteristics
		+ SELF.context_dependent_characteristics;
	SELF\implicit_model_class_extension.required_properties:
		LIST [0:?] OF UNIQUE opt_or_mand_property_BSU
		:= [];
WHERE
	WR1: definition_available_implies(
		SELF\content_item.dictionary_definition,
		'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.ITEM_CLASS' IN

		TYPEOF((SELF\content_item.dictionary_definition.
		definition[1])));
	WR2: QUERY(elt <* SELF.selection_context_parameters |
		in_typeof('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA' +
		'.CONDITION_DET', elt)) = SELF.selection_context_parameters;
	WR3: QUERY(elt <* SELF.identification_characteristics |
		in_typeof('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA' +
		'.NON_DEPENDENT_P_DET', elt)) =
		SELF.identification_characteristics;
	WR4: QUERY(elt <* SELF.identification_characteristics |
		(data_type_typeof(elt.property) <> [])
		AND NOT('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA' +
		'.SIMPLE_TYPE' IN data_type_typeof(elt.property))
		AND NOT('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA' +
		'.CLASS_INSTANCE_TYPE' IN data_type_typeof(elt.property))
		) = [];
	WR5: QUERY(elt <* SELF.derived_characteristics |
		in_typeof('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA' +
		'.NON_DEPENDENT_P_DET', elt)) = SELF.derived_properties;
	WR6: QUERY(elt <* SELF.context_dependent_characteristics |
		in_typeof('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA' +
		'.DEPENDENT_P_DET', elt)) =
		SELF.context_dependent_characteristics;
	WR7: NOT(EXISTS(SELF.access_icon)) OR (SELF.access_icon IN
		SELF\model_class_extension.referenced_external_items);
	WR8: NOT(EXISTS(SELF.content_msg)) OR (SELF.content_msg IN
		SELF\model_class_extension.referenced_external_items);
	WR9: list_to_set(SELF.create_icon)
		<= SELF\model_class_extension.referenced_external_items;
	WR10: NOT(EXISTS(SELF.create_msg)) OR (SELF.create_msg IN
		SELF\model_class_extension.referenced_external_items);
	WR11: list_to_set(SELF.class_presentation_on_paper)
		<= SELF\model_class_extension.referenced_external_items;
	WR12: list_to_set(SELF.class_presentation_on_screen)
		<= SELF\model_class_extension.referenced_external_items;
	WR13: QUERY(icon <* SELF.class_presentation_on_paper |
		(NOT EXISTS(icon.width)) OR (icon.kind_of_content
		= illustration_type.not_static_picture)) = [];
	WR14: QUERY(icon <* SELF.class_presentation_on_screen |
		(NOT EXISTS(icon.width))) = [];
END_ENTITY; -- item_class_extension




ENTITY library
SUPERTYPE OF (
              LIBRARY_IN_STANDARD_FORMAT)

SUBTYPE OF(dictionary);
	linked_interfaces: SET [0:?] OF external_file_protocol;
WHERE
	WR1: QUERY(class <* SELF\dictionary.contained_classes |
		referenced_veps_exist_in_supported_veps(
		SELF, class)) = [];
	WR2: QUERY(class <* SELF.contained_classes |
		referenced_protocols_exist_in_supported_protocols(
		SELF, class)) = [];
	WR3: QUERY(int <* SELF.linked_interfaces
		| NOT(('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA'+
		'.LINKED_INTERFACE_PROGRAM_PROTOCOL')
		IN TYPEOF(int))) = [];
END_ENTITY; -- library




ENTITY library_in_standard_format
SUBTYPE OF(library, dictionary_in_standard_format);
WHERE
	WR1: QUERY(int <* SELF\library.linked_interfaces
		| SIZEOF(QUERY(vep <* SELF\dictionary.supported_vep
		| int\external_file_protocol.base_protocol IN
		vep\data_exchange_specification_identification
		.external_file_protocols )) = 0) = [];
END_ENTITY; -- library_in_standard_format




ENTITY opt_or_mand_property_BSU;
	property: property_BSU;
	is_optional: BOOLEAN;
	displayable: BOOLEAN;
END_ENTITY; -- opt_or_mand_property_BSU


ENTITY application_context;
  application          : text;
INVERSE
  context_elements : SET [1:?] OF  application_context_element
                                FOR frame_of_reference;
END_ENTITY;



ENTITY application_context_element
  ;
  name                 : label;
  frame_of_reference   : application_context;
END_ENTITY;




ENTITY A6_illustration
SUBTYPE OF(illustration);
END_ENTITY; -- A6_illustration




ENTITY A9_illustration
SUBTYPE OF(illustration);
END_ENTITY; -- A9_illustration




ENTITY document_content
SUBTYPE OF(class_BSU_related_content);
	SELF\content_item.dictionary_definition: document_BSU;
	SELF\external_item.used_protocol: data_protocol;
END_ENTITY; -- document_content




ENTITY external_file_unit
SUPERTYPE OF (
              HTTP_FILE);
	file: external_file_address;
	content_encoding: OPTIONAL content_encoding_type;
INVERSE
	unit_of: language_specific_content FOR content_files;
WHERE
	WR1: (('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.HTTP_PROTOCOL'
		IN TYPEOF(SELF.unit_of.content_of.content_of.used_protocol))
		AND ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.HTTP_FILE'
		IN TYPEOF(SELF)))
		XOR NOT
		(('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.HTTP_PROTOCOL'
		IN TYPEOF(SELF.unit_of.content_of.content_of.used_protocol))
		OR ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.HTTP_FILE'

		IN TYPEOF(SELF)));
END_ENTITY; -- external_file_unit




ENTITY http_class_directory;
	name: http_directory_name_type;
	class: class_BSU;
UNIQUE
	UR1: class;
END_ENTITY; -- http_class_directory




ENTITY http_file
SUBTYPE OF(external_file_unit);
	mime: MIME_type;
	exchange_format: MIME_subtype;
	format_RFC: OPTIONAL IAB_RFC;
	http_file_name: http_file_name_type;
	http_directory: OPTIONAL http_class_directory;
	remote_access: OPTIONAL absolute_URL_type;
UNIQUE
	UR1: http_file_name, http_directory;
WHERE
        WR1: NOT EXISTS(http_directory) XOR
	('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.CLASS_EXTENSION_EXTERNAL_ITEM'
		IN TYPEOF(SELF.unit_of.content_of.content_of));

END_ENTITY; -- http_file




ENTITY http_protocol
SUBTYPE OF(standard_data_protocol);
	http_RFC: IAB_RFC;
END_ENTITY; -- http_protocol




ENTITY illustration
SUPERTYPE OF (ONEOF (
              A6_ILLUSTRATION,
              A9_ILLUSTRATION))

SUBTYPE OF(dialogue_resource, graphics);
	kind_of_content: illustration_type;
	width: OPTIONAL length_measure_with_unit;
	height: OPTIONAL length_measure_with_unit;
WHERE
	WR1: (NOT EXISTS(SELF.width) AND NOT EXISTS(SELF.height))
		OR (EXISTS(SELF.width) AND EXISTS(SELF.height));
END_ENTITY; -- illustration




ENTITY language_specific_content;
	content_files: SET [1:?] OF external_file_unit;
	main_file: OPTIONAL external_file_unit;
	character_encoding: OPTIONAL character_set_type;
INVERSE
	content_of: external_content FOR consists_of;
WHERE
	WR1: NOT EXISTS(main_file) OR (main_file IN content_files);
	WR2: EXISTS(main_file) XOR
		('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.PROGRAM_LIBRARY_CONTENT'
		IN TYPEOF(SELF.content_of.content_of));
	WR3: EXISTS(character_encoding) OR NOT
		('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.HTTP_PROTOCOL'

		IN TYPEOF(SELF.content_of.content_of.used_protocol));
END_ENTITY; -- language_specific_content




ENTITY message
SUBTYPE OF(dialogue_resource);
END_ENTITY; -- message




ENTITY non_standard_data_protocol
SUBTYPE OF(data_protocol, non_standard_protocol);
WHERE
	WR1: NOT EXISTS(SELF\external_file_protocol.base_protocol);
END_ENTITY; -- non_standard_data_protocol




ENTITY not_translatable_external_content
SUBTYPE OF(external_content);
WHERE
	WR1: SIZEOF(SELF\external_content.consists_of) = 1;
END_ENTITY; -- not_translatable_external_content




ENTITY not_translated_external_content
SUBTYPE OF(external_content);
WHERE
	WR1: SIZEOF(SELF\external_content.consists_of) = 1;
END_ENTITY; -- not_translated_external_content




ENTITY standard_data_protocol
SUBTYPE OF(data_protocol, standard_protocol);
WHERE
	WR1: NOT EXISTS(SELF\external_file_protocol.base_protocol);
END_ENTITY; -- standard_data_protocol




ENTITY translated_external_content
SUBTYPE OF(external_content);
	languages: present_translations;
WHERE
	WR1: SIZEOF(SELF\external_content.consists_of)
		= SIZEOF(SELF.languages.language_codes);
END_ENTITY; -- translated_external_content



ENTITY amount_of_substance_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent                    = 0.0) AND
          (SELF\named_unit.dimensions.mass_exponent                      = 0.0) AND
          (SELF\named_unit.dimensions.time_exponent                      = 0.0) AND
          (SELF\named_unit.dimensions.electric_current_exponent          = 0.0) AND
          (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND
          (SELF\named_unit.dimensions.amount_of_substance_exponent       = 1.0) AND
          (SELF\named_unit.dimensions.luminous_intensity_exponent        = 0.0);
END_ENTITY;



ENTITY context_dependent_unit
  SUBTYPE OF (named_unit);
  name : label;
END_ENTITY;



ENTITY conversion_based_unit
  SUBTYPE OF (named_unit);
  name              : label;
  conversion_factor : measure_with_unit;
END_ENTITY;



ENTITY derived_unit;
  elements : SET [1:?] OF derived_unit_element;
WHERE
  WR1 : ( SIZEOF ( elements ) > 1 ) OR
          (( SIZEOF ( elements ) = 1 ) AND ( elements[1].exponent <> 1.0 ));
END_ENTITY;



ENTITY derived_unit_element;
  unit     : named_unit;
  exponent : REAL;
END_ENTITY;



ENTITY dimensional_exponents;
  length_exponent                    : REAL; 
  mass_exponent                      : REAL;
  time_exponent                      : REAL;
  electric_current_exponent          : REAL;
  thermodynamic_temperature_exponent : REAL;
  amount_of_substance_exponent       : REAL;
  luminous_intensity_exponent        : REAL;
END_ENTITY;


ENTITY length_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.LENGTH_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);

END_ENTITY;                             



ENTITY length_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 1.0)                    AND
       (SELF\named_unit.dimensions.mass_exponent = 0.0)                      AND
       (SELF\named_unit.dimensions.time_exponent = 0.0)                      AND
       (SELF\named_unit.dimensions.electric_current_exponent = 0.0)          AND
       (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND
       (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0)       AND
       (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;



ENTITY luminous_intensity_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent                    = 0.0) AND
       (SELF\named_unit.dimensions.mass_exponent                      = 0.0) AND
       (SELF\named_unit.dimensions.time_exponent                      = 0.0) AND
       (SELF\named_unit.dimensions.electric_current_exponent          = 0.0) AND
       (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND
       (SELF\named_unit.dimensions.amount_of_substance_exponent       = 0.0) AND
       (SELF\named_unit.dimensions.luminous_intensity_exponent        = 1.0);
END_ENTITY;


ENTITY mass_unit 
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent                    = 0.0) AND
       (SELF\named_unit.dimensions.mass_exponent                      = 1.0) AND
       (SELF\named_unit.dimensions.time_exponent                      = 0.0) AND
       (SELF\named_unit.dimensions.electric_current_exponent          = 0.0) AND
       (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND
       (SELF\named_unit.dimensions.amount_of_substance_exponent       = 0.0) AND
       (SELF\named_unit.dimensions.luminous_intensity_exponent        = 0.0);
END_ENTITY ;



ENTITY measure_with_unit;
  value_component : measure_value;
  unit_component  : unit;
WHERE
  WR1: valid_units (SELF);
END_ENTITY;



ENTITY named_unit
  SUPERTYPE OF (ONEOF (
              SI_UNIT,
              CONVERSION_BASED_UNIT,
              CONTEXT_DEPENDENT_UNIT)
              ANDOR ONEOF (
              LENGTH_UNIT,
              MASS_UNIT,
              TIME_UNIT,
              ELECTRIC_CURRENT_UNIT,
              THERMODYNAMIC_TEMPERATURE_UNIT,
              AMOUNT_OF_SUBSTANCE_UNIT,
              LUMINOUS_INTENSITY_UNIT,
              PLANE_ANGLE_UNIT,
              SOLID_ANGLE_UNIT,
              AREA_UNIT,
              VOLUME_UNIT,
              RATIO_UNIT));
  dimensions : dimensional_exponents;
END_ENTITY;

ENTITY plane_angle_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent                    = 0.0) AND
       (SELF\named_unit.dimensions.mass_exponent                      = 0.0) AND
       (SELF\named_unit.dimensions.time_exponent                      = 0.0) AND
       (SELF\named_unit.dimensions.electric_current_exponent          = 0.0) AND
       (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND
       (SELF\named_unit.dimensions.amount_of_substance_exponent       = 0.0) AND
       (SELF\named_unit.dimensions.luminous_intensity_exponent        = 0.0);
END_ENTITY;


ENTITY ratio_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0.0)                    AND
       (SELF\named_unit.dimensions.mass_exponent = 0.0)                      AND
       (SELF\named_unit.dimensions.time_exponent = 0.0)                      AND
       (SELF\named_unit.dimensions.electric_current_exponent = 0.0)          AND
       (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND
       (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0)       AND
       (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;



ENTITY si_unit
  SUBTYPE OF (named_unit);
  prefix     : OPTIONAL si_prefix;
  name       : si_unit_name;
DERIVE
  SELF\named_unit.dimensions : dimensional_exponents 
                             := dimensions_for_si_unit (SELF.name);
END_ENTITY;


ENTITY solid_angle_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent                    = 0.0) AND
       (SELF\named_unit.dimensions.mass_exponent                      = 0.0) AND
       (SELF\named_unit.dimensions.time_exponent                      = 0.0) AND
       (SELF\named_unit.dimensions.electric_current_exponent          = 0.0) AND
       (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND
       (SELF\named_unit.dimensions.amount_of_substance_exponent       = 0.0) AND
       (SELF\named_unit.dimensions.luminous_intensity_exponent        = 0.0);
END_ENTITY;


ENTITY thermodynamic_temperature_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent                    = 0.0) AND
       (SELF\named_unit.dimensions.mass_exponent                      = 0.0) AND
       (SELF\named_unit.dimensions.time_exponent                      = 0.0) AND
       (SELF\named_unit.dimensions.electric_current_exponent          = 0.0) AND
       (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 1.0) AND
       (SELF\named_unit.dimensions.amount_of_substance_exponent       = 0.0) AND
       (SELF\named_unit.dimensions.luminous_intensity_exponent        = 0.0);
END_ENTITY;



ENTITY time_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent                    = 0.0) AND
       (SELF\named_unit.dimensions.mass_exponent                      = 0.0) AND
       (SELF\named_unit.dimensions.time_exponent                      = 1.0) AND
       (SELF\named_unit.dimensions.electric_current_exponent          = 0.0) AND
       (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND
       (SELF\named_unit.dimensions.amount_of_substance_exponent       = 0.0) AND
       (SELF\named_unit.dimensions.luminous_intensity_exponent        = 0.0);
END_ENTITY;


ENTITY volume_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 3.0)                    AND
       (SELF\named_unit.dimensions.mass_exponent = 0.0)                      AND
       (SELF\named_unit.dimensions.time_exponent = 0.0)                      AND
       (SELF\named_unit.dimensions.electric_current_exponent = 0.0)          AND
       (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND
       (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0)       AND
       (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;


ENTITY area_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 2.0)                    AND
       (SELF\named_unit.dimensions.mass_exponent = 0.0)                      AND
       (SELF\named_unit.dimensions.time_exponent = 0.0)                      AND
       (SELF\named_unit.dimensions.electric_current_exponent = 0.0)          AND
       (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND
       (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0)       AND
       (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;



ENTITY electric_current_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent                    = 0.0) AND
       (SELF\named_unit.dimensions.mass_exponent                      = 0.0) AND
       (SELF\named_unit.dimensions.time_exponent                      = 0.0) AND
       (SELF\named_unit.dimensions.electric_current_exponent          = 1.0) AND
       (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND
       (SELF\named_unit.dimensions.amount_of_substance_exponent       = 0.0) AND
       (SELF\named_unit.dimensions.luminous_intensity_exponent        = 0.0);
END_ENTITY;





ENTITY application_protocol_definition;
  status                                    : label;
  application_interpreted_model_schema_name : label; 
  application_protocol_year                 : year_number;
  application                               : application_context;
END_ENTITY;




ENTITY generic_variable
ABSTRACT SUPERTYPE

SUBTYPE OF (simple_generic_expression);
INVERSE
	interpretation :
			environment FOR syntactic_representation;
END_ENTITY;




ENTITY simple_generic_expression
ABSTRACT SUPERTYPE OF (ONEOF (
                       GENERIC_LITERAL,
                       GENERIC_VARIABLE))

SUBTYPE OF (generic_expression);
END_ENTITY;




ENTITY generic_expression
ABSTRACT SUPERTYPE OF (ONEOF (
                       SIMPLE_GENERIC_EXPRESSION,
                       UNARY_GENERIC_EXPRESSION,
                       BINARY_GENERIC_EXPRESSION,
                       MULTIPLE_ARITY_GENERIC_EXPRESSION));
WHERE 
	WR1: is_acyclic(SELF);
END_ENTITY;




ENTITY unary_generic_expression
ABSTRACT SUPERTYPE

SUBTYPE OF(generic_expression);
	operand: generic_expression;
END_ENTITY;




ENTITY binary_generic_expression
ABSTRACT SUPERTYPE

SUBTYPE OF(generic_expression);
	operands: LIST [2:2] OF generic_expression;
END_ENTITY;




ENTITY multiple_arity_generic_expression
ABSTRACT SUPERTYPE

SUBTYPE OF(generic_expression);
	operands: LIST [2:?] OF generic_expression;
END_ENTITY;




ENTITY variable_semantics
ABSTRACT SUPERTYPE;
END_ENTITY;




ENTITY unary_function_call
ABSTRACT SUPERTYPE OF (ONEOF (
                       ABS_FUNCTION,
                       MINUS_FUNCTION,
                       SIN_FUNCTION,
                       COS_FUNCTION,
                       TAN_FUNCTION,
                       ASIN_FUNCTION,
                       ACOS_FUNCTION,
                       EXP_FUNCTION,
                       LOG_FUNCTION,
                       LOG2_FUNCTION,
                       LOG10_FUNCTION,
                       SQUARE_ROOT_FUNCTION))

SUBTYPE OF (unary_numeric_expression);
END_ENTITY;




ENTITY unary_numeric_expression
ABSTRACT SUPERTYPE OF (ONEOF (
                       UNARY_FUNCTION_CALL))

SUBTYPE OF (numeric_expression, unary_generic_expression);
	SELF\unary_generic_expression.operand	: numeric_expression;
END_ENTITY;




ENTITY numeric_expression
ABSTRACT SUPERTYPE OF (ONEOF (
                       SIMPLE_NUMERIC_EXPRESSION,
                       UNARY_NUMERIC_EXPRESSION,
                       BINARY_NUMERIC_EXPRESSION,
                       MULTIPLE_ARITY_NUMERIC_EXPRESSION,
                       LENGTH_FUNCTION,
                       VALUE_FUNCTION))

SUBTYPE OF (expression);
DERIVE
	is_int: BOOLEAN := is_int_expr (SELF);
	sql_mappable: BOOLEAN := is_SQL_mappable (SELF);
END_ENTITY;




ENTITY expression
ABSTRACT SUPERTYPE OF (ONEOF (
                       NUMERIC_EXPRESSION,
                       BOOLEAN_EXPRESSION,
                       STRING_EXPRESSION))

SUBTYPE OF (generic_expression);
END_ENTITY;




ENTITY multiple_arity_numeric_expression
ABSTRACT SUPERTYPE OF (ONEOF (
                       PLUS_EXPRESSION,
                       MULT_EXPRESSION,
                       MULTIPLE_ARITY_FUNCTION_CALL))

SUBTYPE OF (numeric_expression, multiple_arity_generic_expression);
	SELF\multiple_arity_generic_expression.operands	: LIST [2:?] OF 
						numeric_expression;
END_ENTITY;




ENTITY binary_numeric_expression
ABSTRACT SUPERTYPE OF (ONEOF (
                       MINUS_EXPRESSION,
                       DIV_EXPRESSION,
                       MOD_EXPRESSION,
                       SLASH_EXPRESSION,
                       POWER_EXPRESSION,
                       BINARY_FUNCTION_CALL))

SUBTYPE OF (numeric_expression, binary_generic_expression);
	SELF\binary_generic_expression.operands : LIST [2:2] OF 
						numeric_expression;
END_ENTITY;




ENTITY multiple_arity_boolean_expression
ABSTRACT SUPERTYPE OF (ONEOF (
                       AND_EXPRESSION,
                       OR_EXPRESSION))

SUBTYPE OF (boolean_expression, multiple_arity_generic_expression);
	SELF\multiple_arity_generic_expression.operands	: 
LIST [2:?] OF boolean_expression;
END_ENTITY;




ENTITY boolean_expression
ABSTRACT SUPERTYPE OF (ONEOF (
                       SIMPLE_BOOLEAN_EXPRESSION,
                       UNARY_BOOLEAN_EXPRESSION,
                       BINARY_BOOLEAN_EXPRESSION,
                       MULTIPLE_ARITY_BOOLEAN_EXPRESSION,
                       COMPARISON_EXPRESSION,
                       INTERVAL_EXPRESSION,
                       BOOLEAN_DEFINED_FUNCTION))

SUBTYPE OF (expression);
END_ENTITY;




ENTITY comparison_expression
ABSTRACT SUPERTYPE OF (ONEOF (
                       COMPARISON_EQUAL,
                       COMPARISON_GREATER,
                       COMPARISON_GREATER_EQUAL,
                       COMPARISON_LESS,
                       COMPARISON_LESS_EQUAL,
                       COMPARISON_NOT_EQUAL,
                       LIKE_EXPRESSION))

SUBTYPE OF (boolean_expression, binary_generic_expression);
	SELF\binary_generic_expression.operands	: LIST [2:2] OF 
expression; 
WHERE 
	WR1: (('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.NUMERIC_EXPRESSION'
			IN TYPEOF(SELF\binary_generic_expression.operands[1]))
		AND 
		 	('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.NUMERIC_EXPRESSION'
			IN TYPEOF(SELF\binary_generic_expression.operands[2]))) 
OR
 (('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.BOOLEAN_EXPRESSION'
	IN TYPEOF(SELF\binary_generic_expression.operands[1]))
		AND 
		 	('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.BOOLEAN_EXPRESSION'
	IN TYPEOF(SELF\binary_generic_expression.operands[2])))
OR
(('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.STRING_EXPRESSION'
	IN TYPEOF(SELF\binary_generic_expression.operands[1]))
		AND 
		 	('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.STRING_EXPRESSION'

			IN TYPEOF(SELF\binary_generic_expression.operands[2]))) ;
END_ENTITY;




ENTITY binary_function_call
ABSTRACT SUPERTYPE OF (ONEOF (
                       ATAN_FUNCTION))

SUBTYPE OF (binary_numeric_expression);
END_ENTITY;




ENTITY simple_boolean_expression
ABSTRACT SUPERTYPE OF (ONEOF (
                       BOOLEAN_LITERAL,
                       BOOLEAN_VARIABLE))

SUBTYPE OF (boolean_expression, simple_generic_expression);
END_ENTITY;




ENTITY generic_literal
ABSTRACT SUPERTYPE

SUBTYPE OF (simple_generic_expression);
END_ENTITY; 




ENTITY variable
ABSTRACT SUPERTYPE OF (ONEOF (
                       NUMERIC_VARIABLE,
                       BOOLEAN_VARIABLE,
                       STRING_VARIABLE))

SUBTYPE OF(generic_variable);
END_ENTITY;




ENTITY string_expression
ABSTRACT SUPERTYPE OF (ONEOF (
                       SIMPLE_STRING_EXPRESSION,
                       INDEX_EXPRESSION,
                       SUBSTRING_EXPRESSION,
                       CONCAT_EXPRESSION,
                       FORMAT_FUNCTION))

SUBTYPE OF (expression);
END_ENTITY;




ENTITY binary_boolean_expression
ABSTRACT SUPERTYPE OF (ONEOF (
                       XOR_EXPRESSION,
                       EQUALS_EXPRESSION))

SUBTYPE OF (boolean_expression, binary_generic_expression);
END_ENTITY;




ENTITY literal_number 
ABSTRACT SUPERTYPE OF (ONEOF (
                       INT_LITERAL,
                       REAL_LITERAL))

SUBTYPE OF (simple_numeric_expression, generic_literal);
	the_value: NUMBER;
END_ENTITY;




ENTITY simple_numeric_expression
ABSTRACT SUPERTYPE OF (ONEOF (
                       LITERAL_NUMBER,
                       NUMERIC_VARIABLE))

SUBTYPE OF (numeric_expression, simple_generic_expression);
END_ENTITY;




ENTITY numeric_variable
SUPERTYPE OF (ONEOF (
              INT_NUMERIC_VARIABLE,
              REAL_NUMERIC_VARIABLE))

SUBTYPE OF (simple_numeric_expression, variable);
WHERE 
	WR1:	('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.INT_NUMERIC_VARIABLE'
			IN TYPEOF(SELF) ) OR
			('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.REAL_NUMERIC_VARIABLE'

			IN TYPEOF(SELF) );
END_ENTITY;




ENTITY multiple_arity_function_call
ABSTRACT SUPERTYPE OF (ONEOF (
                       MAXIMUM_FUNCTION,
                       MINIMUM_FUNCTION))

SUBTYPE OF (multiple_arity_numeric_expression);
END_ENTITY;




ENTITY unary_boolean_expression
ABSTRACT SUPERTYPE OF (ONEOF (
                       NOT_EXPRESSION,
                       ODD_FUNCTION))

SUBTYPE OF (boolean_expression, unary_generic_expression);
END_ENTITY;




ENTITY simple_string_expression
ABSTRACT SUPERTYPE OF (ONEOF (
                       STRING_LITERAL,
                       STRING_VARIABLE))

SUBTYPE OF (string_expression, simple_generic_expression);
END_ENTITY;




ENTITY dictionary_element
ABSTRACT SUPERTYPE OF (ONEOF (
                       SUPPLIER_ELEMENT,
                       CLASS_AND_PROPERTY_ELEMENTS,
                       DATA_TYPE_ELEMENT));

	identified_by: basic_semantic_unit;
	time_stamps: OPTIONAL dates;
	revision: revision_type;
END_ENTITY; -- dictionary_element




ENTITY content_item
ABSTRACT SUPERTYPE;
	dictionary_definition: basic_semantic_unit;
END_ENTITY; -- content_item




ENTITY simple_type
ABSTRACT SUPERTYPE OF (ONEOF (
                       NUMBER_TYPE,
                       BOOLEAN_TYPE,
                       STRING_TYPE))

SUBTYPE OF(data_type);
	value_format: value_format_type;
END_ENTITY; -- simple_type




ENTITY data_type
ABSTRACT SUPERTYPE OF (ONEOF (
                       SIMPLE_TYPE,
                       COMPLEX_TYPE,
                       NAMED_TYPE));
END_ENTITY; -- data_type




ENTITY class
ABSTRACT SUPERTYPE OF (
                       ITEM_CLASS)

SUBTYPE OF(class_and_property_elements);
	SELF\dictionary_element.identified_by: class_BSU;
	its_superclass: OPTIONAL class_BSU;
	described_by: LIST [0:?] OF UNIQUE property_BSU;
	defined_types: SET [0:?] OF data_type_BSU;
DERIVE
	subclasses: SET [0:?] OF class := identified_by.subclasses;
	known_applicable_properties: SET [0:?] OF property_BSU
		:= compute_known_applicable_properties(
			SELF\dictionary_element.identified_by);
	known_applicable_data_types: SET [0:?] OF data_type_BSU
		:= compute_known_applicable_data_types(
			SELF\dictionary_element.identified_by);
INVERSE
	associated_items: SET [0:?] OF class_BSU_relationship 
		FOR relating_class;
WHERE
	WR1: acyclic_superclass_relationship(SELF.identified_by, []);
	WR2: NOT all_class_descriptions_reachable(
		SELF\dictionary_element.identified_by)
		OR (list_to_set(SELF.described_by) <= 
		SELF\dictionary_element.identified_by
		\class_BSU.known_visible_properties);
	WR3: NOT all_class_descriptions_reachable(
		SELF\dictionary_element.identified_by)
		OR (SELF.defined_types <= 
		SELF\dictionary_element.identified_by
		\class_BSU.known_visible_data_types); 
	WR4: check_properties_applicability(SELF);
	WR5: check_datatypes_applicability(SELF);
END_ENTITY; -- class




ENTITY class_and_property_elements
ABSTRACT SUPERTYPE OF (ONEOF (
                       PROPERTY_DET,
                       CLASS))

SUBTYPE OF(dictionary_element);
	names: item_names;
	definition: definition_type;
	source_doc_of_definition: OPTIONAL document;
	note: OPTIONAL note_type;
	remark: OPTIONAL remark_type;
END_ENTITY; -- class_and_property_elements




ENTITY document
ABSTRACT SUPERTYPE;
END_ENTITY; -- document




ENTITY class_BSU_relationship
ABSTRACT SUPERTYPE;
	relating_class: class;
	related_tokens: SET [1:?] OF class_related_BSU;
END_ENTITY; -- class_BSU_relationship




ENTITY class_related_BSU
ABSTRACT SUPERTYPE

SUBTYPE OF(basic_semantic_unit);
END_ENTITY; -- class_related_BSU




ENTITY complex_type
ABSTRACT SUPERTYPE OF (ONEOF (
                       LEVEL_TYPE,
                       CLASS_INSTANCE_TYPE,
                       ENTITY_INSTANCE_TYPE))

SUBTYPE OF(data_type);
END_ENTITY; -- complex_type




ENTITY property_DET
ABSTRACT SUPERTYPE OF (ONEOF (
                       CONDITION_DET,
                       DEPENDENT_P_DET,
                       NON_DEPENDENT_P_DET))

SUBTYPE OF(class_and_property_elements);
	SELF\dictionary_element.identified_by: property_BSU;
	preferred_symbol: OPTIONAL mathematical_string;
	synonymous_symbols: SET [0:?] OF mathematical_string;
	figure: OPTIONAL graphics;
	det_classification: OPTIONAL DET_classification_type;
	domain: data_type;
	formula: OPTIONAL mathematical_string;
DERIVE
	describes_classes: SET [0:?] OF class
		:= identified_by.describes_classes;
END_ENTITY; -- property_DET




ENTITY graphics
ABSTRACT SUPERTYPE;
END_ENTITY; -- graphics




ENTITY supplier_BSU_relationship
ABSTRACT SUPERTYPE;
	relating_supplier: supplier_element;
	related_tokens: SET [1:?] OF supplier_related_BSU;
END_ENTITY; -- supplier_BSU_relationship




ENTITY supplier_related_BSU
ABSTRACT SUPERTYPE

SUBTYPE OF(basic_semantic_unit);
END_ENTITY; -- supplier_related_BSU




ENTITY dic_item_instance
SUPERTYPE OF (ONEOF (
              DIC_COMPONENT_INSTANCE,
              DIC_MATERIAL_INSTANCE,
              DIC_FEATURE_INSTANCE)
              ANDOR 
              LIB_ITEM_INSTANCE)

SUBTYPE OF(dic_class_instance);
WHERE
	WR1: check_class_type_for_dic_item_instance(SELF);
	WR2: QUERY(prop <* SELF.properties
		| (SIZEOF(prop.prop_def.definition) = 1)
		AND (('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA' +
		'.DEPENDENT_P_DET')
		IN TYPEOF(prop.prop_def.definition[1]))
		AND (prop.prop_def.definition[1]\dependent_P_DET.depends_on
		>= collects_property_context(prop.prop_def, SELF)))
		= [];
END_ENTITY; -- dic_item_instance




ENTITY dic_class_instance
ABSTRACT SUPERTYPE OF (ONEOF (
                       DIC_ITEM_INSTANCE));
	class_def: class_BSU;
	properties: LIST [0:?] OF property_value;
	case_of: SET [0:?] OF class_BSU;
WHERE
	WR1: (QUERY(prop <* SELF.properties |
		NOT((applicable_properties(
		SELF.class_def, [prop.prop_def])))) = [ ]);
	WR2: QUERY(prop <* SELF.properties
		| (SIZEOF(QUERY (prop1 <* SELF.properties
		| prop1.prop_def = prop.prop_def)) = 1))
		= SELF.properties;
	WR3: check_property_values_translations(QUERY(prop_val <*
		properties | 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.' +
		'TRANSLATED_STRING_VALUE' IN TYPEOF(prop_val.its_value)));
END_ENTITY; -- dic_class_instance




ENTITY a_priori_semantic_relationship
ABSTRACT SUPERTYPE OF (ONEOF (
                       ITEM_CLASS_CASE_OF))

SUBTYPE OF(class);
	referenced_classes: SET [1:?] OF class_BSU;
	referenced_properties: LIST [0:?] OF property_BSU;
	referenced_data_types: SET [0:?] OF data_type_BSU;
	referenced_tables: SET[0:?] OF table_BSU;
	referenced_documents: SET[0:?] OF document_BSU;
END_ENTITY; -- a_priori_semantic_relationship




ENTITY lib_item_instance
SUPERTYPE OF (ONEOF (
                       LIB_COMPONENT_INSTANCE,
                       LIB_MATERIAL_INSTANCE,
                       LIB_FEATURE_INSTANCE))

SUBTYPE OF(dic_item_instance);
	supplier_identification: OPTIONAL STRING;
	supplier_designation: OPTIONAL translatable_label;
	user_identification: OPTIONAL STRING;
	user_designation: OPTIONAL translatable_label;
	is_global_id: BOOLEAN;
	source_class_content: OPTIONAL version_type;
END_ENTITY; -- lib_item_instance




ENTITY class_instance_constructor
ABSTRACT SUPERTYPE OF (ONEOF (
                       UNARY_CLASS_INSTANCE_CONSTRUCTOR,
                       BINARY_CLASS_INSTANCE_CONSTRUCTOR,
                       MULTIPLE_ARITY_CLASS_INSTANCE_CONSTRUCTOR))

SUBTYPE OF(class_instance_expression);
	properties: SET [1:?] OF property_assignment;
WHERE
	WR1: definition_available_implies
		(SELF\class_instance_expression.expr_type,
		applicable_properties(
		SELF\class_instance_expression.expr_type,
		list_to_set(collects_assigned_properties(SELF.properties))));
END_ENTITY; -- class_instance_constructor




ENTITY class_instance_expression
ABSTRACT SUPERTYPE OF (ONEOF (
                       SIMPLE_CLASS_INSTANCE_EXPRESSION,
                       UNARY_CLASS_INSTANCE_EXPRESSION,
                       BINARY_CLASS_INSTANCE_EXPRESSION,
                       MULTIPLE_ARITY_CLASS_INSTANCE_EXPRESSION))

SUBTYPE OF(generic_expression);
	expr_type: class_BSU;
END_ENTITY; -- class_instance_expression




ENTITY binary_class_instance_expression
ABSTRACT SUPERTYPE OF (
                       BINARY_CLASS_INSTANCE_CONSTRUCTOR)

SUBTYPE OF(class_instance_expression, binary_generic_expression);
END_ENTITY; -- binary_class_instance_expression




ENTITY simple_class_instance_expression
ABSTRACT SUPERTYPE OF (ONEOF (
                       CLASS_INSTANCE_VARIABLE,
                       CLASS_INSTANCE_LITERAL))

SUBTYPE OF(class_instance_expression, simple_generic_expression);
END_ENTITY; -- simple_class_instance_expression




ENTITY simple_entity_instance_expression
ABSTRACT SUPERTYPE OF (ONEOF (
                       ENTITY_INSTANCE_VARIABLE,
                       ENTITY_INSTANCE_LITERAL))

SUBTYPE OF(entity_instance_expression, simple_generic_expression);
END_ENTITY; -- simple_entity_instance_expression




ENTITY entity_instance_expression
ABSTRACT SUPERTYPE OF (
                       SIMPLE_ENTITY_INSTANCE_EXPRESSION)

SUBTYPE OF(generic_expression);
	type_name: SET [1:?] OF STRING;
END_ENTITY; -- entity_instance_expression




ENTITY boolean_defined_function
ABSTRACT SUPERTYPE

SUBTYPE OF (defined_function, boolean_expression);
END_ENTITY ;




ENTITY defined_function
ABSTRACT SUPERTYPE OF ((ONEOF (
                       BOOLEAN_DEFINED_FUNCTION))
                       ANDOR 
                       SQL_MAPPABLE_DEFINED_FUNCTION);
END_ENTITY;




ENTITY level_spec_literal
ABSTRACT SUPERTYPE OF (ONEOF (
                       INT_LEVEL_SPEC_LITERAL,
                       REAL_LEVEL_SPEC_LITERAL))

SUBTYPE OF(simple_level_spec_expression, generic_literal);
	the_value: level_spec_value;
WHERE
	WR1: compatible_level_type_and_instance(
		SELF\level_spec_expression.levels,
		TYPEOF(SELF\level_spec_expression.value_type),
		SELF.the_value);
END_ENTITY; -- level_spec_literal




ENTITY simple_level_spec_expression
ABSTRACT SUPERTYPE OF (ONEOF (
                       LEVEL_SPEC_VARIABLE,
                       LEVEL_SPEC_LITERAL))

SUBTYPE OF(level_spec_expression, simple_generic_expression);
END_ENTITY; -- simple_level_spec_expression




ENTITY level_spec_expression
ABSTRACT SUPERTYPE OF (
                       SIMPLE_LEVEL_SPEC_EXPRESSION)

SUBTYPE OF(generic_expression);
	levels: LIST[1:4] OF UNIQUE level;
	value_type: number_type;
END_ENTITY; -- level_spec_expression




ENTITY level_spec_variable
ABSTRACT SUPERTYPE OF (ONEOF (
                       INT_LEVEL_SPEC_VARIABLE,
                       REAL_LEVEL_SPEC_VARIABLE))

SUBTYPE OF(simple_level_spec_expression, generic_variable);
END_ENTITY; -- level_spec_variable




ENTITY multiple_arity_class_instance_expression
ABSTRACT SUPERTYPE OF (
                       MULTIPLE_ARITY_CLASS_INSTANCE_CONSTRUCTOR)

SUBTYPE OF(class_instance_expression,
	multiple_arity_generic_expression);
END_ENTITY; -- multiple_arity_class_instance_expression




ENTITY unary_class_instance_expression
ABSTRACT SUPERTYPE OF (
                       UNARY_CLASS_INSTANCE_CONSTRUCTOR)

SUBTYPE OF(class_instance_expression, unary_generic_expression);
END_ENTITY; -- unary_class_instance_expression




ENTITY simple_column
ABSTRACT SUPERTYPE OF (ONEOF (
                       BOOLEAN_COLUMN,
                       FORMATTED_COLUMN))

SUBTYPE OF(column);
	SELF\column.values: LIST [1:?] OF null_or_simple_value;
END_ENTITY; -- simple_column




ENTITY column
ABSTRACT SUPERTYPE OF (ONEOF (
                       SIMPLE_COLUMN,
                       COMPLEX_COLUMN));
	values: LIST [1:?] OF null_or_primitive_value;
INVERSE
	belongs_to: table_extension FOR content;
END_ENTITY; -- column




ENTITY complex_column
ABSTRACT SUPERTYPE OF (ONEOF (
                       LEVEL_SPEC_COLUMN,
                       ENTITY_INSTANCE_COLUMN,
                       CLASS_INSTANCE_COLUMN))

SUBTYPE OF(column);
	SELF\column.values: LIST [1:?] OF null_or_complex_value;
END_ENTITY; -- complex_column




ENTITY table_expression
ABSTRACT SUPERTYPE OF (ONEOF (
                       SIMPLE_TABLE_EXPRESSION,
                       UNARY_TABLE_EXPRESSION,
                       BINARY_TABLE_EXPRESSION,
                       MULTIPLE_ARITY_TABLE_EXPRESSION,
                       SELECT_EXPRESSION))

SUBTYPE OF(generic_expression);
DERIVE
	its_columns: LIST[1:?] OF variable_semantics
		:= collects_columns(SELF);
	the_key: SET[1:?] OF variable_semantics := return_key(SELF);
	is_SQL_mappable: LOGICAL
		:= is_SQL_mappable_table_expression(SELF);
WHERE
	WR1: QUERY(sem <* its_columns
		| SIZEOF(QUERY(sem_2 <* its_columns
		| sem_2 :=: sem)) <> 1) = [];
END_ENTITY; -- table_expression




ENTITY binary_table_expression
ABSTRACT SUPERTYPE OF (ONEOF (
                       SET_TABLE_EXPRESSION,
                       NATURAL_JOIN_EXPRESSION))

SUBTYPE OF(table_expression, binary_generic_expression);
	SELF\binary_generic_expression.operands:
		LIST [2:2] OF table_expression;
END_ENTITY; -- binary_table_expression




ENTITY multiple_arity_table_expression
ABSTRACT SUPERTYPE OF (
                       MULTIPLE_ARITY_CARTESIAN_PRODUCT)

SUBTYPE OF(table_expression, multiple_arity_generic_expression);
	SELF\multiple_arity_generic_expression.operands:
		LIST [2:?] OF table_expression;
END_ENTITY; -- multiple_arity_table_expression




ENTITY unary_table_expression
ABSTRACT SUPERTYPE OF (
                       PROJECTION_EXPRESSION)

SUBTYPE OF(table_expression, unary_generic_expression);
	SELF\unary_generic_expression.operand: table_expression;
END_ENTITY; -- unary_table_expression




ENTITY set_table_expression
ABSTRACT SUPERTYPE OF (ONEOF (
                       UNION_TABLE_EXPRESSION,
                       INTERSECT_TABLE_EXPRESSION,
                       DIFFERENCE_TABLE_EXPRESSION))

SUBTYPE OF(binary_table_expression);
WHERE
	WR1: SELF\binary_generic_expression.operands[1]
		\table_expression.its_columns =
		SELF\binary_generic_expression.operands[2]
		\table_expression.its_columns;
END_ENTITY; -- set_table_expression




ENTITY number_column
ABSTRACT SUPERTYPE OF (ONEOF (
                       REAL_COLUMN,
                       INTEGER_COLUMN))

SUBTYPE OF(formatted_column);
	SELF\column.values: LIST [1:?] OF null_or_number_value;
END_ENTITY; -- number_column




ENTITY formatted_column
ABSTRACT SUPERTYPE OF (ONEOF (
                       NUMBER_COLUMN,
                       STRING_COLUMN))

SUBTYPE OF(simple_column);
	value_format: OPTIONAL value_format_type;
END_ENTITY; -- formatted_column




ENTITY level_spec_column
ABSTRACT SUPERTYPE OF (ONEOF (
                       INT_LEVEL_SPEC_COLUMN,
                       REAL_LEVEL_SPEC_COLUMN))

SUBTYPE OF(complex_column);
	levels: LIST [1:4] OF UNIQUE level;
	SELF\column.values: LIST [1:?] OF null_or_level_spec_value;
WHERE
	WR1: QUERY(inst <* SELF\column.values
		| NOT right_values_for_level_spec(SELF.levels, inst)) = [];
END_ENTITY; -- level_spec_column




ENTITY SQL_mappable_defined_function
ABSTRACT SUPERTYPE

SUBTYPE OF (defined_function);
END_ENTITY;




ENTITY table_identification
ABSTRACT SUPERTYPE;
WHERE
	WR1: SIZEOF(USEDIN(SELF,
		'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.TABLE_SPECIFICATION'
		+ '.TABLE_IDENTIFIER'))
		<= 1;
	WR2: SIZEOF(USEDIN(SELF,
		'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.TABLE_EXTENSION'

		+ '.TABLE_IDENTIFIER')) <= 1;
END_ENTITY; -- table_identification




ENTITY simple_table_expression
ABSTRACT SUPERTYPE OF (ONEOF (
                       TABLE_VARIABLE,
                       TABLE_LITERAL))

SUBTYPE OF(table_expression, simple_generic_expression);
END_ENTITY; -- simple_table_expression




ENTITY self_class_name_semantics
ABSTRACT SUPERTYPE OF (ONEOF (
                       SELF_CLASS_PREFERRED_NAME_SEMANTICS,
                       SELF_CLASS_SHORT_NAME_SEMANTICS,
                       SELF_CLASS_CODE_SEMANTICS,
                       SELF_CLASS_SUPPLIER_CODE_SEMANTICS,
                       SELF_CLASS_VERSION_SEMANTICS))

SUBTYPE OF(self_class_variable_semantics);
WHERE
	WR1: SIZEOF(QUERY(v <* syntax_of(SELF) | NOT
		('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.STRING_VARIABLE'

		IN TYPEOF(v)))) = 0;
END_ENTITY; -- self_class_name_semantics




ENTITY self_class_variable_semantics
ABSTRACT SUPERTYPE OF (
                       SELF_CLASS_NAME_SEMANTICS)

SUBTYPE OF(self_variable_semantics);
END_ENTITY; -- self_class_variable_semantics




ENTITY self_variable_semantics
ABSTRACT SUPERTYPE OF (ONEOF (
                       SELF_PROPERTY_SEMANTICS,
                       SELF_CLASS_VARIABLE_SEMANTICS))

SUBTYPE OF(variable_semantics);
END_ENTITY; -- self_variable_semantics




ENTITY self_property_name_semantics
ABSTRACT SUPERTYPE OF (ONEOF (
                       SELF_PROPERTY_PREFERRED_NAME_SEMANTICS,
                       SELF_PROPERTY_SHORT_NAME_SEMANTICS,
                       SELF_PROPERTY_CODE_SEMANTICS,
                       SELF_PROPERTY_VERSION_SEMANTICS,
                       SELF_PROPERTY_CLASS_CODE_SEMANTICS,
                       SELF_PROPERTY_CLASS_VERSION_SEMANTICS))

SUBTYPE OF(self_property_semantics);
WHERE
	WR1: QUERY(v <* syntax_of(SELF)
		| NOT('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.STRING_VARIABLE'

		IN TYPEOF(v))) = [];
END_ENTITY; -- self_property_name_semantics




ENTITY self_property_semantics
ABSTRACT SUPERTYPE OF (ONEOF (
                       SELF_PROPERTY_VALUE_SEMANTICS,
                       SELF_PROPERTY_NAME_SEMANTICS))

SUBTYPE OF(self_variable_semantics, property_semantics);
END_ENTITY; -- self_property_semantics




ENTITY property_semantics
ABSTRACT SUPERTYPE OF (ONEOF (
                       SELF_PROPERTY_SEMANTICS))

SUBTYPE OF(variable_semantics);
	the_property: property_BSU;
	its_own_property: OPTIONAL sub_property_path;
WHERE
	WR1: check_property_semantics(SELF);
END_ENTITY; -- property_semantics




ENTITY simple_domain
ABSTRACT SUPERTYPE OF (ONEOF (
                       TABLE_DEFINED_DOMAIN,
                       TYPE_DEFINED_DOMAIN,
                       SUBCLASS_DEFINED_DOMAIN,
                       CONSTANT_RANGE_DEFINED_DOMAIN,
                       VARIABLE_RANGE_DEFINED_DOMAIN,
                       PREDICATE_DEFINED_DOMAIN,
                       SIMPLE_FUNCTIONAL_DOMAIN));
INVERSE
	referenced_by: guarded_simple_domain FOR domain;
END_ENTITY; -- simple_domain




ENTITY simple_functional_domain
ABSTRACT SUPERTYPE OF (ONEOF (
                       LIBRARY_EXPRESSION_DEFINED_VALUE,
                       TABLE_DEFINED_VALUE,
                       NULL_DEFINED_VALUE))

SUBTYPE OF(simple_domain );
END_ENTITY; -- simple_functional_domain




ENTITY a_posteriori_semantic_relationship
ABSTRACT SUPERTYPE OF (ONEOF (
                       A_POSTERIORI_CASE_OF));
END_ENTITY; -- a_posteriori_semantic_relationship




ENTITY external_file_protocol
ABSTRACT SUPERTYPE OF ((ONEOF (
                       STANDARD_PROTOCOL,
                       NON_STANDARD_PROTOCOL))
                       ANDOR (ONEOF (
                       PROGRAM_PROTOCOL,
                       DATA_PROTOCOL)));
	organisation: organization;
	country: OPTIONAL identifier;
	protocol_name: identifier;
	protocol_version: identifier;
	level: OPTIONAL identifier;
	designation: item_names;
	base_protocol: OPTIONAL program_protocol;
WHERE
	WR1: (NOT(SELF.protocol_name LIKE '* *'))
		AND (NOT(SELF.protocol_name LIKE '*.*'))
		AND (NOT(SELF.protocol_name LIKE '*-*'));
	WR2: NOT(SELF.protocol_version LIKE '* *');
END_ENTITY; -- external_file_protocol




ENTITY program_protocol
ABSTRACT SUPERTYPE

SUBTYPE OF(external_file_protocol);
END_ENTITY; -- program_protocol




ENTITY view_exchange_protocol_identification
SUBTYPE OF(data_exchange_specification_identification);
	referenced_ISO10303_AP: OPTIONAL application_protocol_definition;
END_ENTITY; -- view_exchange_protocol_identification




ENTITY data_exchange_specification_identification
ABSTRACT SUPERTYPE OF (ONEOF (
                       LIBRARY_IIM_IDENTIFICATION,
                       VIEW_EXCHANGE_PROTOCOL_IDENTIFICATION));
	source_document_identifier: OPTIONAL identifier;
	status: label;
	name: identifier;
	date: year_number;
	application: OPTIONAL identifier;
	level: OPTIONAL identifier;
	external_file_protocols: SET [0:?] OF external_file_protocol;
END_ENTITY; -- data_exchange_specification_identification




ENTITY class_related_dictionary_element
ABSTRACT SUPERTYPE OF (ONEOF (
                       TABLE_ELEMENT,
                       DOCUMENT_ELEMENT))

SUBTYPE OF(dictionary_element);
	SELF\dictionary_element.identified_by: class_related_BSU;
	names: item_names;
	definition: definition_type;
	note: OPTIONAL note_type;
	remark: OPTIONAL remark_type;
END_ENTITY; -- class_related_dictionary_element




ENTITY implicit_model_class_extension
ABSTRACT SUPERTYPE OF (ONEOF (
                       ITEM_CLASS_EXTENSION))

SUBTYPE OF(model_class_extension);
	selectable_properties: LIST [0:?] OF UNIQUE
		opt_or_mand_property_BSU;
	required_properties: LIST [0:?] OF UNIQUE
		opt_or_mand_property_BSU;
	derived_properties: LIST [0:?] OF UNIQUE
		opt_or_mand_property_BSU;
	class_extension: SET [0:?] OF domain_restriction;
	derivation: SET [0:?] OF functional_domain_restriction;
	filters: SET [0:?] OF domain_restriction;
WHERE
	WR1: QUERY(opt_or_mand <* SELF.selectable_properties
		| NOT applicable_properties
		(SELF\content_item.dictionary_definition,
		[opt_or_mand.property])) = [];
	WR2: QUERY(opt_or_mand <* SELF.derived_properties
		| NOT applicable_properties
		(SELF\content_item.dictionary_definition,
		[opt_or_mand.property])) = [];
	WR3: (QUERY(dom <*
		(SELF.class_extension + SELF.derivation + SELF.filters)
		| (QUERY(sem <* dom.assumes
		| NOT('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA'
		+ '.SELF_PROPERTY_SEMANTICS' IN TYPEOF(sem))) <> [])) = [])
		AND
		(QUERY(dom <* SELF.filters
		| (QUERY(sem <* dom.defines
		| NOT('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA'
		+ '.SELF_PROPERTY_SEMANTICS' IN TYPEOF(sem))) <> [])) = []);
	WR4: QUERY(dom <* (SELF.class_extension + SELF.derivation)
		| QUERY(sem <* dom.defines
		| NOT('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA'
		+'.SELF_PROPERTY_VALUE_SEMANTICS' IN TYPEOF(sem))
		OR EXISTS(sem.its_own_property))
		<> []) = [];
	WR5: NOT all_class_descriptions_reachable(
		SELF.dictionary_definition) OR (QUERY(dom <*
		(SELF.class_extension + SELF.derivation + SELF.filters)
		| (QUERY(sem <* dom.assumes
		| NOT(sem\property_semantics.the_property IN
		provided_properties_list(SELF.dictionary_definition)))
		<> [])) = []);
	WR6: NOT all_class_descriptions_reachable(
		SELF.dictionary_definition) OR (QUERY(dom <*
		(SELF.class_extension + SELF.filters)
		| (QUERY(sem <* dom.defines
		| NOT(sem\property_semantics.the_property IN
		selectable_properties_list(SELF.dictionary_definition)))
		<> [])) = []);
	WR7: NOT all_class_descriptions_reachable(
		SELF.dictionary_definition) OR (QUERY(dom <*
		(SELF.class_extension + SELF.derivation + SELF.filters)
		| (QUERY(tab <* dom.base_tables | NOT applicable_tables(
		SELF.dictionary_definition, [tab])) <> [])) = []);
	WR8: acyclic_class_extension_definition(
		SELF.dictionary_definition);
	WR9: QUERY(prop <* SELF.selectable_properties
		| SIZEOF(QUERY(choi <* SELF.class_extension
		| (prop.property IN get_property_BSU_from_property_semantics(
		choi\domain_restriction.defines)))) <> 1) = [];
	WR10: QUERY(prop <* SELF.derived_properties
		| SIZEOF(QUERY(f <* SELF.derivation
		| (prop.property IN get_property_BSU_from_property_semantics(
		f.defines)))) <> 1) = [];
	WR11: NOT all_class_descriptions_reachable(
		SELF.dictionary_definition) OR (QUERY(f <* SELF.derivation
		| (QUERY(prop <* f.defines
		| NOT(get_property_BSU_from_property_semantics([prop])[1]
		IN derived_properties_list(SELF.dictionary_definition)))
		<> [])) = []);
	WR12: NOT all_class_descriptions_reachable(
		SELF.dictionary_definition)
		OR (QUERY(prop <* derived_properties_list(
		SELF.dictionary_definition)
		| SIZEOF(QUERY(f <* defined_derivation_function(
		SELF.dictionary_definition) | QUERY(sem <* f.defines
		| sem\property_semantics.the_property = prop) <> []))
		<> 1 ) = []);
	WR13: QUERY(filt <* filters | NOT(EXISTS(
		filt.constraint_description))) = [];
	WR14: QUERY(dom_1 <* class_extension | NOT(QUERY(dom_2 <*
		dom_1.domains | 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA' +
		'.PREDICATE_DEFINED_DOMAIN' IN TYPEOF(dom_2.domain)) = [])
		) = [];
   	WR15: QUERY(prop <* SELF.required_properties |
		prop.is_optional) = [];
END_ENTITY; -- implicit_model_class_extension

ENTITY explicit_model_class_extension
ABSTRACT SUPERTYPE OF(ONEOF(explicit_item_class_extension))
SUBTYPE OF(model_class_extension);
	instance_identification: LIST[1:?] OF UNIQUE property_BSU;
	POPULATION: LIST[1:?] OF UNIQUE dic_class_instance;
	table_like: BOOLEAN;
WHERE
	WR1: NOT table_like OR (QUERY(inst <* SELF.POPULATION |
		NOT same_order_for_properties(POPULATION[1].properties,
		inst.properties)) = []);
	WR2: applicable_properties(
		SELF\content_item.dictionary_definition,
		list_to_set(SELF.instance_identification));
	WR3: all_properties_are_applicable(SELF);
	WR4: same_string_values_translations_for_class_extension(SELF);
	WR5: QUERY (inst <* SELF.POPULATION |
		inst.class_def :<>: SELF\content_item.dictionary_definition)
		= [];
	WR6: QUERY(inst <* SELF.POPULATION | NOT(
		QUERY(prop <* inst.properties | NOT(EXISTS(prop.its_value))
		AND (prop.prop_def IN SELF.instance_identification)) = []))
		= [];
END_ENTITY; -- explicit_model_class_extension

ENTITY explicit_item_class_extension
SUBTYPE OF(explicit_model_class_extension);
	access_icon: OPTIONAL A9_illustration;
	content_msg: OPTIONAL message;
	create_icon: LIST [0:?] OF A6_illustration;
	create_msg: OPTIONAL message;
	class_presentation_on_paper: LIST [0:?] OF illustration;
	class_presentation_on_screen: LIST [0:?] OF illustration;
WHERE
	WR1: QUERY(inst <* SELF\explicit_model_class_extension.POPULATION
		| NOT('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA' +
		'.DIC_ITEM_INSTANCE' IN TYPEOF(inst))) = [];
	WR2: definition_available_implies(
		SELF\content_item.dictionary_definition,
		'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.ITEM_CLASS' IN TYPEOF(
		(SELF\content_item.dictionary_definition.definition[1])));
	WR3: NOT(EXISTS(SELF.access_icon)) OR (SELF.access_icon IN
		SELF\model_class_extension.referenced_external_items);
	WR4: NOT(EXISTS(SELF.content_msg)) OR (SELF.content_msg IN
		SELF\model_class_extension.referenced_external_items);
	WR5: list_to_set(SELF.create_icon)
		<= SELF\model_class_extension.referenced_external_items;
	WR6: NOT(EXISTS(SELF.create_msg)) OR (SELF.create_msg IN
		SELF\model_class_extension.referenced_external_items);
	WR7: list_to_set(SELF.class_presentation_on_paper)
		<= SELF\model_class_extension.referenced_external_items;
	WR8: list_to_set(SELF.class_presentation_on_screen)
		<= SELF\model_class_extension.referenced_external_items;
	WR9: QUERY(icon <* SELF.class_presentation_on_paper |
		(NOT EXISTS(icon.width)) OR (icon.kind_of_content
		= illustration_type.not_static_picture)) = [];
	WR10: QUERY(icon <* SELF.class_presentation_on_screen |
		(NOT EXISTS(icon.width))) = [];
END_ENTITY; -- explicit_item_class_extension


ENTITY model_class_extension
ABSTRACT SUPERTYPE OF (ONEOF (
                       IMPLICIT_MODEL_CLASS_EXTENSION,
					   EXPLICIT_MODEL_CLASS_EXTENSION))

SUBTYPE OF(class_extension);
	referenced_external_items: SET [0:?] OF
		class_extension_external_item;
	used_protocols: SET [0:?] OF external_file_protocol;
	referenced_view_exchange_protocol: LIST [0:?] OF
		view_exchange_protocol_identification;
	content_version: OPTIONAL version_type;
	content_revision: OPTIONAL revision_type;
	recommended_presentation: SET [0:?] OF
		property_value_recommended_presentation;
	classification: SET [0:?] OF property_classification;
WHERE
	WR1: QUERY(item <* SELF.referenced_external_items
		| NOT(item\external_item.used_protocol
		IN SELF.used_protocols)) = [];
	WR2: QUERY (prop <* classification | NOT
		applicable_properties(SELF\content_item.
		dictionary_definition, [prop.prop_def])) = [];
	WR3: (EXISTS (SELF.content_version)
		AND EXISTS (SELF.content_revision))
		OR (NOT EXISTS (SELF.content_version)
		AND NOT EXISTS (SELF.content_revision));
END_ENTITY; -- model_class_extension




ENTITY class_extension
ABSTRACT SUPERTYPE OF (ONEOF (
                       MODEL_CLASS_EXTENSION))

SUBTYPE OF(content_item);
	SELF\content_item.dictionary_definition: class_BSU;
END_ENTITY; -- class_extension




ENTITY class_extension_external_item
ABSTRACT SUPERTYPE OF (ONEOF (
                       DIALOGUE_RESOURCE))

SUBTYPE OF(external_item);
	code: external_item_code_type;
INVERSE
	belongs_to: model_class_extension FOR referenced_external_items;
UNIQUE
	UR1: code, belongs_to;
END_ENTITY; -- class_extension_external_item



ENTITY external_item
ABSTRACT SUPERTYPE OF(ONEOF(dictionary_external_item,
	class_extension_external_item,
	property_value_external_item));
	used_protocol: external_file_protocol;
	content: external_content;
END_ENTITY; -- external_item



ENTITY property_value_external_item
SUBTYPE OF(external_item);
END_ENTITY; -- property_value_external_item


ENTITY external_content
ABSTRACT SUPERTYPE OF (ONEOF (
                       TRANSLATED_EXTERNAL_CONTENT,
                       NOT_TRANSLATED_EXTERNAL_CONTENT,
                       NOT_TRANSLATABLE_EXTERNAL_CONTENT));
	consists_of: LIST[1:?] OF language_specific_content;
INVERSE
	content_of: external_item FOR content;
END_ENTITY; -- external_content




ENTITY property_value_recommended_presentation;
	prop_def: property_BSU;
	recommended_presentation_unit: unit;
	recommended_presentation_format: value_format_type;
WHERE
	WR1: presentation_unit_is_correct(SELF.prop_def,
		SELF.recommended_presentation_unit);
END_ENTITY;




ENTITY property_classification;
	its_value: classification_value;
	prop_def: property_BSU;
END_ENTITY; -- property_classification




ENTITY class_BSU_related_content
ABSTRACT SUPERTYPE OF (
                       DOCUMENT_CONTENT)

SUBTYPE OF(dictionary_external_item);
	SELF\content_item.dictionary_definition: class_related_BSU;
END_ENTITY; -- class_BSU_related_content




ENTITY dictionary_external_item
ABSTRACT SUPERTYPE OF (ONEOF (
                       CLASS_BSU_RELATED_CONTENT))

SUBTYPE OF(content_item, external_item);
	revision: revision_type;
END_ENTITY; -- dictionary_external_item




ENTITY data_protocol
ABSTRACT SUPERTYPE OF (ONEOF (
                       STANDARD_DATA_PROTOCOL,
                       NON_STANDARD_DATA_PROTOCOL))

SUBTYPE OF(external_file_protocol);
END_ENTITY; -- data_protocol




ENTITY dialogue_resource
ABSTRACT SUPERTYPE OF (ONEOF (
                       MESSAGE,
                       ILLUSTRATION))

SUBTYPE OF(class_extension_external_item);
	SELF\external_item.used_protocol: data_protocol;
END_ENTITY; -- dialogue_resource




ENTITY non_standard_protocol
ABSTRACT SUPERTYPE OF (ONEOF (
                       NON_STANDARD_DATA_PROTOCOL))

SUBTYPE OF(external_file_protocol);
END_ENTITY; -- non_standard_protocol




ENTITY standard_protocol
ABSTRACT SUPERTYPE OF (ONEOF (
                       STANDARD_DATA_PROTOCOL))

SUBTYPE OF(external_file_protocol);
END_ENTITY; -- standard_protocol


FUNCTION same_translations_for_table_extension(
	content: LIST[1:?] OF column): BOOLEAN;
LOCAL
	translated_values: SET OF translated_string_value := [];
END_LOCAL;

REPEAT i := 1 TO SIZEOF(content[1].values);
	translated_values :=
		get_translated_string_values_of_tuple(content, i);
	IF NOT(same_translations(translated_values))
	THEN
		RETURN(FALSE);
	END_IF;
END_REPEAT;

RETURN(TRUE);

END_FUNCTION; -- same_translations_for_table_extension


FUNCTION get_translated_string_values_of_tuple(
	content: LIST[1:?] OF column; index: INTEGER):
	SET OF translated_string_value;
LOCAL
	translated_values: SET OF translated_string_value := [];
END_LOCAL;

IF (index > SIZEOF(content[1].values))  -- abnormal case
THEN
	RETURN([]);
END_IF;

REPEAT i := 1 TO SIZEOF(content);
	IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.TRANSLATED_STRING_VALUE'
		IN TYPEOF(content[i].values[index]))
	THEN
		translated_values := translated_values +
			content[i].values[index];
	END_IF;
END_REPEAT;

RETURN(translated_values);

END_FUNCTION; -- get_translated_string_values_of_tuple




FUNCTION superclass_closure (
	current: SET OF class_BSU)    -- which classes
	:SET OF class_BSU;  -- all their superclasses or ?
 LOCAL
       superclasses : SET OF class_BSU := [];
 END_LOCAL;

        compute_superclass_closure (current, superclasses);
        RETURN (superclasses);

END_FUNCTION; -- superclass_closure

PROCEDURE compute_superclass_closure (
	current: SET OF class_BSU;    	-- new superclasses
	VAR visited: SET OF class_BSU); -- already known superclasses

IF EXISTS(current)  THEN
	IF SIZEOF(current) <> 0 THEN
		REPEAT i := 1 TO SIZEOF(current);
			IF SIZEOF (current[i].definition) = 0
	                THEN 	visited := ?;       -- all superclasses cannot be computed
	                	SKIP;
	                ELSE
	                        IF  EXISTS (current[i].definition[1]\class.its_superclass)
	                            AND NOT  (current[i].definition[1]\class.its_superclass IN visited)
	                        THEN 	visited := visited + [ current[i].definition[1]\class.its_superclass];
	                        	compute_superclass_closure([current[i].definition[1]\class.its_superclass], visited );
	        		END_IF;

			END_IF;
		 END_REPEAT;
	END_IF;
ELSE
     visited := ?;       -- all superclasses cannot be computed
END_IF;
END_PROCEDURE; -- compute_superclass_closure

FUNCTION item_caseof_closure (
	current: SET OF class_BSU)    -- which classes
	:SET OF class_BSU;  -- all classes they are caseof or ?
 LOCAL
       caseof : SET OF class_BSU
			:= next_item_caseof(superclass_closure (current));
 END_LOCAL;
        compute_item_caseof_closure (caseof, caseof);
        RETURN (caseof);
END_FUNCTION; -- item_caseof_closure

FUNCTION next_item_caseof (
	current: SET OF class_BSU)    -- which classes
	:SET OF class_BSU;  -- classes they are directly caseof or ?
 LOCAL
       caseof : SET OF class_BSU := [];
 END_LOCAL;
	IF  EXISTS(current) THEN
 		REPEAT i := 1 TO SIZEOF(current);
			IF SIZEOF (current[i].definition) = 0
                	THEN 	caseof := ?;
				-- all classes they are caseof cannot be computed
                		SKIP;
                	ELSE
				IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.'
					+'ITEM_CLASS_CASE_OF' IN
					TYPEOF(current[i].definition[1]))
                	THEN 	caseof := caseof
						+ current[i].definition[1]
						\item_class_case_of.is_case_of;
         			END_IF;
			END_IF;
		END_REPEAT;
        	RETURN (caseof);
	ELSE
	  	RETURN (?); -- all classes they are caseof cannot be computed
	END_IF;
END_FUNCTION; -- next_item_caseof

PROCEDURE compute_item_caseof_closure (
	current: SET OF class_BSU;    	-- last found caseof
	VAR visited: SET OF class_BSU);
		-- already known classes that are caseof (including current)
 LOCAL
       next : SET OF class_BSU ;        	-- computed new caseof
 END_LOCAL;
 IF  EXISTS(current) THEN
	IF SIZEOF(current) <> 0 THEN
        	next := superclass_closure (current);-- caseof by inheritance
		next := next_item_caseof ( next )+ next;
								-- and caseof by transitivity
		REPEAT i := 1 TO SIZEOF(next);
                	IF  NOT  (next[i] IN visited)
                 	THEN
				  visited := visited + next[i] ;
				  compute_item_caseof_closure([next[i]], visited );
        			END_IF;
		 END_REPEAT;
	END_IF;
ELSE
	visited := ?;
-- all classes that are caseof cannot be computed
END_IF;
END_PROCEDURE; -- compute_item_caseof_closure



FUNCTION is_acyclic (arg: generic_expression): BOOLEAN;
RETURN (acyclic (arg, []));
END_FUNCTION ; -- is_acyclic



FUNCTION acyclic (arg1: generic_expression; 
			arg2: SET OF generic_expression): BOOLEAN;

LOCAL
	result: BOOLEAN;
END_LOCAL;

IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.SIMPLE_GENERIC_EXPRESSION'
	IN TYPEOF (arg1)) 
THEN
	RETURN (TRUE);
END_IF;

IF arg1 IN arg2 
THEN 
	RETURN (FALSE);
END_IF;

IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.UNARY_GENERIC_EXPRESSION'
	IN TYPEOF (arg1) 
THEN 
	RETURN 
	(acyclic(arg1\unary_generic_expression.operand,arg2+[arg1]));
END_IF;

IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.BINARY_GENERIC_EXPRESSION'
	IN TYPEOF (arg1) 
THEN 
	RETURN 
	(acyclic(arg1\binary_generic_expression.operands[1],arg2+[arg1])
	AND
	acyclic(arg1\binary_generic_expression.operands[2],arg2+[arg1]));
END_IF;

IF 
'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.MULTIPLE_ARITY_GENERIC_EXPRESSION'

	IN TYPEOF (arg1) 
THEN 
	result := TRUE;
	REPEAT i := 1 TO 
			SIZEOF (arg1\multiple_arity_generic_expression.operands);
		result := result AND
		acyclic(arg1\multiple_arity_generic_expression.operands[i], 
arg2+[arg1]);
	END_REPEAT;

	RETURN (result);
END_IF;

END_FUNCTION; -- acyclic




FUNCTION is_int_expr (arg: numeric_expression) : BOOLEAN;

LOCAL
	i: INTEGER;
END_LOCAL;

IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.INT_LITERAL' IN TYPEOF(arg)
THEN 
	RETURN (TRUE); 
END_IF;
IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.REAL_LITERAL' IN TYPEOF(arg)
THEN 
	RETURN (FALSE); 
END_IF;
IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.INT_NUMERIC_VARIABLE' IN TYPEOF(arg)
THEN 
	RETURN (TRUE); 
END_IF;
IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.REAL_NUMERIC_VARIABLE' IN TYPEOF(arg)
THEN 
	RETURN (FALSE); 
END_IF;
IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.ABS_FUNCTION' IN TYPEOF(arg)
THEN 
	RETURN (is_int_expr(arg\unary_numeric_expression.operand));
END_IF;
IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.MINUS_FUNCTION' IN TYPEOF(arg)
THEN 
	RETURN (is_int_expr(arg\unary_numeric_expression.operand)); 
END_IF;
IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.SIN_FUNCTION' IN TYPEOF(arg))
		OR ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.COS_FUNCTION' IN TYPEOF(arg))
		OR ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.TAN_FUNCTION' IN TYPEOF(arg))
		OR ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.ASIN_FUNCTION' IN TYPEOF(arg))
		OR ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.ACOS_FUNCTION' IN TYPEOF(arg))
		OR ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.ATAN_FUNCTION' IN TYPEOF(arg))
		OR ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.EXP_FUNCTION' IN TYPEOF(arg))
		OR ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.LOG_FUNCTION' IN TYPEOF(arg))
		OR ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.LOG2_FUNCTION' IN TYPEOF(arg))
		OR ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.LOG10_FUNCTION' IN TYPEOF(arg))
		OR ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.SQUARE_ROOT_FUNCTION'
								IN TYPEOF(arg))
THEN 
	RETURN (FALSE);
END_IF;
IF 	('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.PLUS_EXPRESSION' IN TYPEOF(arg))
		OR ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.MULT_EXPRESSION'
								IN TYPEOF(arg))
		OR ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.MAXIMUM_FUNCTION'
								IN TYPEOF(arg))
		OR ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.MINIMUM_FUNCTION'
								IN TYPEOF(arg)) 
THEN 
	REPEAT i :=1 TO SIZEOF (
			arg\multiple_arity_numeric_expression.operands);
	IF NOT 
		is_int_expr(arg\multiple_arity_numeric_expression.operands[i]) 
	THEN 
		RETURN (FALSE);
	END_IF;
	END_REPEAT;
	RETURN (TRUE);
END_IF;
IF 	('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.MINUS_EXPRESSION' IN TYPEOF(arg))
		OR ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.POWER_EXPRESSION'
								IN TYPEOF(arg))
THEN 
	RETURN (is_int_expr(arg\binary_numeric_expression.operands[1])
		AND is_int_expr(arg\binary_numeric_expression.operands[2]));
END_IF;
IF	('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.DIV_EXPRESSION' IN TYPEOF(arg))
		OR ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.MOD_EXPRESSION' IN TYPEOF(arg))
THEN 
	RETURN(TRUE);	
END_IF;
IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.SLASH_EXPRESSION' IN TYPEOF(arg)
THEN 
	RETURN (FALSE); 	
END_IF;
IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.LENGTH_FUNCTION' IN TYPEOF(arg)
THEN 
	RETURN (TRUE); 
END_IF;
IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.VALUE_FUNCTION' IN TYPEOF(arg)
THEN 
	IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.INT_VALUE_FUNCTION'
								IN TYPEOF(arg) 
	THEN 
		RETURN (TRUE); 
	ELSE 
		RETURN (FALSE); 
	END_IF;
END_IF;
IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.INTEGER_DEFINED_FUNCTION'
								IN TYPEOF(arg)
THEN 
	RETURN(TRUE) ;
END_IF;
IF'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.REAL_DEFINED_FUNCTION' IN TYPEOF(arg)
THEN 
	RETURN(FALSE) ;
END_IF ;
IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.BOOLEAN_DEFINED_FUNCTION'
								IN TYPEOF(arg)
THEN 
	RETURN(FALSE) ;
END_IF ;
IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.STRING_DEFINED_FUNCTION'

								IN TYPEOF(arg)
THEN 
	RETURN (FALSE) ;
END_IF ;


RETURN (FALSE);

END_FUNCTION; -- is_int_expr




FUNCTION is_SQL_mappable (arg: expression) : BOOLEAN;

LOCAL
	i: INTEGER;
END_LOCAL;

IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.SIMPLE_NUMERIC_EXPRESSION'
								IN TYPEOF (arg) 
THEN 
	RETURN (TRUE);
END_IF;
IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.SQL_MAPPABLE_DEFINED_FUNCTION'
								IN TYPEOF (arg) 
THEN 
	RETURN (TRUE);
END_IF;
IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.MINUS_FUNCTION' IN TYPEOF(arg)
THEN 
	RETURN (is_SQL_mappable(arg\unary_numeric_expression.operand)); 
END_IF;
IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.ABS_FUNCTION' IN TYPEOF(arg))
		OR ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.SIN_FUNCTION' IN TYPEOF(arg))
		OR ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.COS_FUNCTION' IN TYPEOF(arg))
		OR ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.TAN_FUNCTION' IN TYPEOF(arg))
		OR ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.ASIN_FUNCTION' IN TYPEOF(arg))
		OR ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.ACOS_FUNCTION' IN TYPEOF(arg))
		OR ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.ATAN_FUNCTION' IN TYPEOF(arg))
		OR ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.EXP_FUNCTION' IN TYPEOF(arg))
		OR ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.LOG_FUNCTION' IN TYPEOF(arg))
		OR ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.LOG2_FUNCTION' IN TYPEOF(arg))
		OR ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.LOG10_FUNCTION' IN TYPEOF(arg))
		OR ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.SQUARE_ROOT_FUNCTION'
								IN TYPEOF(arg)) 
		OR ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.VALUE_FUNCTION' IN TYPEOF(arg))
		OR ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.LENGTH_FUNCTION'
								IN TYPEOF(arg))
THEN 
	RETURN (FALSE);
END_IF;
IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.PLUS_EXPRESSION' IN TYPEOF(arg))
		OR('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.MULT_EXPRESSION' IN TYPEOF(arg))
		OR('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.MAXIMUM_FUNCTION'
								IN TYPEOF(arg)) 
		OR('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.MINIMUM_FUNCTION'
								IN TYPEOF(arg)) 
THEN 
	REPEAT i :=1 TO SIZEOF (
			arg\multiple_arity_numeric_expression.operands);
		IF NOT is_SQL_mappable(
			arg\multiple_arity_numeric_expression.operands[i])
		THEN 
			RETURN (FALSE);
		END_IF;
	END_REPEAT;
RETURN (TRUE);
END_IF;
IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.MINUS_EXPRESSION' IN TYPEOF(arg))
		OR ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.SLASH_EXPRESSION' IN
								TYPEOF(arg))
THEN
		RETURN (is_SQL_mappable(
			arg\binary_numeric_expression.operands[1])
		AND is_SQL_mappable(arg\binary_numeric_expression.operands[2]));
END_IF;
IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.DIV_EXPRESSION' IN TYPEOF(arg))
		OR ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.MOD_EXPRESSION' IN TYPEOF(arg))
		OR('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.POWER_EXPRESSION'
								IN TYPEOF(arg))
THEN 
	RETURN (FALSE); 	
END_IF;
IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.SIMPLE_BOOLEAN_EXPRESSION'
								IN TYPEOF (arg) 
THEN 
	RETURN (TRUE);
END_IF;
IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.NOT_EXPRESSION' IN TYPEOF (arg)
THEN 
	RETURN (is_SQL_mappable (arg\UNARY_GENERIC_EXPRESSION.OPERAND));
END_IF;
IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.ODD_FUNCTION'IN TYPEOF (arg))
		OR ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.XOR_EXPRESSION'
								IN TYPEOF (arg)) 
THEN	
	RETURN (FALSE);
END_IF;
IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.AND_EXPRESSION' IN TYPEOF (arg))
		OR ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.OR_EXPRESSION' IN TYPEOF (arg))
THEN
	REPEAT i:=1 TO SIZEOF (
			arg\MULTIPLE_ARITY_BOOLEAN_EXPRESSION.OPERANDS);
		IF NOT is_SQL_mappable (
			arg\MULTIPLE_ARITY_BOOLEAN_EXPRESSION.OPERANDS[i]) 
		THEN 
			RETURN (FALSE);
		END_IF;
	END_REPEAT;
	RETURN (TRUE);
END_IF;
IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.EQUALS_EXPRESSION' IN TYPEOF (arg)
THEN
	RETURN(is_SQL_mappable (
			arg\BINARY_GENERIC_EXPRESSION.OPERANDS [1])
		AND is_SQL_mappable(
			arg\BINARY_GENERIC_EXPRESSION.OPERANDS [2]));
END_IF;
IF	('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.COMPARISON_EQUAL' IN TYPEOF (arg))
		OR ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.COMPARISON_GREATER'
								IN TYPEOF (arg)) 
		OR ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.COMPARISON_GREATER_EQUAL'
								IN TYPEOF (arg))
		OR ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.COMPARISON_LESS'
								IN TYPEOF (arg)) 
		OR ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.COMPARISON_LESS_EQUAL'
								IN TYPEOF (arg)) 
		OR ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.COMPARISON_NOT_EQUAL'
								IN TYPEOF (arg)) 
		OR ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.LIKE_EXPRESSION'
								IN TYPEOF (arg)) 
THEN
	RETURN (is_SQL_mappable (arg\COMPARISON_EXPRESSION.OPERANDS[1])
		AND is_SQL_mappable (arg\COMPARISON_EXPRESSION.OPERANDS[2]));
END_IF;
IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.INTERVAL_EXPRESSION' IN TYPEOF(arg)
THEN 
	RETURN (is_SQL_mappable(arg\interval_expression.interval_low) 
		AND is_SQL_mappable(arg\interval_expression.interval_high)
		AND is_SQL_mappable(arg\interval_expression.interval_item));
END_IF;
IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.NUMERIC_DEFINED_FUNCTION'
								IN TYPEOF(arg)) 
		OR ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.BOOLEAN_DEFINED_FUNCTION'
								IN TYPEOF(arg))
		OR ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.STRING_DEFINED_FUNCTION'
								IN TYPEOF(arg))  
THEN 
		RETURN (FALSE) ;
END_IF;


IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.SIMPLE_STRING_EXPRESSION'
								IN TYPEOF(ARG) 
THEN 
	RETURN (TRUE);
END_IF;
IF 	('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.INDEX_EXPRESSION' IN TYPEOF(arg))
		OR ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.SUBSTRING_EXPRESSION'
								IN TYPEOF(arg)) 
		OR ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.CONCAT_EXPRESSION'
								IN TYPEOF(arg)) 
		OR ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.FORMAT_FUNCTION'

								IN TYPEOF(arg)) 
THEN 
	RETURN (FALSE);
END_IF;


	RETURN (FALSE);
END_FUNCTION; -- is_SQL_mappable




FUNCTION compute_known_visible_properties(cl: class_BSU):
	SET OF property_BSU;
LOCAL
	s: SET OF property_BSU := [];
END_LOCAL;

s := s + USEDIN(cl, 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA' +
	'.PROPERTY_BSU.NAME_SCOPE');
IF SIZEOF(cl.definition) = 0
THEN
	RETURN(s);
ELSE
	IF EXISTS(cl.definition[1]\class.its_superclass) THEN
		s := s + compute_known_visible_properties(
			cl.definition[1]\class.its_superclass);
	END_IF;
	
	RETURN(s);
END_IF;

END_FUNCTION; -- compute_known_visible_properties




FUNCTION compute_known_applicable_properties(cl: class_BSU): 
	SET OF property_BSU;

LOCAL 
	s: SET OF property_BSU := [];
END_LOCAL;

IF SIZEOF(cl.definition)=0
THEN 
	RETURN(s);
ELSE
	REPEAT i := 1 TO SIZEOF(cl.definition[1]\class.described_by);
		s := s + cl.definition[1]\class.described_by[i];
	END_REPEAT;

	IF EXISTS(cl.definition[1]\class.its_superclass) 
	THEN 
		s := s + compute_known_applicable_properties(
			cl.definition[1]\class.its_superclass);
	END_IF;

	RETURN(s); 
END_IF;
END_FUNCTION; -- compute_known_applicable_properties




FUNCTION compute_known_applicable_data_types(cl: class_BSU):
	SET OF data_type_BSU;
LOCAL
	s: SET OF data_type_BSU := [];
END_LOCAL;

IF SIZEOF(cl.definition) = 0
THEN
	RETURN(s);
ELSE
	REPEAT i := 1 TO SIZEOF(cl.definition[1]\class.defined_types);
		s := s + cl.definition[1]\class.defined_types[i];
	END_REPEAT;
	
	IF EXISTS(cl.definition[1]\class.its_superclass) 
	THEN
		s := s + compute_known_applicable_data_types(
			cl.definition[1]\class.its_superclass);
	END_IF;
	
	RETURN(s);
END_IF;

END_FUNCTION; -- compute_known_applicable_data_types




FUNCTION acyclic_superclass_relationship(
	current: class_BSU; visited: SET OF class): LOGICAL;

IF SIZEOF(current.definition) = 1 THEN 
	IF current.definition[1] IN visited THEN
		RETURN(FALSE);

	ELSE
		IF EXISTS(current.definition[1]\class.its_superclass)
		THEN 
			RETURN(acyclic_superclass_relationship(
				current.definition[1]\class.its_superclass,
				visited + current.definition[1])); 
		ELSE
			RETURN(TRUE);
		END_IF;
	END_IF;
ELSE
	RETURN(UNKNOWN);
END_IF;
END_FUNCTION; -- acyclic_superclass_relationship




FUNCTION all_class_descriptions_reachable(cl: class_BSU): LOGICAL;

IF NOT EXISTS(cl)
THEN
	RETURN(?);
END_IF;

IF SIZEOF(cl.definition) = 0
THEN
	RETURN(FALSE);
END_IF;

IF NOT(EXISTS(cl.definition[1]\class.its_superclass))
THEN
	RETURN(TRUE);
ELSE
	RETURN(all_class_descriptions_reachable(
		cl.definition[1]\class.its_superclass));
END_IF;

END_FUNCTION; -- all_class_descriptions_reachable




FUNCTION list_to_set(l: LIST [0:?] OF GENERIC:type_elem):
	SET OF GENERIC: type_elem;

LOCAL
	s: SET OF GENERIC: type_elem := [];
END_LOCAL;

REPEAT i := 1 TO SIZEOF(l);
	s := s + l[i];
END_REPEAT;

RETURN(s);
END_FUNCTION; -- list_to_set




FUNCTION check_properties_applicability(cl: class): LOGICAL;
LOCAL
	inter: SET OF property_bsu := [];
END_LOCAL;

IF EXISTS(cl.its_superclass)
THEN
	IF (SIZEOF(cl.its_superclass.definition)=1)
	THEN
		inter := (list_to_set(cl.described_by) * 
			cl.its_superclass.definition[1]\class.
			known_applicable_properties);
		RETURN(inter = []);
	ELSE
		RETURN(UNKNOWN);
	END_IF;
ELSE
	RETURN(TRUE);
END_IF;

END_FUNCTION; -- check_properties_applicability




FUNCTION check_datatypes_applicability(cl: class): LOGICAL;
LOCAL
	inter: SET OF data_type_bsu := [];
END_LOCAL;

IF EXISTS(cl.its_superclass)
THEN
	IF (SIZEOF(cl.its_superclass.definition) = 1)
	THEN
		inter := cl.defined_types * 
			cl.its_superclass.definition[1]\class.
			known_applicable_data_types;
		RETURN(inter = []);
	ELSE
		RETURN(UNKNOWN);
	END_IF;
ELSE
	RETURN(TRUE);
END_IF;

END_FUNCTION; -- check_datatypes_applicability




FUNCTION compute_known_visible_data_types(cl: class_BSU):
	SET OF data_type_BSU;
LOCAL
	s: SET OF data_type_BSU :=[ ];
END_LOCAL;

s := s + USEDIN(cl, 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA' +
	'.DATA_TYPE_BSU.NAME_SCOPE');

IF SIZEOF(cl.definition) = 0
THEN
	RETURN(s);
ELSE
	IF EXISTS(cl.definition[1]\class.its_superclass) 
	THEN
		s := s + compute_known_visible_data_types(
			cl.definition[1]\class.its_superclass);
	END_IF;

	RETURN(s);
END_IF;

END_FUNCTION; -- compute_known_visible_data_types




FUNCTION definition_available_implies(
	BSU: basic_semantic_unit;
	expression: LOGICAL): LOGICAL;

RETURN(NOT(SIZEOF(BSU.definition) = 1) OR expression);

END_FUNCTION; -- definition_available_implies




FUNCTION is_subclass(sub, super: class): LOGICAL;
	IF (NOT EXISTS(sub)) OR (NOT EXISTS(super)) THEN
		RETURN(UNKNOWN);
	END_IF;
	
	IF sub = super
	THEN
		RETURN(TRUE);
	END_IF;
	
	IF NOT EXISTS(sub.its_superclass) 
	THEN
		
		RETURN(FALSE); 
	END_IF;
	
	IF SIZEOF(sub.its_superclass.definition) = 1 
	THEN


		IF (sub.its_superclass.definition[1] = super) 
		THEN
			RETURN(TRUE);
		ELSE
			RETURN(is_subclass(sub.its_superclass.definition[1],
				super));
		END_IF;
	ELSE
		RETURN(UNKNOWN);
	END_IF;

END_FUNCTION; -- is_subclass




FUNCTION check_label_length(l: translatable_label;
	l_length: INTEGER): BOOLEAN;

IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.TRANSLATED_LABEL'

	IN TYPEOF(l) 
THEN 
	REPEAT i :=1 TO SIZEOF(l.labels);
		IF LENGTH(l.labels[i]) > l_length 
		THEN
			RETURN(FALSE);
		END_IF;
	END_REPEAT;

	RETURN(TRUE);

ELSE 
	RETURN(LENGTH(l) <= l_length); 
END_IF;
END_FUNCTION; -- check_label_length 




FUNCTION check_syn_length(s: syn_name_type; s_length: INTEGER):BOOLEAN;

IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.LABEL_WITH_LANGUAGE'

	IN TYPEOF(s)
THEN
	RETURN(LENGTH(s.l) <= s_length); 
ELSE
	RETURN(LENGTH(s) <= s_length); 
END_IF;
END_FUNCTION; -- check_syn_length 




FUNCTION codes_are_unique(values: LIST OF dic_value): LOGICAL;
LOCAL
	ls: SET OF STRING := [];
	li: SET OF INTEGER := [];
END_LOCAL;

IF('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.VALUE_CODE_TYPE' IN
	TYPEOF(values[1].value_code))
THEN
	REPEAT i := 1 TO SIZEOF(values);
		ls := ls + values[i].value_code;
	END_REPEAT;

	RETURN(SIZEOF(values) = SIZEOF(ls));
ELSE
	IF('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.INTEGER_TYPE' IN

		TYPEOF(values[1].value_code))
	THEN
		REPEAT i := 1 TO SIZEOF(values);
			li := li + values[i].value_code;
		END_REPEAT;

		RETURN(SIZEOF(values) = SIZEOF(li));
	ELSE
		RETURN(?);
	END_IF;
END_IF;

END_FUNCTION; -- codes_are_unique




FUNCTION is_condition_det(prop: property_value): LOGICAL;

IF(SIZEOF(prop.prop_def.definition) > 0) THEN
	RETURN('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.CONDITION_DET'

		IN TYPEOF(prop.prop_def.definition[1]));
ELSE
	RETURN(UNKNOWN);
END_IF;

END_FUNCTION; -- is_condition_det




FUNCTION is_dependent_p_det(prop: property_bsu): LOGICAL;

IF(SIZEOF(prop.definition) > 0) THEN
	RETURN('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.DEPENDENT_P_DET'

		IN TYPEOF(prop.definition[1]));
ELSE
	RETURN(UNKNOWN);
END_IF;

END_FUNCTION; -- is_dependent_p_det




FUNCTION all_context_parameters_referenced(
	cdpv: context_dependent_property_value): LOGICAL;

IF(SIZEOF(cdpv\property_value.prop_def.definition) > 0) THEN
	RETURN(cdpv\property_value.prop_def.definition[1]\
		dependent_p_det.depends_on
		>= collects_assigned_instance_properties(
		list_to_set(cdpv.the_context)));
ELSE
	RETURN(UNKNOWN);
END_IF;

END_FUNCTION; -- all_context_parameters_referenced




FUNCTION collects_assigned_instance_properties(
	props: SET [0:?] OF property_value): SET OF property_BSU;

LOCAL
	assign_prop: SET OF property_BSU;
		-- assigned properties of the dic_class_instance
END_LOCAL;

assign_prop := [];

REPEAT i := 1 TO SIZEOF(props);
	assign_prop := assign_prop + props[i].prop_def;
END_REPEAT;

RETURN(assign_prop);

END_FUNCTION; -- collects_assigned_instance_properties




FUNCTION applicable_properties(cl: class_BSU;
	prop: AGGREGATE OF property_BSU): LOGICAL;

IF SIZEOF(prop) = 0
THEN
	RETURN(TRUE);
END_IF;

IF NOT EXISTS(cl)
THEN
	RETURN(UNKNOWN);
END_IF;

IF SIZEOF(cl.definition) = 0
THEN
	RETURN(UNKNOWN);
END_IF;

prop := prop - list_to_set(cl.definition[1]\class.described_by);

IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA' +
	'.A_PRIORI_SEMANTIC_RELATIONSHIP' IN TYPEOF(cl.definition[1])
THEN
	prop := prop - list_to_set(cl.definition[1]
		\a_priori_semantic_relationship.referenced_properties);
END_IF;

IF SIZEOF(prop) = 0
THEN
	RETURN(TRUE);
ELSE
	IF EXISTS(cl.definition[1]\class.its_superclass)
	THEN
		RETURN(applicable_properties(cl.definition[1]
			\class.its_superclass, prop));
	ELSE
		RETURN(FALSE);
	END_IF;
END_IF;

END_FUNCTION; -- applicable_properties




FUNCTION check_property_values_translations(props:
	LIST OF property_value): LOGICAL;
LOCAL
	translated_string_values: SET OF translated_string_value := [];
END_LOCAL;

	REPEAT i := 1 TO SIZEOF(props);
		translated_string_values :=
			translated_string_values + props[i].its_value;
	END_REPEAT;

	RETURN(same_translations(translated_string_values));
END_FUNCTION; -- check_property_values_translations




FUNCTION same_translations(translated_string_values: SET OF
	translated_string_value): LOGICAL;
LOCAL
	comp: translated_string_value;
END_LOCAL;

	IF (SIZEOF(translated_string_values) <> 0)
	THEN
		comp := translated_string_values[1];
		REPEAT i := 2 TO SIZEOF(translated_string_values);
			IF (translated_string_values[i].languages <>
				comp.languages)
			THEN
				RETURN(FALSE);
			END_IF;
		END_REPEAT;

		RETURN(TRUE);
	ELSE
		RETURN(UNKNOWN);
	END_IF;

END_FUNCTION; -- same_translations




FUNCTION check_class_type_for_dic_item_instance(dic_cl: dic_item_instance): LOGICAL;

IF (SIZEOF(dic_cl.class_def.definition) = 1) THEN

	IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.' +
		'DIC_COMPONENT_INSTANCE') IN TYPEOF(dic_cl)
	THEN
			RETURN(('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA'
				+ '.COMPONENT_CLASS'
				IN TYPEOF(dic_cl.class_def.definition[1])));
 	END_IF;

	IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.' +
		'DIC_MATERIAL_INSTANCE') IN TYPEOF(dic_cl)
	THEN
			RETURN(('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA'
				+ '.MATERIAL_CLASS'
				IN TYPEOF(dic_cl.class_def.definition[1])));
	END_IF;

	IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.' +
		'DIC_FEATURE_INSTANCE') IN TYPEOF(dic_cl)
	THEN
			RETURN('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA'
				+ '.FEATURE_CLASS'
				IN TYPEOF(dic_cl.class_def.definition[1]));
	END_IF;

	IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.' +
		'DIC_ITEM_INSTANCE') IN TYPEOF(dic_cl)
	THEN
			RETURN(('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA'
				+ '.ITEM_CLASS'
				IN TYPEOF(dic_cl.class_def.definition[1])));
	END_IF;
ELSE
	RETURN(UNKNOWN);
END_IF;
END_FUNCTION; -- check_class_type_for_dic_item_instance

	

FUNCTION collects_property_context(prop: property_BSU;
	inst: dic_class_instance): SET OF property_BSU;

LOCAL
	assigned_context_parameters: SET OF property_BSU;
		--assigned context parameters of the dic_class_instance
	correct: BOOLEAN; --prop belongs to inst properties
END_LOCAL;

assigned_context_parameters := [];
correct := FALSE;

REPEAT i := 1 TO SIZEOF(inst.properties);

	IF inst.properties[i].prop_def :=: prop
	THEN
		correct := TRUE;
	END_IF;

	IF ((SIZEOF(inst.properties[i].prop_def.definition) = 0)
		OR ((SIZEOF(inst.properties[i].prop_def.definition) = 1)
	AND (('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.CONDITION_DET')
	IN TYPEOF(inst.properties[i].prop_def.definition[1]))))
	THEN
		assigned_context_parameters := assigned_context_parameters
			+ inst.properties[i].prop_def;
	END_IF;

	IF (('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA' +
	'.CONTEXT_DEPENDENT_PROPERTY_VALUE') IN
	TYPEOF(inst.properties[i]))
	THEN
		assigned_context_parameters := assigned_context_parameters
			+ collects_assigned_instance_properties(list_to_set(
			inst.properties[i].the_context));
	END_IF;

END_REPEAT;

IF NOT correct
THEN
	assigned_context_parameters := [];
END_IF;

RETURN(assigned_context_parameters );

END_FUNCTION; -- collects_property_context




FUNCTION compatible_type_and_value(dom: property_or_data_type_BSU;
	val: primitive_value): LOGICAL;

LOCAL
	temp: SET[0:1] OF class_BSU;
	set_string: SET OF STRING := [];
	set_integer: SET OF INTEGER := [];
	code_type: non_quantitative_code_type;
	int_type: non_quantitative_int_type;
END_LOCAL;

IF data_type_typeof(dom) = []
THEN
	RETURN(UNKNOWN);
END_IF;



IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.INTEGER_VALUE' IN TYPEOF(val))
THEN
    IF (('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.NON_QUANTITATIVE_INT_TYPE' IN
		data_type_typeof(dom))
		AND (SIZEOF(data_type_non_quantitative_int_type(dom)) = 1))
    THEN
		set_integer := [];
		code_type := data_type_non_quantitative_int_type(dom)[1];

		REPEAT j := 1 TO SIZEOF(code_type.domain.its_values);
			set_integer := set_integer + code_type.domain.its_values[j].value_code;
		END_REPEAT;
        RETURN(val IN set_integer);
    ELSE
		RETURN(('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.INT_TYPE'
			IN data_type_typeof(dom)) OR
			(('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.NUMBER_TYPE'
			IN data_type_typeof(dom))
			AND NOT('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.REAL_TYPE'
			IN data_type_typeof(dom))));
    END_IF;
END_IF;

IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.REAL_VALUE' IN TYPEOF(val))
THEN
	RETURN(('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.REAL_TYPE'
		IN data_type_typeof(dom)) OR
		(('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.NUMBER_TYPE'
		IN data_type_typeof(dom))
		AND NOT('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.INT_TYPE'
		IN data_type_typeof(dom))));
END_IF;

IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.NUMBER_VALUE' IN TYPEOF(val))
THEN
	RETURN('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.NUMBER_TYPE'
		IN data_type_typeof(dom));
END_IF;

IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.BOOLEAN_VALUE' IN TYPEOF(val))
THEN
	RETURN('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.BOOLEAN_TYPE'
		IN data_type_typeof(dom));
END_IF;

IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.TRANSLATABLE_STRING_VALUE' IN TYPEOF(val))
THEN
	IF (('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA' +
		'.NON_QUANTITATIVE_CODE_TYPE') IN  data_type_typeof(dom))
    THEN
        IF (SIZEOF(data_type_non_quantitative_code_type(dom)) = 1)
		THEN
			set_string := [];
			code_type := data_type_non_quantitative_code_type(dom)[1];

			REPEAT j := 1 TO SIZEOF(code_type.domain.its_values);
				set_string := set_string + code_type.domain.its_values[j].value_code;
			END_REPEAT;

            RETURN(('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.STRING_VALUE' IN TYPEOF(val)) AND (val IN set_string));

        ELSE
            RETURN(UNKNOWN);
        END_IF;
	ELSE
		RETURN('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA' +
			'.STRING_TYPE' IN data_type_typeof(dom));
	END_IF;
END_IF;


IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.ENTITY_INSTANCE_VALUE'
	IN TYPEOF(val)
THEN
	IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA' +
		'.UNCONTROLLED_ENTITY_INSTANCE_VALUE'
		IN TYPEOF(val)
	THEN
		RETURN(UNKNOWN);
	END_IF;
	IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.ENTITY_INSTANCE_TYPE'
		IN data_type_typeof(dom))
AND (SIZEOF(data_type_type_name(dom)) <> 0)
		AND (data_type_type_name(dom) <= TYPEOF(val))
	THEN
		RETURN(TRUE);
	ELSE
		RETURN(FALSE);
	END_IF;
END_IF;

IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.DIC_CLASS_INSTANCE'
	IN TYPEOF(val)
THEN
	IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.CLASS_INSTANCE_TYPE'
		IN data_type_typeof(dom))
		AND (SIZEOF(data_type_class_of(dom)) <> 0)
	THEN
		temp := data_type_class_of(dom);
		RETURN(compatible_class_and_class(temp[1],
			val\dic_class_instance.class_def));
	ELSE
		RETURN(FALSE);
	END_IF;
END_IF;

IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.LEVEL_SPEC_VALUE' IN TYPEOF(val)
THEN
	IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.LEVEL_TYPE'

		IN data_type_typeof(dom))
	THEN
		RETURN(compatible_level_type_and_instance(
			data_type_level_spec(dom),
			data_type_level_value_typeof(dom),
			val));
	ELSE
		RETURN(FALSE);
	END_IF;
END_IF;

RETURN(UNKNOWN);

END_FUNCTION; -- compatible_type_and_value




FUNCTION data_type_typeof(type_spec: property_or_data_type_BSU):
	SET OF STRING;

LOCAL
	res: BOOLEAN := FALSE;
	x: data_type;
END_LOCAL;

IF NOT EXISTS(type_spec)
THEN
	RETURN([]); -- type_spec is indeterminate
END_IF;

IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.PROPERTY_BSU' IN
	TYPEOF(type_spec))
THEN
	IF NOT(SIZEOF(type_spec.definition) = 0)
	THEN
		x := type_spec.definition[1]\property_DET.domain;
		res := TRUE;
	END_IF;
ELSE
	IF NOT(SIZEOF(type_spec.definition) = 0)
	THEN
		x := type_spec.definition[1]
			\data_type_element.type_definition;
		res := TRUE;
	END_IF;
END_IF;

IF NOT(res)
THEN
	RETURN([]);
END_IF;

IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.NAMED_TYPE' IN TYPEOF(x))

THEN
	IF NOT(SIZEOF(x\named_type.referred_type.definition) = 0)
	THEN
		RETURN(data_type_typeof(x\named_type.referred_type));
	ELSE
		RETURN([]);
	END_IF;
ELSE
	RETURN(TYPEOF(x));
END_IF;

END_FUNCTION; -- data_type_typeof




FUNCTION data_type_type_name(t: property_or_data_type_BSU):
	SET [0:?] OF STRING;

LOCAL
	res: BOOLEAN := FALSE;
	s: SET [0:1] OF STRING := [];
	x: data_type;
END_LOCAL;

IF NOT EXISTS(t)
THEN
	RETURN([]); -- t is indeterminate
END_IF;

IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.PROPERTY_BSU' IN TYPEOF(t))
THEN
	IF NOT(SIZEOF(t.definition) = 0)
	THEN
		x := t.definition[1]\property_DET.domain;
		res := TRUE;
	END_IF;
ELSE
	IF NOT(SIZEOF(t.definition) = 0)
	THEN
		x := t.definition[1]\data_type_element.type_definition;
		res := TRUE;
	END_IF;
END_IF;

IF res
THEN
	IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.ENTITY_INSTANCE_TYPE'
		IN TYPEOF(x))
	THEN
		s := x\entity_instance_type.type_name;
	END_IF;

	IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.NAMED_TYPE'

		IN TYPEOF(x))
	THEN
		s := data_type_type_name(x\named_type.referred_type);
	END_IF;
END_IF;

RETURN(s);

END_FUNCTION; -- data_type_type_name




FUNCTION data_type_class_of(type_spec: property_or_data_type_BSU):
	SET[0:1] OF class_BSU;

LOCAL
	res: BOOLEAN := FALSE;
	s: SET[0:1] OF class_BSU := [];
	x: data_type;
END_LOCAL;

IF NOT EXISTS(type_spec)
THEN
	RETURN([]); -- type_spec is indeterminate
END_IF;

IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.PROPERTY_BSU' IN
	TYPEOF(type_spec))
THEN
	IF NOT(SIZEOF(type_spec.definition) = 0)
	THEN
		x := type_spec.definition[1]\property_DET.domain;
		res := TRUE;
	END_IF;
ELSE
	IF NOT(SIZEOF(type_spec.definition) = 0)
	THEN
		x := type_spec.definition[1]\data_type_element
			.type_definition;
		res := TRUE;
	END_IF;
END_IF;

IF res
THEN
	IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.CLASS_INSTANCE_TYPE' IN
		TYPEOF(x))
	THEN
		s := s + x\class_instance_type.domain;
		RETURN(s);
	END_IF;

	IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.NAMED_TYPE'

		IN TYPEOF(x))
	THEN
		s := data_type_class_of(x\named_type.referred_type);
		RETURN(s);
	END_IF;
END_IF;

RETURN(s);

END_FUNCTION; -- data_type_class_of




FUNCTION compatible_class_and_class(cl1:class_BSU; cl2:class_BSU):
	LOGICAL;

IF (cl1.defined_by\basic_semantic_unit.code =
	cl2.defined_by\basic_semantic_unit.code) AND
	(cl1\basic_semantic_unit.code =
	cl2\basic_semantic_unit.code) AND
	(cl1\basic_semantic_unit.version >=
	cl2\basic_semantic_unit.version)
THEN 

	RETURN(TRUE);
END_IF;

IF (SIZEOF(cl2\basic_semantic_unit.definition) = 0)
THEN 
	RETURN(UNKNOWN);
END_IF;

IF (SIZEOF(cl2\basic_semantic_unit.definition) = 1)
	AND (NOT EXISTS(cl2\basic_semantic_unit.
	definition[1]\class.its_superclass))
THEN 
	RETURN(FALSE);
END_IF;

RETURN(compatible_class_and_class(cl1, cl2\basic_semantic_unit.
	definition[1]\class.its_superclass));

END_FUNCTION; -- compatible_class_and_class




FUNCTION compatible_level_type_and_instance(
	levels: LIST [1:4] OF UNIQUE level; value_typeof: SET OF STRING;
	val: level_spec_value): BOOLEAN;

LOCAL
	c_val: BOOLEAN;
END_LOCAL;

c_val := FALSE;

IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.INT_LEVEL_SPEC_VALUE'
	IN TYPEOF(val))
	AND NOT('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.REAL_TYPE' IN
	value_typeof)
THEN
	c_val := TRUE;
END_IF;

IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.REAL_LEVEL_SPEC_VALUE'
	IN TYPEOF(val))
	AND NOT('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.INT_TYPE'

	IN value_typeof)
THEN
	c_val := TRUE;
END_IF;

RETURN(c_val AND (right_values_for_level_spec(levels, val)));

END_FUNCTION; -- compatible_level_type_and_instance




FUNCTION right_values_for_level_spec(
	levels: LIST [1:4] OF UNIQUE level;
	val: level_spec_value): BOOLEAN;

LOCAL
	c_place: BOOLEAN;
	lev: SET [1:4] OF level;
END_LOCAL;

c_place := TRUE;
lev := list_to_set(levels);

IF EXISTS(val.values[1])
THEN
	IF level.min IN lev
	THEN
		lev := lev - [level.min];
	ELSE
		c_place := FALSE;
	END_IF;
END_IF;

IF EXISTS(val.values[2])
THEN
	IF level.nom IN lev
	THEN
		lev := lev - [level.nom];
	ELSE
		c_place := FALSE;
	END_IF;
END_IF;

IF EXISTS(val.values[3])
THEN
	IF level.typ IN lev
	THEN
		lev := lev - [level.typ];
	ELSE
		c_place := FALSE;
	END_IF;
END_IF;

IF EXISTS(val.values[4])
THEN
	IF level.max IN lev
	THEN
		lev := lev - [level.max];
	ELSE
		c_place := FALSE;
	END_IF;
END_IF;

IF (c_place)
THEN
	RETURN(TRUE);
ELSE
	RETURN(FALSE);
END_IF;

END_FUNCTION; -- right_values_for_level_spec




FUNCTION data_type_level_spec(t: property_or_data_type_BSU):
	LIST[0:4] OF UNIQUE Level;

LOCAL
	res: BOOLEAN := FALSE;
	s: LIST[0:4] OF UNIQUE level := [];
	x: data_type;
END_LOCAL;

IF NOT EXISTS(t)
THEN
	RETURN([]); -- t is indeterminate
END_IF;

IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.PROPERTY_BSU' IN TYPEOF(t))
THEN
	IF NOT(SIZEOF(t.definition) = 0)
	THEN
		x := t.definition[1]\property_DET.domain;
		res := TRUE;
	END_IF;
ELSE
	IF NOT(SIZEOF(t.definition) = 0)
	THEN
		x := t.definition[1]\data_type_element.type_definition;
		res := TRUE;
	END_IF;
END_IF;

IF res
THEN
	IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.LEVEL_TYPE'
		IN TYPEOF(x))
	THEN
		s := x\level_type.levels;
	END_IF;

	IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.NAMED_TYPE'

		IN TYPEOF(x))
	THEN
		s := data_type_level_spec(x\named_type.referred_type);
	END_IF;
END_IF;

RETURN(s);

END_FUNCTION; -- data_type_level_spec




FUNCTION data_type_level_value_typeof(t: property_or_data_type_BSU):
	SET OF STRING;

LOCAL
	res: BOOLEAN := FALSE;
	s: SET OF STRING := [];
	x: data_type;
END_LOCAL;

IF NOT EXISTS(t)
THEN
	RETURN([]); -- t is indeterminate
END_IF;

IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.PROPERTY_BSU' IN TYPEOF(t))
THEN
	IF NOT(SIZEOF(t.definition) = 0)
	THEN
		x := t.definition[1]\property_DET.domain;
		res := TRUE;
	END_IF;
ELSE
	IF NOT(SIZEOF(t.definition) = 0)
	THEN
		x := t.definition[1]\data_type_element.type_definition;
		res := TRUE;
	END_IF;
END_IF;

IF res
THEN
	IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.LEVEL_TYPE'
		IN TYPEOF(x))
	THEN
		s := TYPEOF(x\level_type.value_type);
	END_IF;

	IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.NAMED_TYPE'

		IN TYPEOF(x))
	THEN
		s := data_type_level_value_typeof(
			x\named_type.referred_type);
	END_IF;

END_IF;

RETURN(s);

END_FUNCTION; -- data_type_level_value_typeof




FUNCTION collects_assigned_properties(
	p_a: AGGREGATE OF property_assignment): LIST OF property_BSU;

LOCAL
	assign_prop: LIST OF property_BSU;
	-- assigned properties of the
	-- multiple_arity_class_instance_constructor
END_LOCAL;

assign_prop := [];

REPEAT i := 1 TO SIZEOF(p_a);
	assign_prop := assign_prop + p_a[i].prop_def;
END_REPEAT;

RETURN(assign_prop);

END_FUNCTION; -- collects_assigned_properties




FUNCTION collects_referenced_library_expressions(
	p_a: AGGREGATE OF property_assignment)
	: LIST [1:?] OF library_expression;

LOCAL
	assign_exp: LIST [0:?] OF library_expression := [];
END_LOCAL;

REPEAT i := 1 TO SIZEOF(p_a);
	IF EXISTS(p_a[i].its_value)
	THEN
		assign_exp := assign_exp + p_a[i].its_value;
	END_IF;
END_REPEAT;

RETURN(assign_exp);

END_FUNCTION; -- collects_referenced_library_expressions




FUNCTION compatible_type_and_library_expression(
	dom: property_or_data_type_BSU;
	expr: library_expression): LOGICAL;

LOCAL
	temp: SET[0:1] OF class_BSU;
END_LOCAL;

IF (data_type_typeof(dom) = [])
THEN 
	RETURN(UNKNOWN);
END_IF;


IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.LEVEL_SPEC_EXPRESSION'
	IN TYPEOF(expr))
THEN
	IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.LEVEL_TYPE'
		IN data_type_typeof(dom))
		AND (list_to_set(data_type_level_spec(dom))
		= list_to_set(expr\level_spec_expression.levels))
		AND (TYPEOF(expr\level_spec_expression.value_type)
		<= data_type_level_value_typeof(dom))
	THEN
		RETURN(TRUE);
	ELSE
		RETURN(FALSE);
	END_IF;
END_IF;



IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.ENTITY_INSTANCE_EXPRESSION'
	IN TYPEOF(expr))
THEN
	IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.ENTITY_INSTANCE_TYPE'
		IN data_type_typeof(dom))
		AND (data_type_type_name(dom)
		<= expr\entity_instance_expression.type_name)
	THEN
		RETURN(TRUE);
	ELSE
		RETURN(FALSE);
	END_IF;
END_IF;



IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.CLASS_INSTANCE_EXPRESSION'
	IN TYPEOF(expr))
THEN
	IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.CLASS_INSTANCE_TYPE'

		IN data_type_typeof(dom)) AND
		(SIZEOF(data_type_class_of(dom)) = 1)
	THEN
		temp := data_type_class_of(dom);
		RETURN(compatible_class_and_class(
			temp[1], expr\class_instance_expression.expr_type));
	ELSE
		RETURN(FALSE);
	END_IF;
END_IF;


RETURN(compatible_simple_type_and_expression(dom, expr));

END_FUNCTION; -- compatible_type_and_library_expression





FUNCTION compatible_simple_type_and_expression(
	dom: property_or_data_type_BSU; expr: expression): LOGICAL;

IF (data_type_typeof(dom) = [])
THEN
	RETURN(UNKNOWN);
END_IF;

IF (('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.NUMERIC_EXPRESSION' IN TYPEOF(expr))
	AND is_int_expr(expr))
THEN
	IF (('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.INT_TYPE' IN
		data_type_typeof(dom)) OR
		(('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.NUMBER_TYPE' IN
		data_type_typeof(dom))
		AND NOT('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.REAL_TYPE' IN
		data_type_typeof(dom))))
	THEN
		RETURN(TRUE);
	ELSE
		RETURN(FALSE);
	END_IF;
END_IF;

IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.NUMERIC_EXPRESSION' IN TYPEOF(expr))
	AND NOT is_int_expr(expr)
THEN
	IF (('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.REAL_TYPE' IN
		data_type_typeof(dom)) OR
		(('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.NUMBER_TYPE' IN
		data_type_typeof(dom))
		AND NOT('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.INT_TYPE' IN
		data_type_typeof(dom))))
	THEN
		RETURN(TRUE);
	ELSE
		RETURN(FALSE);
	END_IF;
END_IF;

IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.BOOLEAN_EXPRESSION' IN TYPEOF(expr))
THEN
	IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.BOOLEAN_TYPE' IN
		data_type_typeof(dom))
	THEN
		RETURN(TRUE);
	ELSE
		RETURN(FALSE);
	END_IF;
END_IF;

IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.STRING_EXPRESSION' IN TYPEOF(expr))
THEN
	IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.STRING_TYPE' IN

		data_type_typeof(dom))
	THEN
		RETURN(TRUE);
	ELSE
		RETURN(FALSE);
	END_IF;
END_IF; -- all simple types have been considered

END_FUNCTION; -- compatible_simple_type_and_expression




FUNCTION collects_columns(t: table_expression):
	LIST OF variable_semantics;

LOCAL
	res, tempo: LIST [0:?] OF variable_semantics := [];
	x: BAG [1:1] OF table_specification;
END_LOCAL;


IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.TABLE_VARIABLE'IN TYPEOF(t))
THEN
	RETURN(t\table_variable.structure);
END_IF;

IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.TABLE_LITERAL' IN TYPEOF(t))
THEN
	x := USEDIN(t\table_literal.the_value,
        'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA'
		+ '.TABLE_SPECIFICATION.TABLE_IDENTIFIER');
	RETURN(x[1].column_meaning);
END_IF;

IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.NATURAL_JOIN_EXPRESSION'
	IN TYPEOF(t))
THEN
	RETURN(
	diff_columns(collects_columns(
		t\natural_join_expression.table_1),
		collects_columns(
		t\natural_join_expression.table_2)));
END_IF;

IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.BINARY_TABLE_EXPRESSION'
	IN TYPEOF(t))
THEN
	RETURN(collects_columns(t\binary_table_expression.operands[1])+
	collects_columns(t\binary_table_expression.operands[2]));
END_IF;

IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.MULTIPLE_ARITY_TABLE_EXPRESSION')
	IN TYPEOF(t) THEN
	REPEAT i:= 1 TO
			SIZEOF(t\multiple_arity_table_expression.operands);
		res := res +
			collects_columns(t\multiple_arity_table_expression
			.operands[i]);
	END_REPEAT;
	RETURN(res);
END_IF;

IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.SELECT_EXPRESSION' IN TYPEOF(t))
THEN
	RETURN(collects_columns(
		t\binary_generic_expression.operands[1]));
END_IF;

IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.PROJECTION_EXPRESSION'

	IN TYPEOF(t))
THEN
	REPEAT i := 1 TO SIZEOF(t\projection_expression.argts_var);
		tempo := tempo +t\projection_expression.argts_var[i];
	END_REPEAT;
	RETURN(tempo);
END_IF;

RETURN([]);

END_FUNCTION; -- collects_columns




FUNCTION diff_columns(l1, l2:LIST [1:?] OF variable_semantics):
	LIST [1:?] OF variable_semantics;

REPEAT i := 1 TO SIZEOF(l2);
	IF NOT(l2[i] IN l1)
	THEN
		l1 := l1 + l2[i];
	END_IF;
END_REPEAT;

RETURN(l1);
END_FUNCTION; -- diff_columns




FUNCTION return_key(t: table_expression):
	SET [1:?] OF variable_semantics;

LOCAL
	res: SET [0:?] OF variable_semantics := [];
	x: BAG[1:1] OF table_specification;
END_LOCAL;

IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.TABLE_VARIABLE'IN TYPEOF(t))
THEN
	RETURN(t\table_variable.its_key);
END_IF;

IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.TABLE_LITERAL' IN TYPEOF(t))
THEN
	x := USEDIN(t\table_literal.the_value,
		'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.'
		+ 'TABLE_SPECIFICATION.TABLE_IDENTIFIER');
	RETURN(x[1]\table_specification.key);
END_IF;

IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.SELECT_EXPRESSION' IN TYPEOF(t))
THEN
	RETURN(return_key(t\binary_generic_expression.operands[1]));
END_IF;

IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.PROJECTION_EXPRESSION'
	IN TYPEOF(t))
THEN
	IF QUERY(col <* t\projection_expression.from_table.the_key | NOT
		(col IN t\projection_expression.argts_var)) <> []
	THEN
		RETURN(list_to_set(t\table_expression.its_columns));
	ELSE
		RETURN(t\projection_expression.from_table.the_key);
	END_IF;
END_IF;

IF (('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.INTERSECT_TABLE_EXPRESSION'
		IN TYPEOF(t))
	OR
	('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.DIFFERENCE_TABLE_EXPRESSION'
		IN TYPEOF(t)))
THEN
	RETURN(return_key(t\binary_table_expression.operands[1]));
END_IF;

IF (('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.UNION_TABLE_EXPRESSION'
		IN TYPEOF(t))
	OR
	('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.NATURAL_JOIN_EXPRESSION'
		IN TYPEOF(t)))
THEN
	RETURN(return_key(t\binary_table_expression.operands[1]) +
	return_key(t\binary_table_expression.operands[2]));
END_IF;

IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.MULTIPLE_ARITY_TABLE_EXPRESSION'
	IN TYPEOF(t))
THEN
	REPEAT i := 1 TO
	SIZEOF(t\multiple_arity_table_expression.operands);
		res := res
		+ return_key(t\multiple_arity_table_expression.operands[i]);
	END_REPEAT;
	RETURN(res);
END_IF;

RETURN([]);

END_FUNCTION; -- return_key




FUNCTION is_SQL_mappable_table_expression(
	arg: table_expression): LOGICAL;

IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.SIMPLE_TABLE_EXPRESSION'
	IN TYPEOF(arg))
THEN
	IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.RDB_TABLE_VARIABLE'
		IN TYPEOF(arg))
	THEN
		RETURN(TRUE);
	END_IF;
	IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.TABLE_LITERAL'
		IN TYPEOF(arg))
	THEN
		IF (SIZEOF(USEDIN(arg\table_literal.the_value,
			'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.TABLE_SPECIFICATION'
			+ '.TABLE_IDENTIFIER')) = 1)
		THEN
			RETURN(('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA'
				+ '.RDB_TABLE_SPECIFICATION')
				IN TYPEOF(USEDIN(arg\table_literal.the_value,
                'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA'
				+ '.TABLE_SPECIFICATION.TABLE_IDENTIFIER')[1]));
		ELSE
			RETURN(UNKNOWN);
		END_IF;
	END_IF;
	RETURN(FALSE); -- table_variable that is not RDB_table_variable
END_IF;

IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.UNARY_TABLE_EXPRESSION'
	IN TYPEOF(arg))
THEN
	RETURN(is_SQL_mappable_table_expression(
		arg\unary_table_expression.operand));
END_IF;

IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.SELECT_EXPRESSION'
	IN TYPEOF(arg))
THEN
	RETURN(is_SQL_mappable_table_expression(
		arg\select_expression.from_table)
		AND is_SQL_mappable(arg\select_expression.condition));
END_IF;

IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.BINARY_TABLE_EXPRESSION'
	IN TYPEOF(arg))
THEN
	RETURN(is_SQL_mappable_table_expression(
		arg\binary_table_expression.operands[1])
		AND Is_SQL_mappable_table_expression(
		arg\binary_table_expression.operands[2]));
END_IF;

IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.MULTIPLE_ARITY_TABLE_EXPRESSION'

	IN TYPEOF(arg))
THEN
	REPEAT i := 1 TO SIZEOF
		(arg\multiple_arity_table_expression.operands);
		IF NOT is_SQL_mappable_table_expression
			(arg\multiple_arity_table_expression.operands[i])
		THEN
			RETURN(FALSE);
		END_IF;
	END_REPEAT;

	RETURN(TRUE);
END_IF;

RETURN(UNKNOWN);

END_FUNCTION; -- is_SQL_mappable_table_expression




FUNCTION compatible_variable_semantics_and_expression(
	sem: variable_semantics; expr: expression): LOGICAL;

LOCAL
	va: SET OF generic_variable;
END_LOCAL;

va := syntax_of(sem);
IF SIZEOF(va) = 0
THEN
	RETURN(UNKNOWN);
ELSE
	REPEAT i := LOINDEX(va) TO HIINDEX(va);
		IF (NOT compatible_variable_and_expression(va[i], expr))
		THEN
			RETURN(FALSE);
		END_IF;
	END_REPEAT;
	RETURN(TRUE);
END_IF;

END_FUNCTION; -- compatible_variable_semantics_and_expression




FUNCTION syntax_of(sem: variable_semantics): SET OF generic_variable;

LOCAL
	env: BAG OF environment;
	vars: SET OF generic_variable;
END_LOCAL;

env := USEDIN(sem,
	'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.ENVIRONMENT.SEMANTICS');

vars := [];

REPEAT i := LOINDEX(env) TO HIINDEX(env);
	vars := vars + env[i].syntactic_representation;
END_REPEAT;

RETURN(vars);

END_FUNCTION; -- syntax_of




FUNCTION compatible_variable_and_expression(va: generic_variable;
	expr: expression): LOGICAL;

IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.NUMERIC_EXPRESSION' IN TYPEOF(expr))
	AND is_int_expr(expr)
THEN
	IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.INT_NUMERIC_VARIABLE'
		IN TYPEOF(va))
	THEN
		RETURN(TRUE);
	ELSE
		RETURN(FALSE);
	END_IF;
END_IF;

IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.NUMERIC_EXPRESSION' IN TYPEOF(expr))

THEN
	IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.REAL_NUMERIC_VARIABLE'
		IN TYPEOF(va))
	THEN
		RETURN(TRUE);
	ELSE
		RETURN(FALSE);
	END_IF;
END_IF;

IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.BOOLEAN_EXPRESSION' IN TYPEOF(expr))
THEN
	IF('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.BOOLEAN_VARIABLE' IN TYPEOF(va))
	THEN
		RETURN(TRUE);
	ELSE
		RETURN(FALSE);
	END_IF;
END_IF;

IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.STRING_EXPRESSION'
	IN TYPEOF(expr))
THEN
	IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.STRING_VARIABLE' IN TYPEOF(va))

	THEN
		RETURN(TRUE);
	ELSE
		RETURN(FALSE);
	END_IF;
END_IF;

-- all simple types have been considered
RETURN(UNKNOWN);

END_FUNCTION; -- compatible_variable_and_expression


FUNCTION same_order_for_properties(
	first, current: LIST [1:?] OF property_value): BOOLEAN;

IF SIZEOF(first) = SIZEOF(current)
THEN ;
ELSE	RETURN(FALSE);
END_IF;

REPEAT i := 1 TO SIZEOF(first);
	IF NOT (first[i].prop_def = current[i].prop_def)
	THEN
		RETURN(FALSE);
	END_IF;

	IF (('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA' +
		'.CONTEXT_DEPENDENT_PROPERTY_VALUE')
		IN TYPEOF(first[i]))
	THEN
		IF NOT(('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA' +
			'.CONTEXT_DEPENDENT_PROPERTY_VALUE')
			IN TYPEOF(current[i]))
		THEN
			RETURN(FALSE);
		END_IF;

		IF NOT same_order_for_properties(
			first[i]\context_dependent_property_value.the_context,
			current[i]\context_dependent_property_value.
			the_context)
		THEN
			RETURN(FALSE);
		END_IF;
	END_IF;

	IF (('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA' +
		'.CONTEXT_DEPENDENT_PROPERTY_VALUE')
		IN TYPEOF(current[i]))
	THEN
		IF NOT(('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA' +
			'.CONTEXT_DEPENDENT_PROPERTY_VALUE')
			IN TYPEOF(first[i]))
		THEN
			RETURN(FALSE);
		END_IF;
	END_IF;

	IF (('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA' +
		'.DIC_CLASS_INSTANCE') IN TYPEOF (first[i].its_value))
	THEN
		IF NOT same_order_for_properties(first[i].its_value.properties,
								current[i].its_value.properties)
		THEN RETURN (FALSE);
		END_IF;
	END_IF;

END_REPEAT;

RETURN(TRUE);

END_FUNCTION; -- same_order_for_properties


FUNCTION all_properties_are_applicable(
	expl: explicit_model_class_extension): LOGICAL;

LOCAL
	inst: dic_class_instance;
	prop_val: property_value;
	res: LOGICAL := TRUE;
END_LOCAL;

REPEAT i := 1 TO SIZEOF(expl.POPULATION);
	inst := expl.POPULATION[i];
	REPEAT j := 1 TO SIZEOF(inst.properties);
		prop_val := inst.properties[j];
		res := res AND applicable_properties(expl\
			content_item.dictionary_definition,
			[prop_val.prop_def]);
	END_REPEAT;
END_REPEAT;

RETURN(res);

END_FUNCTION; -- all_properties_are_applicable



FUNCTION compatible_list_variable_semantics_and_expressions(
	sem: LIST [0:?] OF variable_semantics;
	exprs: LIST [0:?] OF expression): LOGICAL;

LOCAL
	res: LOGICAL;
END_LOCAL;

IF SIZEOF(sem) <> SIZEOF(exprs)
THEN
	RETURN(FALSE);
END_IF;

res := TRUE;

REPEAT i:= 1 TO SIZEOF(sem);
	res := res AND
	compatible_variable_semantics_and_expression(sem[i], exprs[i]);
END_REPEAT;

RETURN(res);

END_FUNCTION; -- compatible_list_variable_semantics_and_expressions




FUNCTION used_variables (arg : generic_expression) : 
			SET OF generic_variable;

LOCAL
	result : SET OF generic_variable := [];
END_LOCAL;

IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.GENERIC_VARIABLE'
	IN TYPEOF (arg) 
THEN 
	RETURN ([arg]);
END_IF;

IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.UNARY_GENERIC_EXPRESSION'
	IN TYPEOF (arg)
THEN 
	RETURN (used_variables (arg\unary_generic_expression.operand));
END_IF;

IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.BINARY_GENERIC_EXPRESSION'
	IN TYPEOF (arg)
THEN 
	RETURN(used_variables(arg\binary_generic_expression.operands[1])
		+ used_variables (arg\binary_generic_expression.operands[2]));
END_IF;

IF
'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.MULTIPLE_ARITY_GENERIC_EXPRESSION'

	IN TYPEOF (arg)
THEN
	REPEAT i := 1 TO 
		SIZEOF(arg\multiple_arity_generic_expression.operands);
		result := result + used_variables(
			arg\multiple_arity_generic_expression.operands[i]);
	END_REPEAT;
	
	RETURN (result);
END_IF;
RETURN ([ ]);      -- in this case the subtype shall not contain
			            -- any variable (see IP1 in generic_expression)
END_FUNCTION; -- used_variables




FUNCTION check_iterator_context(expr: select_expression;
	v: generic_variable): LOGICAL;

IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA' +
	'.COLUMN_TRAVERSAL_VARIABLE_SEMANTICS' IN
	TYPEOF(v.interpretation.semantics))
THEN
	IF (v.interpretation.semantics\
		column_traversal_variable_semantics.ctxt:<>: expr.from_table)
	THEN
		RETURN(FALSE);
	ELSE
		RETURN(TRUE);
	END_IF;
ELSE
	RETURN(UNKNOWN);
END_IF;

END_FUNCTION; -- check_iterator_context




FUNCTION check_iterator_domain_uniqueness(expr: select_expression;
	v: generic_variable): LOGICAL;

LOCAL
	vars: SET OF generic_variable := [];
	res: SET OF generic_variable := [];
END_LOCAL;

IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.'

	+ 'COLUMN_TRAVERSAL_VARIABLE_SEMANTICS' IN
	TYPEOF(v.interpretation.semantics))
THEN
	vars := used_variables(expr.condition);

	REPEAT i := 1 TO SIZEOF(vars);
		IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA' +
			'.COLUMN_TRAVERSAL_VARIABLE_SEMANTICS' IN
			TYPEOF(vars[i].interpretation.semantics))
		THEN
			IF (vars[i].interpretation.semantics\
				column_traversal_variable_semantics.domain
				:=: v.interpretation.semantics\
				column_traversal_variable_semantics.domain)
			THEN
				res := res + vars[i];
			END_IF;
		END_IF;
	END_REPEAT;

	RETURN(SIZEOF(res) = 1);
END_IF;

RETURN(UNKNOWN);

END_FUNCTION; -- check_iterator_domain_uniqueness




FUNCTION same_translations_for_string_values(string_values:
	LIST OF null_or_translatable_string_value): LOGICAL;
LOCAL
	translated_values: SET OF translated_string_value := [];
	not_translated_values: LIST OF string_value := [];
END_LOCAL;

	translated_values := list_to_set(QUERY(val <* string_values |
		'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.TRANSLATED_STRING_VALUE'
		IN TYPEOF(val)));
	not_translated_values := QUERY(val <* string_values |
		'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.STRING_VALUE'

		IN TYPEOF(val));

	IF (SIZEOF(translated_values) <> 0)
	THEN
		IF (SIZEOF(not_translated_values) <> 0)
		THEN
			RETURN(FALSE);
		ELSE
			RETURN(same_translations(translated_values));
		END_IF;
	ELSE
		RETURN(UNKNOWN);
	END_IF;
END_FUNCTION; -- same_translations_for_string_values




FUNCTION compatible_list_variable_semantics_and_columns(
	sem: LIST [0:?] OF variable_semantics;
	col: LIST [0:?] OF column): LOGICAL;

LOCAL
	res: LOGICAL;
END_LOCAL;

IF SIZEOF(sem) <> SIZEOF(col)
THEN
	RETURN(FALSE);
END_IF;

res := TRUE;

REPEAT i:= LOINDEX(col) TO HIINDEX(col);
	res := res AND
		compatible_column_and_variable_semantics(col[i], sem[i]);
END_REPEAT;

RETURN(res);

END_FUNCTION; -- compatible_list_variable_semantics_and_columns




FUNCTION compatible_column_and_variable_semantics(col: column;
	sem: variable_semantics): LOGICAL;

LOCAL
	va: SET OF generic_variable;
END_LOCAL;

va := syntax_of(sem);
IF SIZEOF(va) = 0
THEN
	RETURN(UNKNOWN);
ELSE
	REPEAT i := LOINDEX(va) TO HIINDEX(va);
		IF (NOT compatible_column_and_variable(col, va[i]))
		THEN
			RETURN(FALSE);
		END_IF;
	END_REPEAT;
	RETURN(TRUE);
END_IF;

END_FUNCTION; -- compatible_column_and_variable_semantics




FUNCTION compatible_column_and_variable(col: column;
	v: generic_variable): LOGICAL;



IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.INT_NUMERIC_VARIABLE' IN TYPEOF(v))
THEN
	RETURN(('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.INTEGER_COLUMN'
		IN TYPEOF(col)) OR
		(('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.NUMBER_COLUMN'
		IN TYPEOF(col))
		AND NOT('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.REAL_COLUMN'
		IN TYPEOF(col))));
END_IF;

IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.REAL_NUMERIC_VARIABLE' IN TYPEOF(v))
THEN
	RETURN(('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.REAL_COLUMN'
		IN TYPEOF(col))
		OR (('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.NUMBER_COLUMN'
		IN TYPEOF(col))
		AND NOT('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.INTEGER_COLUMN'
		IN TYPEOF(col))));
END_IF;

IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.BOOLEAN_VARIABLE' IN TYPEOF(v))
THEN
	RETURN('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.BOOLEAN_COLUMN'
	IN TYPEOF(col));
END_IF;

IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.STRING_VARIABLE' IN TYPEOF(v))
THEN
	RETURN('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.STRING_COLUMN'
	IN TYPEOF(col));
END_IF;



IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.ENTITY_INSTANCE_VARIABLE')
	IN TYPEOF(v)
THEN
	RETURN(('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.ENTITY_INSTANCE_COLUMN'
		IN TYPEOF(col))
		AND (v\entity_instance_expression.type_name
<= col\entity_instance_column.type_name));
END_IF;

IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.CLASS_INSTANCE_VARIABLE')
	IN TYPEOF(v)
THEN
	IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.CLASS_INSTANCE_COLUMN'
		IN TYPEOF(col))
	THEN
		RETURN(compatible_class_and_class
			(v\class_instance_expression.expr_type,
			col\class_instance_column.class_ref));
	ELSE
		RETURN(FALSE);
	END_IF;
END_IF;

IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.LEVEL_SPEC_VARIABLE')
	IN TYPEOF(v) THEN
	IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.LEVEL_SPEC_COLUMN'

		IN TYPEOF(col))
	THEN
		IF (list_to_set(v\level_spec_expression.levels)
			= list_to_set(col\level_spec_column.levels))
		THEN
			IF (('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA'
				+'.INT_LEVEL_SPEC_VARIABLE' IN TYPEOF(v))
				AND NOT('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA' +
				'.INT_LEVEL_SPEC_COLUMN' IN TYPEOF(col)))
			THEN
				RETURN(FALSE);
			END_IF;
			IF (('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA'
				+'.REAL_LEVEL_SPEC_VARIABLE' IN TYPEOF(v))
				AND NOT('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA' +
				'.REAL_LEVEL_SPEC_COLUMN' IN TYPEOF(col)))
			THEN
				RETURN(FALSE);
			END_IF;
			RETURN(TRUE);
		ELSE
			RETURN(FALSE);
		END_IF;
	ELSE
		RETURN(FALSE);
	END_IF;
END_IF;

RETURN(FALSE);

END_FUNCTION; -- compatible_column_and_variable




FUNCTION no_null_values_in_key_columns(
	the_columns: LIST[1:?] OF variable_semantics;
	the_key: SET[1:?] OF variable_semantics;
	the_values: LIST[1:?] OF column): BOOLEAN;
LOCAL
	sem: variable_semantics;
	result: BOOLEAN := TRUE;
END_LOCAL;

REPEAT i := 1 TO SIZEOF(the_columns);
	sem := the_columns[i];
	IF(sem IN the_key) THEN
		REPEAT j := 1 TO SIZEOF(the_values[i].values);
			IF('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA' +
				'.NULL_VALUE' IN TYPEOF(the_values[i].values[j]))
			THEN
				result := FALSE;
			END_IF;
		END_REPEAT;
	END_IF;
END_REPEAT;

RETURN(result);

END_FUNCTION; -- no_null_values_in_key_columns




FUNCTION check_property_semantics(sem: property_semantics): LOGICAL;

LOCAL
	res: LOGICAL;
END_LOCAL;

IF (EXISTS(sem.its_own_property)) AND
	NOT(data_type_typeof(sem.the_property) = [])
THEN
	res := ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.CLASS_INSTANCE_TYPE'

		IN data_type_typeof(sem.the_property))
		AND applicable_properties(data_type_class_of(
		sem.the_property)[1], [sem.its_own_property.the_property]);

	RETURN(res);
ELSE
	RETURN(UNKNOWN);
END_IF;

END_FUNCTION; -- check_property_semantics




FUNCTION BSU_of_property_semantics(v: property_semantics_or_path):
	property_BSU;

LOCAL
	prop: property_BSU;
END_LOCAL;

prop := v.the_property;

IF EXISTS(v.its_own_property)
THEN
	RETURN(BSU_of_property_semantics(v.its_own_property));
ELSE
	RETURN(prop);
END_IF;

END_FUNCTION; -- BSU_of_property_semantics




FUNCTION collects_variables(v_sem: AGGREGATE OF variable_semantics):
	SET OF generic_variable;

LOCAL
	l: SET OF generic_variable := [];
END_LOCAL;

REPEAT i := 1 TO SIZEOF(v_sem);
	l := l + syntax_of(v_sem[i]);
END_REPEAT;

RETURN(l);

END_FUNCTION; -- collects_variables




FUNCTION used_tables_in_domain(arg: domain_restriction):
	SET OF table_identification;

LOCAL
	result: SET OF table_identification := [];
END_LOCAL;

REPEAT i := 1 TO SIZEOF(arg.domains);
	IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.BOOLEAN_EXPRESSION'
		IN TYPEOF(arg.domains[i].guard))
	THEN
		result := result + used_table_literals
			(arg.domains[i].guard);
	END_IF;

	IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.TABLE_DEFINED_DOMAIN'
		IN TYPEOF(arg.domains[i].domain))
	THEN
		result := result + used_table_literals
			(arg.domains[i].domain\table_defined_domain.from_table);
	END_IF;

	IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.PREDICATE_DEFINED_DOMAIN'
		IN TYPEOF(arg.domains[i].domain))
	THEN
		result := result + used_table_literals(
		arg.domains[i].domain\predicate_defined_domain.constraint);
	END_IF;

	IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA'
		+'.LIBRARY_EXPRESSION_DEFINED_VALUE' IN TYPEOF(
		arg.domains[i].domain))
	THEN
		result := result + used_table_literals(
			arg.domains[i].domain\library_expression_defined_value
			.its_value);
	END_IF;

	IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.TABLE_DEFINED_VALUE'

		IN TYPEOF(arg.domains[i].domain))
	THEN
		result := result + used_table_literals
			(arg.domains[i].domain\table_defined_value.from_table);
	END_IF;
END_REPEAT;

RETURN(result);

END_FUNCTION; -- used_tables_in_domain




FUNCTION used_table_literals(arg: generic_expression):
	SET OF table_identification;

LOCAL
	result: SET OF table_identification := [];
END_LOCAL;

IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.TABLE_LITERAL' IN TYPEOF(arg))
THEN
	RETURN([arg\table_literal.the_value]);
END_IF;

IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.UNARY_GENERIC_EXPRESSION')
	IN TYPEOF(arg)
THEN
	RETURN(used_table_literals(
		arg\unary_generic_expression.operand));
END_IF;

IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.BINARY_GENERIC_EXPRESSION'
	IN TYPEOF(arg))
THEN
	RETURN(used_table_literals(arg\binary_generic_expression
		.operands[1]) + used_table_literals(
		arg\binary_generic_expression.operands[2]));
END_IF;

IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.' +

	'MULTIPLE_ARITY_GENERIC_EXPRESSION' IN TYPEOF(arg))
THEN
	REPEAT i := 1 TO
		SIZEOF(arg\multiple_arity_generic_expression.operands);
		result := result + used_table_literals(
			arg\multiple_arity_generic_expression.operands[i]);
	END_REPEAT;
	RETURN(result);
END_IF;

RETURN([]);

END_FUNCTION; -- used_table_literals




FUNCTION variables_belong_to_assumes(gsd: guarded_simple_domain):
	LOGICAL;

IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.BOOLEAN_EXPRESSION')

	IN TYPEOF(gsd)
THEN
	RETURN(collects_var_sem(used_variables(gsd.guard))
		<= gsd.item_of.assumes);
ELSE
	RETURN(TRUE);
END_IF;

END_FUNCTION; -- variables_belong_to_assumes




FUNCTION collects_var_sem(va: AGGREGATE OF generic_variable):
	SET OF variable_semantics;

LOCAL
	l: SET OF variable_semantics := [];
END_LOCAL;

REPEAT i := 1 TO SIZEOF(va);
	l := l + semantics_of(va[i]);
END_REPEAT;

RETURN(l);

END_FUNCTION; -- collects_var_sem




FUNCTION semantics_of(vars: generic_variable): variable_semantics;

RETURN(vars.interpretation.semantics);

END_FUNCTION; -- semantics_of




FUNCTION compatible_variable_and_library_expression(
	va: library_variable; expr: library_expression): LOGICAL;


IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.LEVEL_SPEC_EXPRESSION'
	IN TYPEOF(expr))
THEN
	IF (('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.LEVEL_SPEC_VARIABLE'
		IN TYPEOF(va))
		AND ((list_to_set(va\level_spec_expression.levels))
		= list_to_set(expr\level_spec_expression.levels))
		AND (TYPEOF(va\level_spec_expression.value_type)
		<= TYPEOF(expr\level_spec_expression.value_type)))
	THEN
		RETURN(TRUE);
	ELSE
		RETURN(FALSE);
	END_IF;
END_IF;



IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.ENTITY_INSTANCE_EXPRESSION'
	IN TYPEOF(expr))
THEN
	IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.ENTITY_INSTANCE_VARIABLE'
		IN TYPEOF(va))
		AND (va\entity_instance_expression.type_name
		<= expr\entity_instance_expression.type_name )
	THEN
		RETURN(TRUE);
	ELSE
		RETURN(FALSE);
	END_IF;
END_IF;



IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.CLASS_INSTANCE_EXPRESSION'
	IN TYPEOF(expr))
THEN
	IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.CLASS_INSTANCE_VARIABLE'

		IN TYPEOF(va))
	THEN
		RETURN(compatible_class_and_class(
			va\class_instance_expression.expr_type,
			expr\class_instance_expression.expr_type));
	ELSE
		RETURN(FALSE);
	END_IF;
END_IF;


RETURN(compatible_variable_and_expression(va, expr));

END_FUNCTION; -- compatible_variable_and_library_expression




FUNCTION compatible_types(p1: property_or_data_type_BSU;
	p2: property_or_data_type_BSU): LOGICAL;

LOCAL
	p1_domain, p2_domain: data_type;
END_LOCAL;

IF (NOT EXISTS(p1)) OR (NOT EXISTS(p2))
THEN
	RETURN(UNKNOWN); -- p1 or p2 indeterminate
END_IF;



IF p1 = p2
THEN
	RETURN(TRUE);
END_IF;



IF ((TYPEOF(p1) = TYPEOF(p2))
	AND (p1\basic_semantic_unit.code = p2.code)
	AND (p1.name_scope\basic_semantic_unit.code =
		p2.name_scope\basic_semantic_unit.code)
	AND (p1\basic_semantic_unit.version >=
		p2\basic_semantic_unit.version))
THEN
	RETURN(TRUE);
END_IF;



IF (SIZEOF(p1\basic_semantic_unit.definition) = 0)
	OR (SIZEOF(p2\basic_semantic_unit.definition) = 0)
THEN
	RETURN(UNKNOWN);
ELSE
	IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.PROPERTY_BSU'
		IN TYPEOF(p1))
	THEN
		p1_domain := p1.definition [1]\property_DET.domain;
	ELSE
		p1_domain := p1.definition[1]\data_type_element
			.type_definition;
	END_IF;

	IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.PROPERTY_BSU'
		IN TYPEOF(p2))
	THEN
		p2_domain := p2.definition [1]\property_DET.domain;
	ELSE
		p2_domain := p2.definition[1]\data_type_element
			.type_definition;
	END_IF;
END_IF;



IF p1_domain = p2_domain
THEN
	RETURN(TRUE);
END_IF;



IF (NOT(SIZEOF(data_type_typeof(p1)) = 0))
	AND (data_type_typeof(p1)<= data_type_typeof(p2))
	AND (NOT('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.COMPLEX_TYPE' IN
	data_type_typeof(p2)))
THEN
	RETURN(TRUE);
END_IF;



IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.CLASS_INSTANCE_TYPE' IN
	data_type_typeof(p1))
	AND ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.CLASS_INSTANCE_TYPE' IN
	data_type_typeof(p2))
THEN
	RETURN(compatible_subclass(data_type_class_of(p1)[1],
		data_type_class_of(p2)[1]));
END_IF;



IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.ENTITY_INSTANCE_TYPE' IN
	data_type_typeof(p1))
	AND ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.ENTITY_INSTANCE_TYPE'
	IN data_type_typeof(p2))
THEN
	IF ((data_type_type_name(p1) <= data_type_type_name(p2))
		AND (data_type_type_name(p1) <> []))
	THEN
		RETURN(TRUE);
	ELSE
		RETURN(FALSE);
	END_IF;
END_IF;



IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.LEVEL_TYPE' IN
	data_type_typeof(p1))
	AND ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.LEVEL_TYPE' IN

	data_type_typeof(p2))
THEN
	IF (data_type_level_spec(p1) = data_type_level_spec(p2))
		AND (data_type_level_value_typeof(p1) <> [])
		AND (data_type_level_value_typeof(p1)
		<= data_type_level_value_typeof(p2))
	THEN
		RETURN(TRUE);
	ELSE
		RETURN(FALSE);
	END_IF;
END_IF;



IF ((data_type_typeof(p1) = []) OR (data_type_typeof(p2) = []))
THEN
	RETURN(UNKNOWN);
ELSE
	RETURN(FALSE);
END_IF;

END_FUNCTION; -- compatible_types




FUNCTION compatible_subclass(c1, c2: class_BSU): LOGICAL;

IF (NOT EXISTS(c1)) OR (NOT EXISTS(c2))
THEN
	RETURN(UNKNOWN); -- c1 or c2 indeterminate
END_IF;

IF c1 = c2
THEN
	RETURN(TRUE);
END_IF;

IF ((c1.code = c2.code) AND (c1.version >= c2.version)
	AND (c1.defined_by.code = c2.defined_by.code))
THEN
	RETURN(TRUE);
END_IF;

IF SIZEOF(c2.definition) = 0
THEN
	RETURN(UNKNOWN);
ELSE
	IF EXISTS(c2.definition[1]\class.its_superclass)
	THEN
		RETURN(compatible_subclass(c1, c2.definition[1]
			\class.its_superclass));
	ELSE
		RETURN(FALSE);
	END_IF;
END_IF;

END_FUNCTION; -- compatible_subclass




FUNCTION visible_documents(cl: class_BSU;
	doc: AGGREGATE OF document_BSU): LOGICAL;

IF NOT EXISTS(cl)
THEN
	RETURN(UNKNOWN);
END_IF;

REPEAT i := SIZEOF(doc) TO 1 BY -1;
	IF doc[i].name_scope = cl
	THEN
		doc := doc - doc[i];
	END_IF;
END_REPEAT;

IF SIZEOF(doc) = 0
THEN
	RETURN(TRUE);
END_IF;

IF SIZEOF(cl.definition) = 0
THEN
	RETURN(UNKNOWN);
END_IF;

IF EXISTS(cl.definition[1]\class.its_superclass)
THEN
	RETURN(visible_documents(cl.definition[1]
		\class.its_superclass, doc));
ELSE
	RETURN(FALSE);
END_IF;

END_FUNCTION; -- visible_documents




FUNCTION applicable_properties_for_applicable_tables(
	rel: class_table_relationship): LOGICAL;
LOCAL
	table: table_bsu;
	cl: class_bsu;
	props: LIST OF property_bsu := [];
	res: LOGICAL := TRUE;
END_LOCAL;

IF QUERY(table <* rel.related_tokens
	| SIZEOF(table.definition) = 0) <> []
THEN
	RETURN(UNKNOWN);
END_IF;

REPEAT i := 1 TO SIZEOF(rel.related_tokens);
	table := rel.related_tokens[i];
	cl := rel\class_BSU_relationship.relating_class.identified_by;
	props := get_property_BSU_from_property_semantics(
		table\basic_semantic_unit.definition[1]
		\table_element.column_meaning);
	res := res AND applicable_properties(cl, list_to_set(props));
END_REPEAT;

RETURN(res);

END_FUNCTION; -- visible_properties_for_visible_tables




FUNCTION get_property_BSU_from_property_semantics(
	l: AGGREGATE OF variable_semantics): LIST[1:?] OF property_BSU;

LOCAL
	res: LIST[0:?] OF property_BSU := [];
END_LOCAL;

REPEAT i := 1 TO SIZEOF(l);
	res := res + l[i]\property_semantics.the_property;
END_REPEAT;

RETURN(res);

END_FUNCTION; -- get_property_BSU_from_property_semantics




FUNCTION visible_tables(cl: class_BSU;
	tab: AGGREGATE OF table_BSU): LOGICAL;

IF NOT EXISTS(cl)
THEN
	RETURN(UNKNOWN);
END_IF;

REPEAT i := SIZEOF(tab) TO 1 BY -1;
	IF tab[i].name_scope = cl
	THEN
		tab := tab - tab[i];
	END_IF;
END_REPEAT;

IF SIZEOF(tab) = 0
THEN
	RETURN(TRUE);
END_IF;

IF SIZEOF(cl.definition) = 0
THEN
	RETURN(UNKNOWN);
END_IF;

IF EXISTS(cl.definition[1]\class.its_superclass)
THEN
	RETURN(visible_tables(cl.definition[1]
		\class.its_superclass, tab));
ELSE
	RETURN(FALSE);
END_IF;

END_FUNCTION; -- visible_tables




FUNCTION check_is_case_of_referenced_classes_definition(
	cl: item_class_case_of): BOOLEAN;
LOCAL
	class_def_ok: BOOLEAN := TRUE;
	done: BOOLEAN := FALSE;
END_LOCAL;

REPEAT i := 1 TO SIZEOF(cl.is_case_of);
	IF (SIZEOF(cl.is_case_of[i].definition) = 1)
	THEN
		IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA' +
			'.COMPONENT_CLASS_CASE_OF' IN TYPEOF(cl))
		THEN
			IF (NOT('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA' +
				'.COMPONENT_CLASS'
				IN TYPEOF(cl.is_case_of[i].definition[1])))
			THEN
				class_def_ok := FALSE;
			END_IF;
			done := TRUE;
		END_IF;
		IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA' +
			'.FEATURE_CLASS_CASE_OF' IN TYPEOF(cl))
		THEN
			IF (NOT('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA' +
				'.FEATURE_CLASS'
				IN TYPEOF(cl.is_case_of[i].definition[1])))
			THEN
				class_def_ok := FALSE;
			END_IF;
			done := TRUE;
		END_IF;
		IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA' +
			'.MATERIAL_CLASS_CASE_OF' IN TYPEOF(cl))
		THEN
			IF (NOT('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA' +
				'.MATERIAL_CLASS'
				IN TYPEOF(cl.is_case_of[i].definition[1])))
			THEN
				class_def_ok := FALSE;
			END_IF;
			done := TRUE;
		END_IF;
		IF (('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA' +
			'.ITEM_CLASS_CASE_OF' IN TYPEOF(cl))
			AND (NOT done))
		THEN
			IF (NOT('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA' +
				'.ITEM_CLASS'
				IN TYPEOF(cl.is_case_of[i].definition[1])))
			THEN
				class_def_ok := FALSE;
			END_IF;
		END_IF;

		done := FALSE;
	END_IF;
END_REPEAT;

RETURN(class_def_ok);

END_FUNCTION; -- check_is_case_of_referenced_classes_definition




FUNCTION prefix_ordered_class_list(classes: LIST[2:?] OF class_BSU):
	BOOLEAN;

LOCAL
	related_token: class_related_BSU;	-- items associated with
		-- a class through a class_BSU_relationship
END_LOCAL;

REPEAT i := 1 TO SIZEOF(classes);

	IF SIZEOF(classes[i].definition) = 1
	THEN

		IF (EXISTS(classes[i].definition[1]\class.its_superclass))
			AND (NOT((classes[i].definition[1]\class.its_superclass)
			IN (makes_sub_list(classes, 1, i - 1))))
		THEN
			RETURN(FALSE);
		END_IF;

		IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA'+
			'.A_PRIORI_SEMANTIC_RELATIONSHIP'
			IN TYPEOF(classes[i].definition[1]))
		THEN
			IF (QUERY(x <* classes[i].definition[1]
			\a_priori_semantic_relationship.
			referenced_classes | NOT(x IN makes_sub_list(
			classes, 1, i - 1))) <> [])
			THEN
				RETURN(FALSE);
			END_IF;
		END_IF;

		IF NOT(SIZEOF(classes[i].definition[1]\class.described_by)
			= 0)
		THEN
			IF (makes_reference_outside(classes[i].definition[1]
				\class.described_by, makes_sub_list(
				classes, 1, i)))
			THEN
				RETURN(FALSE);
			END_IF;
		END_IF;

		IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA'+
			'.A_PRIORI_SEMANTIC_RELATIONSHIP'
			IN TYPEOF(classes[i].definition[1]))
		THEN
			IF makes_reference_outside(classes[i].definition[1]\
			a_priori_semantic_relationship.referenced_properties,
			makes_sub_list(classes, 1, i - 1))
			THEN
				RETURN(FALSE);
			END_IF;
		END_IF;

		IF NOT(SIZEOF(classes[i].definition[1]\class.defined_types)
			= 0)
		THEN
			IF makes_reference_outside(classes[i].definition[1]\
				class.defined_types, makes_sub_list
				(classes, 1, i))
			THEN
				RETURN(FALSE);
			END_IF;
		END_IF;

		IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA'+
			'.A_PRIORI_SEMANTIC_RELATIONSHIP'
			IN TYPEOF(classes[i].definition[1]))
		THEN
			IF makes_reference_outside(classes[i].definition[1]\
			a_priori_semantic_relationship.referenced_data_types,
			makes_sub_list(classes, 1, i - 1))
			THEN
				RETURN(FALSE);
			END_IF;
		END_IF;

		IF NOT(SIZEOF(classes[i].definition[1]\
			class.associated_items) = 0)
		THEN
			REPEAT j := 1 TO SIZEOF(classes[i].definition[1]
			\class.associated_items);
				REPEAT k := 1 TO SIZEOF(classes[i].definition[1]
				\class.associated_items[j]
				\class_BSU_relationship.related_tokens);

					related_token := classes[i].definition[1]
						\class.associated_items[j]
						\class_BSU_relationship.related_tokens[k];

					IF (('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA'+
						'.TABLE_BSU') IN (TYPEOF(related_token)))
						AND NOT(related_token\table_BSU.name_scope
						IN makes_sub_list(classes, 1, i))
					THEN
						RETURN(FALSE);
					END_IF;

					IF (('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA'+
						'.DOCUMENT_BSU')
						IN (TYPEOF(related_token)))
						AND NOT(related_token\document_BSU
						.name_scope IN makes_sub_list
						(classes, 1, i))
					THEN
						RETURN(FALSE);
					END_IF;
				END_REPEAT;
			END_REPEAT;
		END_IF;
	END_IF;
END_REPEAT;

RETURN(TRUE);
END_FUNCTION; -- prefix_ordered_class_list




FUNCTION makes_sub_list(cla: LIST [1:?] OF class_BSU;
	i, j: INTEGER): LIST [1:?] OF class_BSU;

LOCAL
	c: LIST [0:?] OF class_BSU := [];
END_LOCAL;

REPEAT k := i TO j;
	c := c + cla[k];
END_REPEAT;

RETURN(c);

END_FUNCTION; -- makes_sub_list




FUNCTION makes_reference_outside (
	p: AGGREGATE OF property_or_data_type_BSU;
	l: LIST[1:?] OF class_BSU): BOOLEAN;

LOCAL
	bool: BOOLEAN := FALSE;
	temp: SET[0:1] OF class_BSU := [];
END_LOCAL;

REPEAT j := 1 TO SIZEOF(p);
	IF ((('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.PROPERTY_BSU'
		IN TYPEOF(p[j]))
		AND (NOT(p[j]\property_bsu.name_scope IN l)))
		OR
		(('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.DATA_TYPE_BSU'
		IN TYPEOF(p[j]))
		AND (NOT(p[j]\data_type_bsu.name_scope IN l))))
	THEN
		bool := TRUE;
		RETURN(bool);
	END_IF;

	IF ((('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.PROPERTY_BSU'
		IN TYPEOF(p[j]))
		AND (NOT(SIZEOF(p[j]\basic_semantic_unit.definition) = 0)))
		OR
		(('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.DATA_TYPE_BSU'
		IN TYPEOF(p[j]))
		AND (NOT(SIZEOF(p[j]\basic_semantic_unit.definition) = 0))))
	THEN
		IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.CLASS_INSTANCE_TYPE'

			IN data_type_typeof(p[j]))
		THEN
			temp := data_type_class_of(p[j]);
			IF NOT(temp[1] IN l)
			THEN
				bool := bool OR TRUE ;
			ELSE
				bool := bool OR FALSE;
			END_IF;
		END_IF;

		IF SIZEOF(data_type_named_type(p[j])) = 1
		THEN
			bool := bool OR makes_reference_outside
				(data_type_named_type(p[j]), l);
		END_IF;
	END_IF;
END_REPEAT;

RETURN(bool);

END_FUNCTION; -- makes_reference_outside




FUNCTION data_type_named_type(type_spec: property_or_data_type_BSU):
	SET[0:1] OF data_type_BSU;

LOCAL
	res: BOOLEAN := FALSE;
	s: SET[0:1] OF data_type_BSU := [];
	x: data_type;
END_LOCAL;

IF NOT EXISTS(type_spec)
THEN
	RETURN([]); -- type_spec is indeterminate
END_IF;

IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.PROPERTY_BSU' IN
	TYPEOF(type_spec))
THEN
	IF NOT(SIZEOF(type_spec.definition) = 0)
	THEN
		x := type_spec.definition[1]\property_DET.domain;
		res := TRUE;
	END_IF;
ELSE
	IF NOT(SIZEOF(type_spec.definition) = 0)
	THEN
		x := type_spec.definition[1]\data_type_element
			.type_definition;
		res := TRUE;
	END_IF;
END_IF;

IF res
THEN
	IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.NAMED_TYPE'

		IN TYPEOF(x))
	THEN
		s := s + x\named_type.referred_type;
	END_IF;
END_IF;

RETURN(s);

END_FUNCTION; -- data_type_named_type




FUNCTION superclass_of_item_is_item(cl: item_class): LOGICAL;

IF NOT EXISTS(cl\class.its_superclass)
THEN
	RETURN(TRUE);
END_IF;

IF SIZEOF(cl\class.its_superclass.definition) = 0
THEN
	RETURN(UNKNOWN);
END_IF;

RETURN(('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.ITEM_CLASS')

	IN TYPEOF(cl\class.its_superclass.definition[1]));

END_FUNCTION; -- superclass_of_item_is_item




FUNCTION simple_type_data_type(type_spec: property_or_data_type_BSU):
	LOGICAL;

IF NOT EXISTS(type_spec)
THEN
	RETURN(UNKNOWN); -- type_spec is indeterminate
END_IF;

IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.SIMPLE_TYPE' IN
	data_type_typeof(type_spec))
THEN
	RETURN(TRUE);
END_IF;

IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.COMPLEX_TYPE' IN

	data_type_typeof(type_spec))
THEN
	RETURN(FALSE);
END_IF;

RETURN(UNKNOWN);

END_FUNCTION; -- simple_type_data_type




FUNCTION compatible_content_and_specification(
	tab: table_content): LOGICAL;

IF SIZEOF(tab\content_item.dictionary_definition.definition) = 0
THEN
	RETURN(UNKNOWN);
END_IF;

RETURN(compatible_list_library_types_and_columns(
	get_property_BSU_from_property_semantics(
	tab\content_item.dictionary_definition.definition[1]\
	table_specification.column_meaning),
	tab\table_extension.content));

END_FUNCTION; -- compatible_content_and_specification




FUNCTION compatible_list_library_types_and_columns(
	dom: LIST [0:?] OF property_or_data_type_BSU;
	col: LIST [0:?] OF column): LOGICAL;

LOCAL
	res: LOGICAL := TRUE;
	set_string: SET OF STRING := [];
	set_integer: SET OF INTEGER := [];
	code_type: non_quantitative_code_type;
	int_type: non_quantitative_int_type;
END_LOCAL;

IF SIZEOF(dom) <> SIZEOF(col)
THEN
	RETURN(FALSE);
END_IF;

REPEAT i := LOINDEX(col) TO HIINDEX(col);
	IF data_type_typeof(dom[i]) = []
	THEN 
		res := UNKNOWN;
	ELSE
		IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.INTEGER_COLUMN'
			IN TYPEOF(col[i]))
		THEN
			IF ((('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA' +
				'.NON_QUANTITATIVE_INT_TYPE') IN
				data_type_typeof(dom[i]))
				AND (SIZEOF(data_type_non_quantitative_int_type(
				dom[i])) = 1))
			THEN
				set_integer := [];
				int_type := data_type_non_quantitative_int_type(
					dom[i])[1];
				REPEAT j :=1 TO SIZEOF(int_type.domain.its_values);
					set_integer := set_integer
						+ int_type.domain.its_values[j]
						.value_code;
				END_REPEAT;
				REPEAT j := 1 TO SIZEOF(col[i].values);
					IF (('INTEGER' IN TYPEOF(col[i].values[j]))
						AND NOT (col[i].values[j] IN set_integer))
					THEN
						RETURN (FALSE);
					END_IF;
				END_REPEAT;
			ELSE
				IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.INT_TYPE'
					IN data_type_typeof(dom[i]))
					OR (('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA' +
					'.NUMBER_TYPE' IN data_type_typeof(dom[i]))
					AND NOT('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA'
					+ '.REAL_TYPE' IN data_type_typeof(dom[i])))
				THEN
					;
				ELSE
					RETURN(FALSE);
				END_IF;
			END_IF;
		END_IF;

		IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.REAL_COLUMN'
			IN TYPEOF(col[i]))
		THEN
			IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.REAL_TYPE'
				IN data_type_typeof(dom[i]))
				OR (('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA' +
				'.NUMBER_TYPE' IN data_type_typeof(dom[i]))
				AND NOT('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA' +
				'.INT_TYPE' IN data_type_typeof(dom[i])))
			THEN
				;
			ELSE
				RETURN(FALSE);
			END_IF;
		END_IF;

		IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.BOOLEAN_COLUMN'
			IN TYPEOF(col[i]))
		THEN
			IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.BOOLEAN_TYPE'
				IN data_type_typeof(dom[i]))
			THEN
				;
			ELSE
				RETURN(FALSE);
			END_IF;
		END_IF;

		IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.STRING_COLUMN'
			IN TYPEOF(col[i]))
		THEN
			IF ((('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA' +
				'.NON_QUANTITATIVE_CODE_TYPE') IN
				data_type_typeof(dom[i]))
				AND (SIZEOF(data_type_non_quantitative_code_type(
				dom[i])) = 1))
			THEN
				set_string := [];
				code_type := data_type_non_quantitative_code_type(
					dom[i])[1];
				REPEAT j:=1 TO SIZEOF(code_type.domain.its_values);
					set_string := set_string
						+ code_type.domain.its_values[j]
						.value_code;
				END_REPEAT;
				REPEAT j := 1 TO SIZEOF(col[i].values);
					IF ((('STRING' IN TYPEOF(col[i].values[j]))
						AND NOT (col[i].values[j] IN set_string))
						OR ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA'
						+ '.TRANSLATED_STRING_VALUE' IN
						TYPEOF(col[i].values[j])))
					THEN
						RETURN (FALSE);
					END_IF;
				END_REPEAT;
			ELSE
				IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA' +
					'.STRING_TYPE' IN data_type_typeof(dom[i]))
				THEN
					;
				ELSE
					RETURN(FALSE);
				END_IF;
			END_IF;
		END_IF;

		IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.ENTITY_INSTANCE_COLUMN'
			IN TYPEOF(col[i]))
		THEN
			IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA' +
				'.ENTITY_INSTANCE_TYPE' IN
				data_type_typeof(dom[i]))
				AND (data_type_type_name(dom[i]) <= col[i]\
				entity_instance_column.type_name)
				
			THEN
				;
			ELSE
				RETURN(FALSE);
			END_IF;
		END_IF;

		IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.CLASS_INSTANCE_COLUMN'
			IN TYPEOF(col[i]))
		THEN
			IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA' +
				'.CLASS_INSTANCE_TYPE' IN data_type_typeof(dom[i]))
				AND (compatible_subclass(
				data_type_class_of(dom[i])[1],
				col[i]\class_instance_column.class_ref))
			THEN
				;
			ELSE
				RETURN(FALSE);
			END_IF;
		END_IF;

		IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.LEVEL_SPEC_COLUMN'
			IN TYPEOF(col[i]))
		THEN
			IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.LEVEL_TYPE'

				IN data_type_typeof(dom[i]))
			THEN
			
				REPEAT j := 1 TO SIZEOF(col[i].values);
					IF NOT(compatible_level_type_and_instance(
						data_type_level_spec(dom[i]),
						data_type_level_value_typeof(dom[i]),
						col[i].values[j]))
					THEN
						RETURN(FALSE);
					END_IF;
				END_REPEAT;
			ELSE
				RETURN(FALSE);
			END_IF;
		END_IF;
	END_IF;
END_REPEAT;

RETURN(res);

END_FUNCTION; -- compatible_list_library_types_and_columns




FUNCTION data_type_non_quantitative_int_type(
	type_spec: property_or_data_type_BSU):
	SET [0:1] OF non_quantitative_int_type;
LOCAL
	res: BOOLEAN := FALSE;
	s: SET [0:1] OF non_quantitative_int_type := [];
	x: data_type;
END_LOCAL;

IF NOT EXISTS(type_spec)
THEN
	RETURN([]); -- type_spec is indeterminate
END_IF;

IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.PROPERTY_BSU' IN
	TYPEOF(type_spec))
THEN
	IF NOT(SIZEOF(type_spec.definition) = 0)
	THEN
		x := type_spec.definition[1]\property_DET.domain;
		res := TRUE;
	END_IF;
ELSE
	IF NOT(SIZEOF(type_spec.definition) = 0)
	THEN
		x := type_spec.definition[1]\
		data_type_element.type_definition;
		res := TRUE;
	END_IF;
END_IF;

IF res
THEN
	IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA'+
		'.NON_QUANTITATIVE_INT_TYPE') IN TYPEOF(x)
	THEN
		s := s + x;
		RETURN(s);
	END_IF;

	IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.NAMED_TYPE')

		IN TYPEOF(x)
	THEN
		s := data_type_non_quantitative_int_type(
			x\named_type.referred_type);
		RETURN(s);
	END_IF;
END_IF;

RETURN([]);

END_FUNCTION; -- data_type_non_quantitative_int_type




FUNCTION data_type_non_quantitative_code_type(
	type_spec: property_or_data_type_BSU):
	SET [0:1] OF non_quantitative_code_type;
LOCAL
	res: BOOLEAN := FALSE;
	s: SET [0:1] OF non_quantitative_code_type := [];
	x: data_type;
END_LOCAL;

IF NOT EXISTS(type_spec)
THEN
	RETURN([]); -- type_spec is indeterminate
END_IF;

IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.PROPERTY_BSU' IN
	TYPEOF(type_spec))
THEN
	IF NOT(SIZEOF(type_spec.definition) = 0)
	THEN
		x := type_spec.definition[1]\property_DET.domain;
		res := TRUE;
	END_IF;
ELSE
	IF NOT(SIZEOF(type_spec.definition) = 0)
	THEN
		x := type_spec.definition[1]\
		data_type_element.type_definition;
		res := TRUE;
	END_IF;
END_IF;

IF res
THEN
	IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA'+
		'.NON_QUANTITATIVE_CODE_TYPE') IN TYPEOF(x)
	THEN
		s := s + x;
		RETURN(s);
	END_IF;

	IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.NAMED_TYPE')

		IN TYPEOF(x)
	THEN
		s := data_type_non_quantitative_code_type(
			x\named_type.referred_type);
		RETURN(s);
	END_IF;
END_IF;

RETURN([]);

END_FUNCTION; -- data_type_non_quantitative_code_type




FUNCTION visible_properties(cl: class_BSU;
	prop: AGGREGATE OF property_BSU): LOGICAL;

LOCAL
	ok: BOOLEAN := TRUE;
END_LOCAL;

IF NOT EXISTS(cl)
THEN
	RETURN(UNKNOWN);
END_IF;

REPEAT i := 1 TO SIZEOF(prop);
	IF NOT(prop[i] IN compute_known_visible_properties(cl))
		THEN ok := FALSE;
	END_IF;
END_REPEAT;

IF NOT(ok) AND NOT(all_class_descriptions_reachable(cl))
	THEN RETURN(UNKNOWN);
END_IF;

IF NOT(ok) AND all_class_descriptions_reachable(cl)
	THEN RETURN(FALSE);
END_IF;

RETURN(TRUE);

END_FUNCTION; -- visible_properties


FUNCTION same_string_values_translations_for_class_extension(
	class_ext: explicit_model_class_extension): LOGICAL;
LOCAL
	comp: SET OF translated_string_value := [];
	translated_property_values: LIST OF property_value := [];
END_LOCAL;

	REPEAT i := 1 TO SIZEOF(class_ext.POPULATION);
		translated_property_values := QUERY(prop_val <*
			class_ext.POPULATION[i].properties |
			'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.' +
			'TRANSLATED_STRING_VALUE' IN
			TYPEOF(prop_val.its_value));
		IF (SIZEOF(translated_property_values) <> 0)
		THEN
			comp := comp + translated_property_values[1].its_value;
		END_IF;
	END_REPEAT;

	RETURN(same_translations(comp));

END_FUNCTION; -- same_string_values_translations_for_class_extension


FUNCTION presentation_unit_is_correct(prop: property_BSU;
	to_unit: unit): LOGICAL;
LOCAL
	prop_domain: data_type;
	prop_typeof: SET OF STRING := [];
END_LOCAL;

IF (SIZEOF(prop\basic_semantic_unit.definition) = 0)
THEN
	RETURN(UNKNOWN);
END_IF;

prop_typeof := data_type_typeof(prop);

IF (prop_typeof = []) -- some DET not present
THEN
	RETURN(UNKNOWN);
END_IF;

prop_domain := data_type_of_BSU(prop)[1]; -- not empty

IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.INT_MEASURE_TYPE' IN
	TYPEOF(prop_domain))
THEN
	RETURN(derive_dimensional_exponents(to_unit) =
		derive_dimensional_exponents(prop_domain\
		int_measure_type.unit.structured_representation));
END_IF;

IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.REAL_MEASURE_TYPE' IN
	TYPEOF(prop_domain))
THEN
	RETURN(derive_dimensional_exponents(to_unit) =
		derive_dimensional_exponents(prop_domain\
		real_measure_type.unit.structured_representation));
END_IF;

IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.LEVEL_TYPE' IN
	TYPEOF(prop_domain))
THEN
	IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.INT_MEASURE_TYPE' IN
		TYPEOF(prop_domain\level_type.value_type))
	THEN
		RETURN(derive_dimensional_exponents(to_unit) =
			derive_dimensional_exponents(
			prop_domain\level_type.value_type
			.unit.structured_representation));
	END_IF;
	IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.REAL_MEASURE_TYPE' IN

		TYPEOF(prop_domain\level_type.value_type))
	THEN
		RETURN(derive_dimensional_exponents(to_unit) =
			derive_dimensional_exponents(
			prop_domain\level_type.value_type
			.unit.structured_representation));
	END_IF;
END_IF;

RETURN(FALSE);

END_FUNCTION; -- presentation_unit_is_correct




FUNCTION data_type_of_BSU(type_spec: property_or_data_type_BSU):
	SET[0:1] OF data_type;
LOCAL
	res: BOOLEAN := FALSE;
	x: data_type;
END_LOCAL;

IF NOT EXISTS(type_spec)
THEN
	RETURN([]); -- type_spec is indeterminate
END_IF;

IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.PROPERTY_BSU' IN
	TYPEOF(type_spec))
THEN
	IF NOT(SIZEOF(type_spec.definition) = 0)
	THEN
		x := type_spec.definition[1]\property_DET.domain;
		res := TRUE;
	END_IF;
ELSE
	IF NOT(SIZEOF(type_spec.definition) = 0)
	THEN
		x := type_spec.definition[1]
			\data_type_element.type_definition;
		res := TRUE;
	END_IF;
END_IF;

IF NOT(res)
THEN
	RETURN([]);
END_IF;

IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.NAMED_TYPE' IN TYPEOF(x))

THEN
	IF NOT(SIZEOF(x\named_type.referred_type.definition) = 0)
	THEN
		RETURN(data_type_of_BSU(x\named_type.referred_type));
	ELSE
		RETURN([]);
	END_IF;
ELSE
	RETURN([x]);
END_IF;

END_FUNCTION; -- data_type_of_BSU



FUNCTION derive_dimensional_exponents (x : unit) : dimensional_exponents;

  LOCAL
    i      : INTEGER;
    result : dimensional_exponents := 
             dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0); 
  END_LOCAL;

  IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.DERIVED_UNIT' IN TYPEOF(x) THEN -- x is a derived unit

    REPEAT i := LOINDEX(x.elements) TO HIINDEX(x.elements);

      result.length_exponent                    := 
        result.length_exponent + 
        (x.elements[i].exponent * 
         x.elements[i].unit.dimensions.length_exponent);

      result.mass_exponent                      := 
        result.mass_exponent + 
        (x.elements[i].exponent * 
         x.elements[i].unit.dimensions.mass_exponent);

     result.time_exponent := 
        result.time_exponent + 
        (x.elements[i].exponent * 
         x.elements[i].unit.dimensions.time_exponent); 

      result.electric_current_exponent          := 
        result.electric_current_exponent + 
        (x.elements[i].exponent * 
         x.elements[i].unit.dimensions.electric_current_exponent);

      result.thermodynamic_temperature_exponent :=
        result.thermodynamic_temperature_exponent + 
        (x.elements[i].exponent * 
         x.elements[i].unit.dimensions.thermodynamic_temperature_exponent);
 
      result.amount_of_substance_exponent       :=
        result.amount_of_substance_exponent + 
        (x.elements[i].exponent * 
         x.elements[i].unit.dimensions.amount_of_substance_exponent);

      result.luminous_intensity_exponent        := 
        result.luminous_intensity_exponent + 
        (x.elements[i].exponent * 
         x.elements[i].unit.dimensions.luminous_intensity_exponent);
 
    END_REPEAT;
  ELSE -- x is a unitless or a named unit
    result := x.dimensions;
  END_IF;
  RETURN (result);
END_FUNCTION;




FUNCTION provided_properties_list(cl: class_BSU):
	LIST OF property_BSU;

LOCAL
	provided_prop: LIST OF opt_or_mand_property_BSU := [];
	prop: LIST OF property_BSU := [];
END_LOCAL;

IF NOT EXISTS(cl)
THEN
	RETURN([]); -- the class itself is indeterminate
END_IF;

IF (SIZEOF(cl.referenced_by) = 1)
THEN
	provided_prop :=
		cl.referenced_by[1]\implicit_model_class_extension.
			derived_properties
		+ cl.referenced_by[1]\implicit_model_class_extension.
			required_properties
		+ cl.referenced_by[1]\implicit_model_class_extension.
			selectable_properties;

	REPEAT i := 1 TO SIZEOF(provided_prop);
		prop := prop + provided_prop[i].property;
	END_REPEAT;
END_IF;

RETURN(prop);

END_FUNCTION; -- provided_properties_list




FUNCTION selectable_properties_list(cl: class_BSU):
	LIST OF property_BSU;

LOCAL
	prop: LIST OF property_BSU := [];
END_LOCAL;

IF NOT EXISTS(cl)
THEN
	RETURN([]); -- the class itself is indeterminate
END_IF;

IF (SIZEOF(cl.referenced_by) = 1)
THEN
	REPEAT i := 1 TO SIZEOF(cl.referenced_by[1]
			\implicit_model_class_extension.selectable_properties);
		prop := prop + cl.referenced_by[1]\
		implicit_model_class_extension.selectable_properties[i].
		property;
	END_REPEAT;
END_IF;

RETURN(prop);

END_FUNCTION; -- selectable_properties_list




FUNCTION applicable_tables(cl: class_BSU;
	tab: AGGREGATE OF table_identification): LOGICAL;

IF SIZEOF(tab) = 0
THEN
	RETURN(TRUE);
END_IF;

IF NOT EXISTS(cl)
THEN
	RETURN(UNKNOWN);
END_IF;

IF SIZEOF(cl.definition) = 0
THEN
	RETURN(UNKNOWN);
END_IF;

tab := tab - retrieve_tables(cl);

IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA' +
	'.A_PRIORI_SEMANTIC_RELATIONSHIP' IN TYPEOF(cl.definition[1])
THEN
	tab := tab - cl.definition[1]\a_priori_semantic_relationship
		.referenced_tables;
END_IF;

IF SIZEOF(tab) = 0
THEN
	RETURN(TRUE);
ELSE
	IF EXISTS(cl.definition[1]\class.its_superclass)
	THEN
	RETURN(
		applicable_tables(cl.definition[1]\class.its_superclass,
			tab));
	ELSE
		RETURN(FALSE);
	END_IF;
END_IF;

END_FUNCTION; -- applicable_tables




FUNCTION retrieve_tables(cl: class_BSU): SET[0:?] OF table_BSU;
-- requires: { SIZEOF(cl.definition) <> O }

LOCAL
	s: SET[0:?] OF table_BSU := [];
END_LOCAL;

REPEAT i := 1 TO SIZEOF(cl.definition[1]\class.associated_items);
	IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA'
		+'.CLASS_TABLE_RELATIONSHIP'
		IN TYPEOF(cl.definition[1]\class.associated_items[i])
	THEN
		s := s + cl.definition[1]\class.associated_items[i]
			.related_tokens;
	END_IF;
END_REPEAT;
RETURN(s);

END_FUNCTION; -- retrieve_tables




FUNCTION acyclic_class_extension_definition(cl: class_BSU): LOGICAL;

LOCAL
	edges: SET OF domain_restriction;
	prop: LIST OF property_BSU;
END_LOCAL;

prop := provided_properties_list(cl);
edges := defined_domain(cl) + defined_derivation_function(cl);

REPEAT i := LOINDEX(prop) TO HIINDEX(prop);
	IF NOT acyclic_order(prop[i], edges, [])
	THEN
		RETURN(FALSE);
	END_IF;
END_REPEAT;

RETURN(TRUE);

END_FUNCTION; -- acyclic_class_extension_definition




FUNCTION defined_domain(cl: class_BSU): SET OF domain_restriction;

IF NOT EXISTS(cl)
THEN
	RETURN([]); -- the class itself is indeterminate
END_IF;

IF (SIZEOF(cl.referenced_by) = 1)
THEN
	RETURN(cl.referenced_by[1]\implicit_model_class_extension.
		class_extension);
ELSE
	RETURN([]);
END_IF;

END_FUNCTION; -- defined_domain




FUNCTION defined_derivation_function(cl: class_BSU):
	SET OF functional_domain_restriction;

IF NOT EXISTS(cl)
THEN
	RETURN([]); -- the class itself is indeterminate
END_IF;

IF (SIZEOF(cl.referenced_by) = 1)
THEN
	RETURN(cl.referenced_by[1]
		\implicit_model_class_extension.derivation);
ELSE
	RETURN([]);
END_IF;

END_FUNCTION; -- defined_derivation_function




FUNCTION acyclic_order(p: property_BSU;
	edges: SET OF domain_restriction;
	nodes: SET OF property_BSU): BOOLEAN;

LOCAL
	succ: SET OF property_BSU := [];
	-- set of property_BSU that depends (recursively) on p
	out_edges: SET OF domain_restriction;
	-- set of domain_restrictions that contain one of the
	-- property_BSU of the set nodes in the the_property attribute
	-- of one of their assumes variable_semantics
END_LOCAL;

out_edges := QUERY(e <* edges | (QUERY(v <* e.assumes
	| v\property_semantics.the_property IN nodes) <> [] ));

REPEAT i := LOINDEX(out_edges) TO HIINDEX(out_edges);

	REPEAT j := LOINDEX(out_edges[i].defines)
		TO HIINDEX(out_edges[i].defines);
		succ := succ + out_edges[i].defines[j]
			\property_semantics.the_property;
	END_REPEAT;

END_REPEAT;

-- p depends on itself:
IF p IN succ
THEN
	RETURN(FALSE);
END_IF;

-- all the depending properties are reached
IF succ <= nodes
THEN
	RETURN(TRUE);
END_IF;

RETURN(acyclic_order(p, edges, nodes + succ));

END_FUNCTION; -- acyclic_order




FUNCTION derived_properties_list(cl: class_BSU):
	LIST OF property_BSU;

LOCAL
	prop: LIST OF property_BSU := [];
END_LOCAL;

IF NOT EXISTS(cl)
THEN
	RETURN([]); -- the class itself is indeterminate
END_IF;

IF (SIZEOF(cl.referenced_by) = 1)
THEN
	REPEAT i := 1 TO SIZEOF(cl.referenced_by[1]
			\implicit_model_class_extension.derived_properties);
		prop := prop + cl.referenced_by[1]
			\implicit_model_class_extension.derived_properties[i].
			property;
	END_REPEAT;
END_IF;

RETURN(prop);

END_FUNCTION; -- derived_properties_list




FUNCTION required_defined_properties(cl: class_BSU):
	LIST OF property_BSU;

LOCAL
	prop: LIST OF property_BSU := [];
END_LOCAL;

IF NOT EXISTS(cl)
THEN
	RETURN([]); -- the class itself is indeterminate
END_IF;

IF (SIZEOF(cl.referenced_by) = 1)
THEN
	REPEAT i := 1 TO SIZEOF(cl.referenced_by[1]
			\implicit_model_class_extension.required_properties);
		prop := prop + cl.referenced_by[1]\
			implicit_model_class_extension.required_properties[i].
			property;
	END_REPEAT;
END_IF;

RETURN(prop);

END_FUNCTION; -- required_defined_properties




FUNCTION in_typeof(typ: STRING; elt: opt_or_mand_property_BSU ):
	LOGICAL;

IF SIZEOF(elt.property.definition) = 1 THEN
	RETURN(typ IN TYPEOF(elt.property.definition [1]));
ELSE
	RETURN(TRUE);
END_IF;

END_FUNCTION; -- in_typeof




FUNCTION referenced_veps_exist_in_supported_veps(
	lib: library; cl: class_BSU): LOGICAL;
LOCAL
	class_extension: SET [0:1] OF content_item :=
		cl\basic_semantic_unit.referenced_by;
	class_extension_referenced_veps: SET OF
		view_exchange_protocol_identification;
	dictionary_supported_veps: SET OF
		view_exchange_protocol_identification;
	tmp: LOGICAL;
END_LOCAL;

IF (SIZEOF(class_extension) = 1)
THEN
	class_extension_referenced_veps :=
		list_to_set(class_extension[1]\model_class_extension
		.referenced_view_exchange_protocol);
	dictionary_supported_veps := lib\dictionary.supported_vep;
	tmp := (class_extension_referenced_veps <=
		dictionary_supported_veps);
	RETURN(('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.MODEL_CLASS_EXTENSION'

		IN TYPEOF(class_extension[1]))
		AND NOT(tmp));
ELSE
	RETURN(FALSE);
END_IF;

END_FUNCTION; -- referenced_veps_exist_in_supported_veps




FUNCTION referenced_protocols_exist_in_supported_protocols(
	lib: library; cl: class_BSU): LOGICAL;
LOCAL
	class_extension: SET [0:1] OF content_item :=
		cl\basic_semantic_unit.referenced_by;
END_LOCAL;

IF SIZEOF(class_extension) = 1
THEN
	RETURN(('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA' +
		'.MODEL_CLASS_EXTENSION' IN TYPEOF(class_extension))
		AND
		(SIZEOF(QUERY(pr <* class_extension[1]\model_class_extension
		.referenced_external_items | NOT(
		pr\external_item.used_protocol IN
		lib\dictionary.base_protocols)
		AND NOT(pr\external_item.used_protocol IN
		lib.linked_interfaces))) <> 0));
ELSE
	RETURN(FALSE);
END_IF;

END_FUNCTION; -- referenced_protocols_exist_in_supported_protocols



FUNCTION valid_units ( m : measure_with_unit ) : BOOLEAN ;

  IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.LENGTH_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;

  IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.MASS_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;

  IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.TIME_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;

 IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.ELECTRIC_CURRENT_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;

  IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.THERMODYNAMIC_TEMPERATURE_MEASURE'
  IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;

  IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.AMOUNT_OF_SUBSTANCE_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;

  IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.LUMINOUS_INTENSITY_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;

  IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.PLANE_ANGLE_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;

  IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.SOLID_ANGLE_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;

  IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.AREA_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;

  IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.VOLUME_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 3.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;

  IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.RATIO_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;

  IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.POSITIVE_LENGTH_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;

  IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.POSITIVE_PLANE_ANGLE_MEASURE' IN TYPEOF ( m.value_component ) THEN

    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;

  RETURN (TRUE);

END_FUNCTION;

FUNCTION dimensions_for_si_unit (n : si_unit_name) : dimensional_exponents; 

  CASE n  OF
    metre          : RETURN (dimensional_exponents 
                             (1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));
    gram           : RETURN (dimensional_exponents 
                             (0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0));
    second         : RETURN (dimensional_exponents
                             (0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0));
    ampere         : RETURN (dimensional_exponents
                             (0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0));
    kelvin         : RETURN (dimensional_exponents
                             (0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0));
    mole           : RETURN (dimensional_exponents
                             (0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0));
    candela        : RETURN (dimensional_exponents
                             (0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0));
    radian         : RETURN (dimensional_exponents
                             (0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));
    steradian      : RETURN (dimensional_exponents
                             (0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));
    hertz          : RETURN (dimensional_exponents
                             (0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0));
    newton         : RETURN (dimensional_exponents
                             (1.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0));
    pascal         : RETURN (dimensional_exponents
                             (-1.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0));
    joule          : RETURN (dimensional_exponents
                             (2.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0));
    watt           : RETURN (dimensional_exponents
                             (2.0, 1.0, -3.0, 0.0, 0.0, 0.0, 0.0));
    coulomb        : RETURN (dimensional_exponents
                             (0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0));
    volt           : RETURN (dimensional_exponents
                             (2.0, 1.0, -3.0, -1.0, 0.0, 0.0, 0.0));
    farad          : RETURN (dimensional_exponents
                             (-2.0, -1.0, 4.0, 1.0, 0.0, 0.0, 0.0));
    ohm            : RETURN (dimensional_exponents
                             (2.0, 1.0, -3.0, -2.0, 0.0, 0.0, 0.0));
    siemens        : RETURN (dimensional_exponents
                             (-2.0, -1.0, 3.0, 2.0, 0.0, 0.0, 0.0));
    weber          : RETURN (dimensional_exponents
                             (2.0, 1.0, -2.0, -1.0, 0.0, 0.0, 0.0));
    tesla          : RETURN (dimensional_exponents
                             (0.0, 1.0, -2.0, -1.0, 0.0, 0.0, 0.0));
    henry          : RETURN (dimensional_exponents
                             (2.0, 1.0, -2.0, -2.0, 0.0, 0.0, 0.0));
    degree_Celsius : RETURN (dimensional_exponents
                             (0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0));
    lumen          : RETURN (dimensional_exponents
                             (0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0));
    lux            : RETURN (dimensional_exponents
                             (-2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0));
    becquerel      : RETURN (dimensional_exponents
                             (0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0));
    gray           : RETURN (dimensional_exponents
                             (2.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0));
    sievert        : RETURN (dimensional_exponents
                             (2.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0));
  END_CASE;      
END_FUNCTION; 



FUNCTION bag_to_set (the_bag : BAG OF GENERIC : intype) : SET OF GENERIC : intype;

  LOCAL
    the_set: SET OF GENERIC : intype := [];
    i      : INTEGER;
  END_LOCAL;

  IF SIZEOF (the_bag) > 0 THEN
    REPEAT i := 1 TO HIINDEX (the_bag);
      the_set := the_set + the_bag [i];
    END_REPEAT;
  END_IF;

  RETURN (the_set);

END_FUNCTION;



FUNCTION sub_list_until(cla: LIST [1:?] OF class_BSU;
	cl: class_BSU): LIST [1:?] OF class_BSU;

LOCAL
	c: LIST [0:?] OF class_BSU := [];
END_LOCAL;

REPEAT k := 1 TO SIZEOF(cla);
	c := c + cla[k];
	IF cla[k] :=: cl
	THEN
		ESCAPE;
	END_IF;
END_REPEAT;

RETURN(c);

END_FUNCTION; -- sub_list_until




FUNCTION applicable_documents(cl: class_BSU;
	doc: AGGREGATE OF document_BSU): LOGICAL;

IF SIZEOF(doc) = 0
THEN
	RETURN(TRUE);
END_IF;

IF NOT EXISTS(cl)
THEN
	RETURN(UNKNOWN);
END_IF;

IF SIZEOF(cl.definition) = 0
THEN
	RETURN(UNKNOWN);
END_IF;

doc := doc - retrieve_documents(cl);

IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA' +
	'.A_PRIORI_SEMANTIC_RELATIONSHIP' IN TYPEOF(cl.definition[1])
THEN
	Doc := doc - cl.definition[1]\a_priori_semantic_relationship.
		referenced_documents;
END_IF;

IF SIZEOF(doc) = 0
THEN
	RETURN(TRUE);
ELSE
	IF EXISTS(cl.definition[1]\class.its_superclass)
	THEN
		RETURN(applicable_documents(cl.definition[1]
			\class.its_superclass, doc));
	ELSE
		RETURN(FALSE);
	END_IF;
END_IF;

END_FUNCTION; -- applicable_documents




FUNCTION retrieve_documents(cl: class_BSU): SET[0:?] OF document_BSU;
-- requires: { SIZEOF(cl.definition) <> O }

LOCAL
	s: SET[0:?] OF document_BSU := [];
END_LOCAL;

REPEAT i := 1 TO SIZEOF(cl.definition[1]\class.associated_items);
	IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA' +
		'.CLASS_DOCUMENT_RELATIONSHIP'
		IN TYPEOF(cl.definition[1]\class.associated_items[i])
	THEN
		s := s+ cl.definition[1]\class.associated_items[i]
			\class_document_relationship.related_tokens;
	END_IF;
END_REPEAT;

RETURN(s);

END_FUNCTION; -- retrieve_documents




FUNCTION allowed_properties(cl: class_BSU;
	prop: SET OF property_BSU): LOGICAL;

IF NOT EXISTS(cl)
THEN
	RETURN(UNKNOWN); -- the class itself is indeterminate
END_IF;

IF (prop <= (list_to_set(provided_properties_list(cl))))
THEN
	RETURN(TRUE);
ELSE
	RETURN(FALSE);
END_IF;

END_FUNCTION; -- allowed_properties



FUNCTION gm_identification_characteristics_list(cl: class_BSU):
	LIST OF property_BSU;

LOCAL
	prop: LIST OF property_BSU := [];
END_LOCAL;

IF NOT EXISTS(cl)
THEN
	RETURN([]); -- the class itself is indeterminate
END_IF;

IF (SIZEOF(cl.referenced_by) = 1)
THEN
	IF NOT('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.ITEM_CLASS_EXTENSION'
		IN TYPEOF(cl.referenced_by[1])) -- abnormal case
	THEN
		RETURN([]); -- abnormal case
	END_IF;

	REPEAT i := 1 TO SIZEOF(cl.referenced_by[1]
		\item_class_extension.identification_characteristics);
		prop := prop + cl.referenced_by[1]
			\item_class_extension.identification_characteristics[i]
			.property;
	END_REPEAT;
END_IF;

RETURN(prop);

END_FUNCTION; -- gm_identification_characteristics_list



FUNCTION visible_types(cl: class_BSU;
	typ: AGGREGATE OF data_type_BSU): LOGICAL;

LOCAL
	ok: BOOLEAN := TRUE;
END_LOCAL;

IF NOT EXISTS(cl)
THEN
	RETURN(UNKNOWN);
END_IF;

REPEAT i := 1 TO SIZEOF(typ);
IF NOT(typ[i] IN compute_known_visible_data_types(cl))
	THEN ok := FALSE;
END_IF;
END_REPEAT;

IF NOT(ok) AND NOT(all_class_descriptions_reachable(cl))
	THEN RETURN(UNKNOWN);
END_IF;

IF NOT(ok) AND all_class_descriptions_reachable(cl)
	THEN RETURN(FALSE);
END_IF;

RETURN(TRUE);

END_FUNCTION; -- visible_types



FUNCTION applicable_types(cl: class_BSU;
	typ: AGGREGATE OF data_type_BSU): LOGICAL;

IF SIZEOF(typ) = 0
THEN
	RETURN(TRUE);
END_IF;

IF NOT EXISTS(cl)
THEN
	RETURN(UNKNOWN);
END_IF;

IF SIZEOF(cl.definition) = 0
THEN
	RETURN(UNKNOWN);
END_IF;

typ := typ - cl.definition[1]\class.defined_types;

IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA' +
	'.A_PRIORI_SEMANTIC_RELATIONSHIP' IN TYPEOF(cl.definition[1]))
THEN
	typ := typ -
		cl.definition[1]\a_priori_semantic_relationship
		.referenced_data_types;
END_IF;

IF SIZEOF(typ) = 0
THEN
	RETURN(TRUE);
ELSE
	IF EXISTS(cl.definition[1]\class.its_superclass)
	THEN
		RETURN(applicable_types(cl.definition[1]
			\class.its_superclass, typ));
	ELSE
		RETURN(FALSE);
	END_IF;
END_IF;

END_FUNCTION; -- applicable_types


FUNCTION optional_properties_list(cl: class_BSU):
	LIST OF property_BSU;

LOCAL
	prop: LIST OF property_BSU := [];
END_LOCAL;

IF NOT EXISTS(cl)
THEN
	RETURN([]); -- the class itself is indeterminate
END_IF;

IF (SIZEOF(cl.referenced_by) = 1)
THEN
	REPEAT i := 1 TO SIZEOF(cl.referenced_by[1]
		\implicit_model_class_extension.derived_properties);
		IF (cl.referenced_by[1]\implicit_model_class_extension
			.derived_properties[i].is_optional)
		THEN
			prop := prop + cl.referenced_by[1]
				\implicit_model_class_extension.
				derived_properties[i].property;
		END_IF;
	END_REPEAT; -- derived optional properties of this class

	REPEAT i := 1 TO SIZEOF(cl.referenced_by[1]
		\implicit_model_class_extension.selectable_properties);
		IF (cl.referenced_by[1]\implicit_model_class_extension
			.selectable_properties[i].is_optional)
		THEN
			prop := prop + cl.referenced_by[1]
				\implicit_model_class_extension.
				selectable_properties[i].property;
		END_IF;
	END_REPEAT; -- selectable optional properties of this class
END_IF;

RETURN(prop);

END_FUNCTION; -- optional_properties_list


FUNCTION supplier_associated_http_files(sup_BSU: supplier_BSU):
	SET OF http_file;

LOCAL
	sup: supplier_element;
	files: SET OF http_file := [];
END_LOCAL;

IF SIZEOF(sup_BSU.definition) > 0
	THEN sup := sup_BSU.definition[1];
ELSE
	RETURN(files);
END_IF;

REPEAT i := 1 TO SIZEOF(sup.associated_items);
-- supplier_BSU_relationship
	REPEAT j := 1 TO SIZEOF(sup.associated_items[i].related_tokens);
	--supplier_related_BSU
		REPEAT k := 1 TO SIZEOF(sup.associated_items[i]
				.related_tokens[j].referenced_by); --content_item

			IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.EXTERNAL_ITEM'IN
				TYPEOF(sup.associated_items[i]
				.related_tokens[j].referenced_by[k]))
			THEN
				REPEAT l := 1 TO SIZEOF(sup.associated_items[i]
					.related_tokens[j].referenced_by[k]
					\external_item.content.consists_of);
					--language_specific_content

					REPEAT m := 1 TO SIZEOF(
						sup.associated_items[i]
						.related_tokens[j].referenced_by[k]
						\external_item.content
						.consists_of[l].content_files);
						-- external_file_unit
						IF
						('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.HTTP_FILE'
							IN TYPEOF(sup.associated_items[i]
							.related_tokens[j].referenced_by[k]
							\external_item.content
							.consists_of[l].content_files[m]))
						THEN
							files := files +
							sup.associated_items[i]
							.related_tokens[j].referenced_by[k]
							\external_item.content
							.consists_of[l].content_files[m];
						END_IF; -- http_file
					END_REPEAT; -- m
				END_REPEAT; -- l
			END_IF; -- external_item
		END_REPEAT; -- k
	END_REPEAT; -- j
END_REPEAT; -- i

RETURN(files);

END_FUNCTION; -- supplier_associated_http_files



RULE single_language_assignment FOR(global_language_assignment);
WHERE
	SIZEOF(global_language_assignment) <= 1;
END_RULE; -- single_language_assignment


RULE assert_ONEOF FOR(named_unit);
WHERE
	QUERY(u <* named_unit |
		('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.NON_SI_UNIT'
		IN TYPEOF(u)) AND
		('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.SI_UNIT' IN TYPEOF(u))
		OR ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.NON_SI_UNIT'
		IN TYPEOF(u)) AND
		('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.CONTEXT_DEPENDENT_UNIT' IN TYPEOF(u))
		OR ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.NON_SI_UNIT'
		IN TYPEOF(u)) AND
		('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.CONVERSION_BASED_UNIT' IN TYPEOF(u))
		) = [];
END_RULE; -- assert_ONEOF


RULE assert_oneof_for_table_rule FOR(table_element);
WHERE
	WR1: QUERY(temp <* table_element |
		NOT('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA'
		+ '.RDB_TABLE_ELEMENT' IN TYPEOF(temp))
		AND ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.RDB_TABLE_SPECIFICATION'

		IN TYPEOF(temp))) = [];
END_RULE; -- assert_oneof_for_table_rule




RULE no_forward_reference_from_table_rule FOR(
		dictionary, table_element);
WHERE
	WR1: QUERY(dic <* dictionary | QUERY(tab <* table_element
		| makes_reference_outside(
		get_property_BSU_from_property_semantics(
		tab\table_specification.column_meaning),
		sub_list_until(dic.contained_classes,
		tab\table_specification.table_identifier\
		table_BSU.name_scope))) <> [] ) = [];
END_RULE; -- no_forward_reference_from_table_rule




RULE imported_tables_are_visible_or_applicable_rule FOR(
	a_priori_semantic_relationship, table_element);
WHERE
	WR1: QUERY(rel <* a_priori_semantic_relationship
		| QUERY(tab <* rel.referenced_tables
		| QUERY(cl <* rel.referenced_classes
		| NOT visible_tables(cl, [tab])
		AND NOT applicable_tables(cl, [tab]))
		= rel.referenced_classes) = [])
		= a_priori_semantic_relationship;
END_RULE; -- imported_tables_are_visible_or_applicable_rule




RULE imported_documents_are_visible_or_applicable_rule FOR(
	a_priori_semantic_relationship, document_element);
WHERE
	WR1: QUERY(rel <* a_priori_semantic_relationship
		| QUERY(doc <* rel.referenced_documents
		| QUERY(cl <* rel.referenced_classes
		| NOT visible_documents(cl, [doc])
		AND NOT applicable_documents(cl, [doc]))
		= rel.referenced_classes) = [])
		= a_priori_semantic_relationship;
END_RULE; -- imported_documents_are_visible_or_applicable_rule




RULE assert_oneof_for_library_rule FOR(library);
WHERE
	WR1: QUERY(temp <* library |
		NOT('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA'
		+ '.LIBRARY_IN_STANDARD_FORMAT'
		IN TYPEOF(temp))
		AND('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA'
		+ '.DICTIONARY_IN_STANDARD_FORMAT'
		IN TYPEOF(temp))) = [];

END_RULE; -- assert_oneof_for_library_rule




RULE unique_http_directory_name_per_supplier_rule FOR(
	http_class_directory);
WHERE
	WR1: QUERY(dir_1 <* http_class_directory
		| QUERY(dir_2 <* http_class_directory
		| (dir_1.name = dir_2.name) AND
		(dir_1.class.defined_by = dir_2.class.defined_by))
		<> [dir_1] )
		= [];
END_RULE; -- unique_http_directory_name_per_supplier_rule




RULE http_directory_refers_to_bsu_related_class_rule FOR(
	http_file, class_bsu_related_content);
WHERE
	WR1: QUERY(http_f <* http_file |
		(('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA' +
		'.CLASS_BSU_RELATED_CONTENT'
		IN TYPEOF(http_f\external_file_unit.unit_of
		.content_of.content_of))
		AND (http_f.http_directory.class <> http_f\
		external_file_unit.unit_of.content_of.content_of
		\content_item.dictionary_definition.name_scope))) = [];
END_RULE; -- http_directory_refers_to_bsu_related_class_rule




RULE http_directory_refers_to_class_extension_rule FOR(
	http_file, class_extension_external_item );
WHERE
	WR1: QUERY(http_f <* http_file |
		('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA' +
		'.CLASS_EXTENSION_EXTERNAL_ITEM'
		IN TYPEOF(http_f\external_file_unit.unit_of
		.content_of.content_of))
		AND (http_f.http_directory.class <> http_f\
		external_file_unit.unit_of.content_of.content_of
		\class_extension_external_item.belongs_to
		\content_item.dictionary_definition)) = [];
END_RULE; -- http_directory_refers_to_class_extension_rule



RULE valued_properties_are_allowed_for_implicit_spec_rule FOR
	(lib_item_instance, item_class_extension);
LOCAL
	allowed_valued_properties: LOGICAL := TRUE;
END_LOCAL;

REPEAT i := 1 TO SIZEOF(lib_item_instance);
	IF (SIZEOF(lib_item_instance[i]\dic_class_instance.class_def
		.referenced_by) = 1)
	THEN
		IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA' +
			'.ITEM_CLASS_EXTENSION' IN TYPEOF(lib_item_instance[i]\
			dic_class_instance.class_def.referenced_by[1]))
		THEN
			allowed_valued_properties := allowed_valued_properties
			AND (QUERY(prop <* lib_item_instance[i].properties |
			NOT((allowed_properties(lib_item_instance[i]\
			dic_class_instance.class_def, [prop.prop_def])))) = []);
		END_IF;
	END_IF;
END_REPEAT;

WHERE
	WR1: allowed_valued_properties;
END_RULE; -- valued_properties_are_allowed_for_implicit_spec_rule



RULE valued_properties_are_allowed_for_explicit_spec_rule FOR
	(lib_item_instance, explicit_item_class_extension);
LOCAL
	allowed_valued_properties: LOGICAL := TRUE;
END_LOCAL;

REPEAT i := 1 TO SIZEOF(lib_item_instance);
	IF SIZEOF(lib_item_instance[i]\dic_class_instance.class_def
		.referenced_by) = 1
	THEN
		IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA' +
			'.EXPLICIT_ITEM_CLASS_EXTENSION' IN
			TYPEOF(lib_item_instance[i]\dic_class_instance.
			class_def.referenced_by[1]))
		THEN
			allowed_valued_properties := allowed_valued_properties
			AND (QUERY(prop <* lib_item_instance[i].properties
			| NOT((applicable_properties(
			lib_item_instance[i]\dic_class_instance
			.class_def, [prop.prop_def])))) = []);
		END_IF;
	END_IF;
END_REPEAT;

WHERE
	WR1: allowed_valued_properties;
END_RULE; -- valued_properties_are_allowed_for_explicit_spec_rule


RULE identification_properties_are_valued_for_implicit_spec_rule FOR
	(lib_item_instance, item_class_extension);
LOCAL
	valued_identification_properties: LOGICAL := TRUE;
END_LOCAL;

REPEAT i := 1 TO SIZEOF(lib_item_instance);
	IF (SIZEOF(lib_item_instance[i]\dic_class_instance.
		class_def.referenced_by) = 1)
	THEN
		IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA' +
			'.ITEM_CLASS_EXTENSION' IN
			TYPEOF(lib_item_instance[i]\dic_class_instance.
			class_def.referenced_by[1]))
		THEN
			valued_identification_properties :=
			valued_identification_properties
			AND (NOT all_class_descriptions_reachable(
			lib_item_instance[i]\dic_class_instance.class_def)
			OR (QUERY(prop <*
			gm_identification_characteristics_list(
			lib_item_instance[i]\dic_class_instance.class_def)
			| NOT(prop IN collects_assigned_instance_properties
			(list_to_set(lib_item_instance[i]\
			dic_class_instance.properties)))) = []));
		END_IF;
	END_IF;
END_REPEAT;

WHERE
	WR1: valued_identification_properties;
END_RULE;-- identification_properties_are_valued_for_implicit_spec_rule


RULE identification_properties_are_valued_for_explicit_spec_rule FOR
	(lib_item_instance, explicit_item_class_extension);
LOCAL
	valued_identification_properties: LOGICAL := TRUE;
END_LOCAL;

REPEAT i := 1 TO SIZEOF(lib_item_instance);
	IF SIZEOF(lib_item_instance[i]\dic_class_instance.
		class_def.referenced_by) = 1
	THEN
		IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA' +
			'.EXPLICIT_ITEM_CLASS_EXTENSION' IN
			TYPEOF(lib_item_instance[i]\dic_class_instance.
			class_def.referenced_by[1]))
		THEN
			valued_identification_properties :=
			valued_identification_properties
			AND (QUERY(prop <*
			lib_item_instance[i]\dic_class_instance.
			class_def.referenced_by[1].instance_identification
			| NOT(prop IN collects_assigned_instance_properties
			(list_to_set(lib_item_instance[i]\
			dic_class_instance.properties)))) = []);
		END_IF;
	END_IF;
END_REPEAT;

WHERE
	WR1: valued_identification_properties;
END_RULE; --identification_properties_are_valued_for_explicit_spec_rule



RULE two_fold_variable_representation_rule FOR(variable_semantics);
WHERE
	WR1: QUERY(vs <* variable_semantics
		| SIZEOF(syntax_of(vs)) > 1) = [];
END_RULE; -- two_fold_variable_representation_rule


RULE allowed_named_type_usage_rule FOR(class);
LOCAL
	named_type_usage_allowed: LOGICAL := TRUE;
	is_app: LOGICAL;
	prop: property_bsu;
	cl: class;
	dtnt: SET[0:1] OF data_type_bsu := [];
END_LOCAL;

REPEAT i := 1 TO SIZEOF(class);
	cl := class[i];
	REPEAT j := 1 TO SIZEOF(class[i].described_by);
		prop := cl.described_by[j];
		dtnt := data_type_named_type(prop);

		IF (SIZEOF(dtnt) = 1) THEN
			is_app := applicable_types(cl.identified_by, dtnt);
			IF (NOT is_app) THEN
				named_type_usage_allowed := FALSE;
			END_IF;
		END_IF;
	END_REPEAT;
END_REPEAT;

WHERE
	WR1: named_type_usage_allowed;
END_RULE; -- allowed_named_type_usage_rule


RULE class_associated_items_rule FOR(class);
WHERE
	WR1: QUERY(temp <* class | (SIZEOF(temp.associated_items) > 2)
		OR ((SIZEOF(temp.associated_items) = 1)
		AND NOT(('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA'
		+'.CLASS_TABLE_RELATIONSHIP' IN
		TYPEOF(temp.associated_items[1]))
		OR ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA'
		+'.CLASS_DOCUMENT_RELATIONSHIP'
		IN TYPEOF(temp.associated_items[1]))))
		OR ((SIZEOF(temp.associated_items) = 2)
		AND NOT((('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA'
		+ '.CLASS_TABLE_RELATIONSHIP'
		IN TYPEOF(temp.associated_items[1]))
		AND ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA'
		+'.CLASS_DOCUMENT_RELATIONSHIP'
		IN TYPEOF(temp.associated_items[2])))
		OR (('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA'
		+'.CLASS_TABLE_RELATIONSHIP'
		IN TYPEOF(temp.associated_items[2]))
		AND ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA'
		+ '.CLASS_DOCUMENT_RELATIONSHIP'
		IN TYPEOF(temp.associated_items[1]))))))
		= [];
END_RULE; -- class_associated_items_rule



RULE assert_oneof_for_class_rule FOR(class);
WHERE
	WR1: QUERY(cl <* class |
		('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.ITEM_CLASS'
		IN TYPEOF(cl))
		AND (('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA'
		+'.ABSTRACT_FUNCTIONAL_MODEL_CLASS') IN TYPEOF(cl))) = [];
	WR2: QUERY(cl <* class |
		('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.ITEM_CLASS'
		IN TYPEOF(cl))
		AND (('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA'
		+ '.FUNCTIONAL_VIEW_CLASS') IN TYPEOF(cl))) = [];
	WR3: QUERY(cl <* class |
		(('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA'
		+ '.ABSTRACT_FUNCTIONAL_MODEL_CLASS')
		IN TYPEOF(cl))
		AND (('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA'
		+'.FUNCTIONAL_VIEW_CLASS') IN TYPEOF(cl))) = [];
END_RULE; -- assert_oneof_for_class_rule


RULE imported_properties_are_visible_or_applicable_rule FOR(
	a_priori_semantic_relationship, property_DET);
WHERE
	WR1: QUERY(rel <* a_priori_semantic_relationship
		| QUERY(prop <* rel.referenced_properties
		| QUERY(cl <* rel.referenced_classes
		| NOT visible_properties(cl, [prop])
		AND NOT applicable_properties(cl, [prop]))
		= rel.referenced_classes) = [])
		= a_priori_semantic_relationship;
END_RULE; -- imported_properties_are_visible_or_applicable_rule



RULE imported_data_types_are_visible_or_applicable_rule FOR(
	a_priori_semantic_relationship, data_type_element);
WHERE
	WR1: QUERY(rel <* a_priori_semantic_relationship
		| QUERY(typ <* rel.referenced_data_types
		| QUERY(cl <* rel.referenced_classes
		| NOT visible_types(cl, [typ])
		AND NOT applicable_types(cl, [typ]))
		= rel.referenced_classes) = [])
		= a_priori_semantic_relationship;
END_RULE; -- imported_data_types_are_visible_or_applicable_rule


RULE complete_identification_for_instance_rule FOR(
	class_instance_constructor);
WHERE
	WR1: (QUERY(inst <* class_instance_constructor |
		NOT(definition_available_implies(inst.expr_type,
		(SIZEOF(inst.expr_type.referenced_by) = 0) OR
		('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.IMPLICIT_MODEL_CLASS_EXTENSION'
		IN TYPEOF(inst.expr_type.referenced_by[1])))))
		= []);
	WR2: (QUERY(inst <* class_instance_constructor |
		QUERY(prop <*
		(list_to_set(collects_assigned_properties(inst.properties)) -
		list_to_set(optional_properties_list(inst.expr_type))) |
		NOT(EXISTS(prop.its_value))) = [] ) =[]);

END_RULE; -- complete_identification_for_instance_rule



RULE complete_identification_for_item_instance_rule FOR(
	class_instance_constructor, item_class_extension);
WHERE
	WR1: QUERY(inst <* class_instance_constructor |
		NOT(
		definition_available_implies(inst.expr_type,
		(SIZEOF(inst.expr_type.referenced_by) = 0) OR
		(('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.ITEM_CLASS_EXTENSION'
		IN TYPEOF(inst.expr_type.referenced_by[1]))
		AND (collects_assigned_properties(inst.properties)
		= (gm_identification_characteristics_list(inst.expr_type))))
		)
		)) = [];
END_RULE; -- complete_identification_for_item_instance_rule




RULE unique_http_file_name_per_supplier_element_rule FOR(
	supplier_BSU);
WHERE
	WR1: QUERY(sup_BSU <* supplier_BSU | (SIZEOF
		(sup_BSU.definition) = 1) AND
		(QUERY(fil_1 <* supplier_associated_http_files(sup_BSU)
		| QUERY(fil_2 <* supplier_associated_http_files(sup_BSU)
		| fil_1.http_file_name = fil_2.http_file_name)
		<> [fil_1] ) <> [] ) )
		= [];
END_RULE; -- unique_http_file_name_per_supplier_element_rule




RULE illustration_is_not_a_referenced_graphics_rule FOR(
	graphics);
WHERE
	WR1: QUERY(icon <* graphics |
		('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.REFERENCED_GRAPHICS'
		IN TYPEOF(icon))
		AND ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.ILLUSTRATION'
		IN TYPEOF(icon))) = [];
END_RULE; -- illustration_is_not_a_referenced_graphics_rule



RULE allowed_reference_to_LIIM_24_1_rule FOR(
	library_iim_identification);
WHERE
	WR1: QUERY(liim_id <* library_iim_identification |
		((liim_id\data_exchange_specification_identification
				.status = 'WD')
			OR
		(liim_id\data_exchange_specification_identification
				.status = 'CD')
			OR
		(liim_id\data_exchange_specification_identification
				.status = 'DIS')
			OR
		(liim_id\data_exchange_specification_identification
				.status = 'FDIS')
			OR
		(liim_id\data_exchange_specification_identification
				.status = 'IS')
			OR
		(liim_id\data_exchange_specification_identification
				.status = 'TS')
			OR
		(liim_id\data_exchange_specification_identification
				.status = 'PAS')
			OR
		(liim_id\data_exchange_specification_identification
				.status = 'ITA')
		)
		AND
		(liim_id\data_exchange_specification_identification.name
		= 'ISO_13584_24_1')
		AND
		is_correct_liim_24_1_application_value(liim_id)
		AND
		(QUERY(efp <*
		liim_id\data_exchange_specification_identification
		.external_file_protocols
		| NOT(is_extended_liim_24_1_application_value(liim_id))
		AND
		NOT(conformant_external_file_protocol_24_1([efp]))
		) = []))
		= QUERY(liim_id <* library_iim_identification |
		(liim_id\data_exchange_specification_identification
		.name = 'ISO_13584_24_1'));
END_RULE; -- allowed_reference_to_LIIM_24_1_rule



FUNCTION conformant_http_protocol_24_1(
	ef: external_file_protocol): BOOLEAN;

LOCAL
	ok: BOOLEAN := TRUE;
END_LOCAL;

IF (('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA'
	+ '.HTTP_PROTOCOL' IN TYPEOF(ef)) AND
	(ef.organisation.id = 'IAB') AND
	(ef.organisation.name = 'Internet Architecture Board') AND
	((ef.protocol_name = 'HTTP')
		OR (ef.protocol_name = 'HTTPS'))AND
	(ef.designation.preferred_name = 'Hypertext Transfer Protocol'))
THEN
	IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.TRANSLATED_LABEL'
		IN TYPEOF(ef.designation.short_name))
	THEN
		REPEAT i:= 1 TO SIZEOF(ef.designation.short_name.labels);
			IF (ef.designation.short_name.labels[i]
				LIKE 'RFC####&')
			THEN
				ok := ok AND TRUE;
			ELSE
				ok := ok AND FALSE;
			END_IF;
		END_REPEAT;
		RETURN(OK);
	ELSE
		IF ef.designation.short_name
			LIKE 'RFC####&'
		THEN
			RETURN(TRUE);
		ELSE
			RETURN(FALSE);
		END_IF;
	END_IF;
ELSE
	RETURN(FALSE);
END_IF;

END_FUNCTION; -- conformant_http_protocol_24_1



FUNCTION conformant_8859_1_protocol_24_1(ef: external_file_protocol):
	BOOLEAN;

IF (('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA'
	+ '.STANDARD_DATA_PROTOCOL' IN TYPEOF(ef)) AND
	(ef.organisation.id = 'ISO') AND
	(ef.organisation.name
	= 'International Organisation for Standardisation') AND
	(ef.protocol_name = 'ISO_8859_1') AND
	(ef.designation.preferred_name
	= 'Latin alphabet No 1') AND
	(ef.designation.short_name = 'ISO 8859-1'))
THEN
	RETURN(TRUE);
ELSE
	RETURN(FALSE);
END_IF;

END_FUNCTION; -- conformant_8859_1_protocol_24_1



FUNCTION conformant_external_file_protocol_24_1(
	S: SET [0:?] OF external_file_protocol): BOOLEAN;

REPEAT i := 1 TO SIZEOF(S);
	IF NOT(conformant_8859_1_protocol_24_1(S[i])
		OR conformant_http_protocol_24_1(S[i]))
	THEN
		RETURN(FALSE);
	END_IF;
END_REPEAT;

RETURN(TRUE);

END_FUNCTION; -- conformant_external_file_protocol_24_1



FUNCTION is_correct_liim_24_1_application_value(
	liim_id: library_iim_identification): BOOLEAN;

IF EXISTS(liim_id\data_exchange_specification_identification.application)
	AND
	((liim_id\data_exchange_specification_identification
		.application[1]='1')
	OR
	(liim_id\data_exchange_specification_identification
		.application[1]='2')
	OR
	(liim_id\data_exchange_specification_identification
		.application[1]='3')
	OR
	(liim_id\data_exchange_specification_identification
		.application[1]='4')
	OR
	(liim_id\data_exchange_specification_identification
		.application[1]='5')
	OR
	(liim_id\data_exchange_specification_identification
		.application[1]='6'))
	AND
	((liim_id\data_exchange_specification_identification
		.application LIKE '#')
	OR
	(liim_id\data_exchange_specification_identification.application
		LIKE '#E'))
THEN
	RETURN(TRUE);
ELSE
	RETURN(FALSE);
END_IF;
END_FUNCTION; -- is_correct_liim_24_1_application_value



FUNCTION is_extended_liim_24_1_application_value(
	liim_id: library_iim_identification): BOOLEAN;

IF EXISTS(liim_id\data_exchange_specification_identification
		.application) AND
	(liim_id\data_exchange_specification_identification
		.application LIKE '#E')
THEN
	RETURN(TRUE);
ELSE
	RETURN(FALSE);
END_IF;
END_FUNCTION; -- is_extended_liim_24_1_application_value


RULE at_most_one_dictionary_rule FOR(dictionary);
WHERE
	WR1: SIZEOF(dictionary) <= 1;
END_RULE; -- at_most_one_library_rule

TYPE date_time_select = SELECT

  (date,

   local_time,

   date_and_time);

END_TYPE;





TYPE month_in_year_number = INTEGER;

WHERE

  WR1: { 1 <= SELF <= 12 };

END_TYPE;



TYPE week_in_year_number = INTEGER;

WHERE

  WR1: { 1 <= SELF <= 53 };

END_TYPE;



TYPE day_in_week_number = INTEGER;

WHERE

  WR1: { 1 <= SELF <= 7 };

END_TYPE;



TYPE day_in_month_number = INTEGER;

END_TYPE;



TYPE day_in_year_number = INTEGER;

END_TYPE;



TYPE ahead_or_behind = ENUMERATION OF

  (ahead,

   behind);

END_TYPE;



TYPE hour_in_day = INTEGER;

WHERE

  WR1: { 0 <= SELF < 24 };

END_TYPE;



TYPE minute_in_hour = INTEGER;

WHERE

  WR1: { 0 <= SELF <= 59 };

END_TYPE;



TYPE second_in_minute = REAL;

WHERE

  WR1: { 0 <= SELF < 60 };

END_TYPE;



ENTITY date

  SUPERTYPE OF (ONEOF (calendar_date,

                       ordinal_date,

                       week_of_year_and_day_date));

  year_component : year_number;

END_ENTITY;



ENTITY calendar_date

  SUBTYPE OF (date);

  day_component   : day_in_month_number;

  month_component : month_in_year_number;

WHERE

  WR1: valid_calendar_date (SELF);

END_ENTITY;



ENTITY ordinal_date

  SUBTYPE OF (date);

  day_component : day_in_year_number;

WHERE

  WR1: (NOT leap_year(SELF.year_component) AND { 1 <= day_component <= 365 }) OR

           (leap_year(SELF.year_component) AND { 1 <= day_component <= 366 });

END_ENTITY;



ENTITY week_of_year_and_day_date

  SUBTYPE OF (date);

  week_component : week_in_year_number;

  day_component  : OPTIONAL day_in_week_number;

END_ENTITY;



ENTITY coordinated_universal_time_offset;

  hour_offset   : hour_in_day;

  minute_offset : OPTIONAL minute_in_hour;

  sense         : ahead_or_behind;

END_ENTITY;



ENTITY local_time;

  hour_component   : hour_in_day;

  minute_component : OPTIONAL minute_in_hour;

  second_component : OPTIONAL second_in_minute;

  zone             : coordinated_universal_time_offset;

WHERE

  WR1: valid_time (SELF);

END_ENTITY;



ENTITY date_and_time;

  date_component : date;

  time_component : local_time;

END_ENTITY;



ENTITY date_time_role;

  name : label;

END_ENTITY;



ENTITY date_role;

  name : label;

END_ENTITY;



ENTITY time_role;

  name : label;

END_ENTITY;



FUNCTION leap_year(year : year_number) : BOOLEAN;



  IF ((((year MOD 4) = 0) AND ((year MOD 100) <> 0)) OR

       ((year MOD 400) = 0)) THEN

    RETURN(TRUE);

  ELSE

    RETURN(FALSE);

  END_IF;

END_FUNCTION;



FUNCTION valid_calendar_date (date : calendar_date) : LOGICAL;



  IF NOT ({1 <= date.day_component <= 31}) THEN

    RETURN(FALSE);

  END_IF;

  CASE date.month_component OF

    4         : RETURN({ 1<= date.day_component <= 30});

    6         : RETURN({ 1<= date.day_component <= 30});

    9         : RETURN({ 1<= date.day_component <= 30});

    11        : RETURN({ 1<= date.day_component <= 30});

    2         :

    BEGIN

      IF (leap_year(date.year_component)) THEN

        RETURN({ 1<= date.day_component <= 29});

      ELSE

        RETURN({ 1<= date.day_component <= 28});

      END_IF;

    END;

    OTHERWISE : RETURN(TRUE);

  END_CASE;

END_FUNCTION;



FUNCTION valid_time (time: local_time) : BOOLEAN;

  IF EXISTS (time.second_component) THEN

    RETURN (EXISTS (time.minute_component));

  ELSE

    RETURN (TRUE);

  END_IF;

END_FUNCTION;



TYPE person_organization_select = SELECT

  (person,

   organization,

   person_and_organization);

END_TYPE;



ENTITY address;

  internal_location       : OPTIONAL label;

  street_number           : OPTIONAL label;

  street                  : OPTIONAL label;

  postal_box              : OPTIONAL label;

  town                    : OPTIONAL label;

  region                  : OPTIONAL label;

  postal_code             : OPTIONAL label;

  country                 : OPTIONAL label;

  facsimile_number        : OPTIONAL label;

  telephone_number        : OPTIONAL label;

  electronic_mail_address : OPTIONAL label;

  telex_number            : OPTIONAL label;

WHERE

  WR1: EXISTS(internal_location)       OR

       EXISTS(street_number)           OR

       EXISTS(street)                  OR

       EXISTS(postal_box)              OR

       EXISTS(town)                    OR

       EXISTS(region)                  OR

       EXISTS(postal_code)             OR

       EXISTS(country)                 OR

       EXISTS(facsimile_number)        OR

       EXISTS(telephone_number)        OR

       EXISTS(electronic_mail_address) OR

       EXISTS(telex_number);

END_ENTITY;



ENTITY personal_address

  SUBTYPE OF (address);

  people      : SET [1:?] OF person;

  description : text;

END_ENTITY;



ENTITY organizational_address

  SUBTYPE OF (address);

  organizations : SET [1:?] OF organization;

  description   : text;

END_ENTITY;



ENTITY person;

  id            : identifier;

  last_name     : OPTIONAL label;

  first_name    : OPTIONAL label;

  middle_names  : OPTIONAL LIST [1:?] OF label;

  prefix_titles : OPTIONAL LIST [1:?] OF label;

  suffix_titles : OPTIONAL LIST [1:?] OF label;

UNIQUE

  UR1: id;

WHERE

  WR1: EXISTS(last_name) OR EXISTS(first_name);

END_ENTITY;



ENTITY organization;

  id          : OPTIONAL identifier;

  name        : label;

  description : text;

END_ENTITY;


ENTITY person_and_organization;

  the_person       : person;

  the_organization : organization;

END_ENTITY;



END_SCHEMA; -- ISO13584_g_m_iim_library_implicit_schema

































