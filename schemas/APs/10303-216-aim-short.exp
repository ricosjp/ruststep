(* 
AIM short form for ISO/IS 10303-216
Blair Downie
2002-11026
ISO TC184/SC4/WG3 N1135
*)

SCHEMA ship_moulded_form_schema;   
  
   USE FROM aic_non_manifold_surface                        -- ISO 10303-508
   (non_manifold_surface_shape_representation );
    
   USE FROM aic_edge_based_wireframe                        -- ISO 10303-501
   (edge_based_wireframe_shape_representation );
    
   USE FROM aic_topologically_bounded_surface               -- ISO 10303-511
   (advanced_face );
    
   USE FROM action_schema                                    -- ISO 10303-41
   (action,
    action_method,
    action_relationship,
    action_request_solution,
    executed_action,
    versioned_action_request);
    
   USE FROM approval_schema                                  -- ISO 10303-41
   (approval,
    approval_date_time,
    approval_person_organization);
    
   USE FROM application_context_schema                        -- ISO 10303-41
   (application_context,
    application_protocol_definition);
 
   USE FROM basic_attribute_schema                           -- ISO 10303-41
   (object_role);
   
   USE FROM date_time_schema                                 -- ISO 10303-41
   (calendar_date,
    date_and_time,
    date_time_role,
    ordinal_date,
    week_of_year_and_day_date);
    
   USE FROM document_schema                                  -- ISO 10303-41
   (document,
    document_representation_type,
    document_usage_constraint);
   USE FROM external_reference_schema                        -- ISO 10303-41
   (external_source,
    external_source_relationship,
    externally_defined_item);
    
   USE FROM effectivity_schema                               -- ISO 10303-41
   (effectivity,
    serial_numbered_effectivity);
         
   REFERENCE FROM geometry_schema                             -- ISO 10303-42
   (dummy_gri); 
   
   USE FROM geometric_model_schema
   (faceted_brep,
    geometric_curve_set);
    
   USE FROM geometry_schema                                  -- ISO 10303-42
   (axis1_placement,
    axis2_placement_2d,
    axis2_placement_3d,
    b_spline_curve, 
    b_spline_surface,
    b_spline_curve_with_knots, 
    b_spline_surface_with_knots,
    bezier_curve, 
    bezier_surface,
    bounded_curve,
    bounded_pcurve,
    bounded_surface_curve,
    cartesian_point,
    circle, 
    composite_curve_on_surface,
    conical_surface, 
    curve,
    cylindrical_surface,
    degenerate_pcurve,
    degenerate_toroidal_surface,
    direction,
    elementary_surface,
    ellipse,
    evaluated_degenerate_pcurve,
    geometric_representation_item,
    geometric_representation_context,
    hyperbola, 
    intersection_curve, 
    line,
    oriented_surface,
    parabola,
    plane,
    point_on_curve,
    point_on_surface, 
    quasi_uniform_curve,
    quasi_uniform_surface,
    rational_b_spline_curve,
    rational_b_spline_surface,
    seam_curve,
    spherical_surface,
    surface_of_linear_extrusion,
    surface_of_revolution,         
    toroidal_surface,
    uniform_curve,
    uniform_surface,
    vector);
   
   USE FROM group_schema                                     -- ISO 10303-41
   (group,
    group_relationship);
    
   USE FROM management_resources_schema                      -- ISO 10303-41
   (action_request_assignment,
    action_assignment,
    approval_assignment,
    classification_assignment,
    classification_role,
    date_and_time_assignment,
    document_reference,
    effectivity_assignment,
    external_identification_assignment,
    group_assignment,
    identification_assignment,
    identification_role,
    identification_assignment_relationship,
    organization_assignment,
    person_assignment,
    person_and_organization_assignment);
    
   USE FROM material_property_definition_schema               -- ISO 10303-41
   (property_definition_relationship);
    
   USE FROM measure_schema                                    -- ISO 10303-41
   (amount_of_substance_measure, 
    amount_of_substance_unit,               
    area_measure,                                               
    celsius_temperature_measure,
    conversion_based_unit,                  
    context_dependent_unit,                 
    count_measure,                          
    derived_unit,                           
    electric_current_measure,
    electric_current_unit,                  
    global_unit_assigned_context,
    length_measure,
    length_measure_with_unit,               
    length_unit,                            
    luminous_intensity_measure,
    luminous_intensity_unit,                
    mass_measure,
    mass_measure_with_unit,                 
    mass_unit,                              
    measure_with_unit,
    named_unit,
    plane_angle_measure,
    plane_angle_measure_with_unit,         
    plane_angle_unit,                       
    positive_length_measure,
    positive_plane_angle_measure,
    ratio_measure,
    ratio_unit,                             
    si_unit,                                
    solid_angle_measure,
    solid_angle_measure_with_unit,          
    solid_angle_unit,                          
    thermodynamic_temperature_measure,
    thermodynamic_temperature_unit,         
    time_measure,
    time_unit,                              
    volume_measure);
     
   USE FROM person_organization_schema                       -- ISO 10303-41
   (address, 
    person,
    person_and_organization,
    person_and_organization_role,
    personal_address, 
    organization,
    organizational_address, 
    organizational_project);
       
   USE FROM product_definition_schema                        -- ISO 10303-41
   (product,
    product_category_relationship,
    product_definition,
    product_definition_relationship,
    product_related_product_category);
    
   USE FROM product_property_definition_schema               -- ISO 10303-41
   (characterized_definition ,
    characterized_object,
    product_definition_shape,
    property_definition,
    shape_aspect);
    
   USE FROM product_property_representation_schema           -- ISO 10303-41
   (property_definition_representation,
    shape_definition_representation, 
    shape_representation);

   USE FROM qualified_measure_schema                         -- ISO 10303-41
   (descriptive_representation_item);
   
   USE FROM representation_schema                            -- ISO 10303-43
   (compound_representation_item, 
    global_uncertainty_assigned_context,
    item_defined_transformation,
    list_representation_item,
    mapped_item,
    parametric_representation_context,
    representation,
    representation_item,
    representation_map,
    representation_relationship,
    set_representation_item,
    value_representation_item);
    
   REFERENCE FROM support_resource_schema                    -- ISO 10303-41
   (bag_to_set);
 
   REFERENCE FROM topology_schema                            -- ISO 10303-42
   (dummy_tri);
    
   USE FROM topology_schema                                  -- ISO 10303-42
   (edge,
    edge_curve,
    edge_loop,
    face,
    face_surface,
    oriented_edge,
    oriented_face,
    poly_loop,
    subface,
    vertex_point);

  TYPE action_item = SELECT
    (product,
     product_definition,
     property_definition,
     product_definition_relationship,
     product_definition_shape,
     product_related_product_category,
     action_request_solution,
     executed_action);
  END_TYPE; -- action_item

  TYPE action_request_item = SELECT
    (action,
     executed_action);
  END_TYPE; -- action_request_item

  TYPE approval_item = SELECT
    (product_definition,
     product_definition_shape,
     property_definition,
     product_related_product_category);
  END_TYPE; -- approval_item

  TYPE classification_item = SELECT
    (action,
     action_request_solution,
     applied_action_request_assignment,
     approval,
     axis2_placement_3d,
     compound_representation_item,
     external_source,
     document,
     document_reference,
     edge_curve,
     executed_action,
     group,
     identification_assignment_relationship,
     measure_with_unit,
     product,
     product_definition,
     product_definition_relationship,
     product_definition_shape,
     product_related_product_category,
     property_definition,
     property_definition_representation,
     representation,
     representation_relationship,
     shape_representation,
     vertex_point,
     versioned_action_request);
  END_TYPE;  -- classification_item

  TYPE date_and_time_item = SELECT
    (action_request_solution,
     executed_action,
     versioned_action_request,
     product_definition,
     action);
  END_TYPE;  -- date_and_time_item

  TYPE document_reference_item = SELECT
    (action,
     product,
     property_definition,
     product_definition);
  END_TYPE; -- document_reference_item

  TYPE effectivity_item = SELECT
    (product_definition,
     property_definition,
     product_definition_shape,
     product_related_product_category);
  END_TYPE; -- effectivity_item

  TYPE external_identification_item = SELECT
    (action,
     document,
     product,
     product_definition,
     product_definition_relationship,
     property_definition);
  END_TYPE;  -- external_identification_item

  TYPE group_item = SELECT
     (approval,
      identification_assignment_relationship,
      product_definition,
      product_definition_relationship);
  END_TYPE;  -- group_item

  TYPE identification_item = SELECT
    (action,
     action_request_solution,
     document,
     executed_action,
     product,
     product_definition,
     property_definition,
     product_definition_shape,
     product_related_product_category,
     compound_representation_item,
     product_definition_relationship,
     group,
     versioned_action_request);
  END_TYPE;  -- identification_item

  TYPE organization_item = SELECT
    (document,
     product_definition,							
     property_definition);
  END_TYPE;  -- organization_item

  TYPE person_item = SELECT
    (document);
  END_TYPE;  -- person_item

  TYPE person_and_organization_item = SELECT
    (action_request_solution,
     document,
     executed_action,
     versioned_action_request,
     action);
  END_TYPE;  -- person_and_organization_item

  ENTITY applied_action_assignment
    SUBTYPE OF (action_assignment);
      items : SET [1:?] OF action_item;
  END_ENTITY; -- applied_action_assignment

  ENTITY applied_action_request_assignment
    SUBTYPE OF (action_request_assignment);
      items : SET [1:?] OF action_request_item;
  END_ENTITY;

  ENTITY applied_approval_assignment
    SUBTYPE OF (approval_assignment);
      items : SET [1:?] OF approval_item;
    WHERE
      wr1: NOT((SELF\approval_assignment.role.name = 'proposed alternative')) OR
         (SIZEOF(QUERY( app <*  
         USEDIN (SELF\approval_assignment.assigned_approval, 
         'SHIP_MOULDED_FORM_SCHEMA.APPROVAL_ASSIGNMENT.ASSIGNED_APPROVAL') |
        ('SHIP_MOULDED_FORM_SCHEMA.APPLIED_APPROVAL_ASSIGNMENT' 
        IN TYPEOF (app)) AND
         (app\approval_assignment.role.name='subject')))=1);
  END_ENTITY;

  ENTITY applied_classification_assignment
    SUBTYPE OF (classification_assignment);
      items : SET [1:?] OF classification_item;
  END_ENTITY;

  ENTITY applied_date_and_time_assignment
    SUBTYPE OF (date_and_time_assignment);
      items : SET [1:?] OF date_and_time_item;
  END_ENTITY;

  ENTITY applied_document_reference
    SUBTYPE OF (document_reference);
      items : SET [1:?] OF document_reference_item;
  END_ENTITY;

  ENTITY applied_effectivity_assignment
    SUBTYPE OF (effectivity_assignment);
      items : SET [1:?] OF effectivity_item;
  END_ENTITY; -- applied_effectivity_assignment

  ENTITY applied_external_identification_assignment
    SUBTYPE OF (external_identification_assignment);
      items : SET [1:?] OF external_identification_item;
  END_ENTITY;

  ENTITY applied_group_assignment
    SUBTYPE OF (group_assignment);
      items : SET [1:?] OF group_item;
  END_ENTITY;

  ENTITY applied_identification_assignment
    SUBTYPE OF (identification_assignment);
      items : SET [1:?] OF identification_item;
  END_ENTITY;

  ENTITY applied_organization_assignment
    SUBTYPE OF (organization_assignment);
      items : SET [1:?] OF organization_item;
  END_ENTITY;

  ENTITY applied_person_assignment
    SUBTYPE OF (person_assignment);
      items : SET [1:?] OF person_item;
  END_ENTITY;

  ENTITY applied_person_and_organization_assignment
    SUBTYPE OF (person_and_organization_assignment);
      items : SET [1:?] OF person_and_organization_item;
  END_ENTITY;

  ENTITY class
    SUBTYPE OF (group);
    WHERE
     WR1:(SIZEOF(QUERY ( oa <* USEDIN(SELF,
          'SHIP_MOULDED_FORM_SCHEMA.GROUP_ASSIGNMENT.ASSIGNED_GROUP')|
          NOT ('SHIP_MOULDED_FORM_SCHEMA.APPLIED_GROUP_ASSIGNMENT' IN TYPEOF(oa)))) =0);
  END_ENTITY; -- class


RULE 
action_request_solution_connected_to_action
FOR(action_request_solution, action);
  LOCAL
    t1_set:  SET OF action_request_solution := [];
    t2_set:  SET OF action := [];
    set_3 :  SET OF ACTION_METHOD := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
t1_set := QUERY(a <* action_request_solution | 
          VALUE_IN(WHICH_CLASS(a), 'change plan'));
t2_set := QUERY(b <* action | VALUE_IN(WHICH_CLASS(b), 'change'));
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
   set_3 := [];
   REPEAT j := 1 TO HIINDEX(t2_set);
      set_3 := set_3 + [t2_set[j].chosen_method]; 
   END_REPEAT;
   violate := VALUE_IN(set_3, t1_set[i].method);
END_REPEAT;
WHERE
    WR1: NOT violate;
END_RULE;

RULE action_request_solution_with_identification_assignment
FOR (APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF action_request_solution := [];
    t2_set:  SET OF applied_identification_assignment := [];
    arg_list:  LIST OF STRING := [ 'change plan'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
        c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME =  arg_LIST[j]);
   END_REPEAT;

  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;


    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
'SHIP_MOULDED_FORM_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
     t2_set := QUERY ( j <* t2_set | j.role.name = 'globally unambiguous identifier');
      violation := NOT (SIZEOF(t2_set) = 1);
          END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE action_with_identification_assignment
FOR (APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF action := [];
    t2_set:  SET OF applied_identification_assignment := [];
   arg_list:  LIST OF STRING := [ 'change', 'versionable object change event', 'check'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* get all classification_assignment instances *)
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
        c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME =  arg_LIST[j]);
   END_REPEAT;

  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;


    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
  'SHIP_MOULDED_FORM_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
     t2_set := QUERY ( j <* t2_set | j.role.name = 'globally unambiguous identifier');
       violation := NOT (SIZEOF(t2_set) = 1);
    END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE alternative_version_relationship_has_mandatory_description
FOR (identification_assignment_relationship);
LOCAL
t1_set: SET OF identification_assignment_relationship := [];
violate: LOGICAL := FALSE;
END_LOCAL;
 (* get all instances of identification_assignment_relationship *)
 (* being classified as 'alternative version relationship' *)
 t1_set := QUERY(i <* identification_assignment_relationship |
   VALUE_IN(WHICH_CLASS(i), 'alternative version relationship'));
 (* from all instances found above, find those for which attribute      description is not instantiated *)
violate := (SIZEOF(QUERY(k <* t1_set | NOT EXISTS (k.description))) > 0);
WHERE
wr1: NOT violate;
END_RULE;

RULE alternative_version_relationship_has_unique_versions
FOR (identification_assignment_relationship);
LOCAL
t1_set: SET OF identification_assignment_relationship := [];
violate: LOGICAL := FALSE;
END_LOCAL;
(* get all instances of identification_assignment_relationship with *)
(* class 'alternative version relationship' *)
t1_set := QUERY(a <* identification_assignment_relationship |
VALUE_IN(WHICH_CLASS(a), 'alternative version relationship'));
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
violate :=
( t1_set[i].relating_identification_assignment.assigned_id =
t1_set[i].related_identification_assignment.assigned_id );
END_REPEAT;
WHERE
wr1: NOT violate;
END_RULE;

RULE alternative_version_relationship_versionable_object
FOR (applied_identification_assignment,
     identification_assignment_relationship);
LOCAL
 violate: LOGICAL := FALSE;
END_LOCAL;

(* get all instances of applied_identification_assignment *)
REPEAT i := 1 TO HIINDEX(applied_identification_assignment) BY 1 WHILE NOT violate;

 IF ( (SIZEOF(USEDIN(applied_identification_assignment[i],
            ('SHIP_MOULDED_FORM_SCHEMA.IDENTIFICATION_ASSIGNMENT_RELATIONSHIP.'
             +'RELATING_IDENTIFICATION_ASSIGNMENT'))) > 0) OR
      (SIZEOF(USEDIN(applied_identification_assignment[i],
            ('SHIP_MOULDED_FORM_SCHEMA.IDENTIFICATION_ASSIGNMENT_RELATIONSHIP.'
             +'RELATED_IDENTIFICATION_ASSIGNMENT'))) > 0) ) THEN
  REPEAT j := 1 to HIINDEX(applied_identification_assignment[i].items) BY 1 WHILE NOT violate;
   violate := NOT VALUE_IN(which_class(applied_identification_assignment[i].items[j]),'versionable object');
  END_REPEAT;
 END_IF;

END_REPEAT;

WHERE
wr1: NOT violate;
END_RULE;

RULE 
approval_event_with_approval_person_organization
FOR(approval);
LOCAL
    t1_set:  SET OF approval := [];
    t2_set:  SET OF approval_person_organization := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
  t1_set := QUERY(i <* approval | 
            VALUE_IN(WHICH_CLASS(i), 'approval event')); 
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
    t2_set := bag_to_set(USEDIN(t1_set[i],
      'SHIP_MOULDED_FORM_SCHEMA.APPROVAL_PERSON_ORGANIZATION.' + 
      'AUTHORIZED_APPROVAL'));
    violate := NOT (SIZEOF(t2_set) = 1);
  END_REPEAT;
  WHERE
    WR1: NOT violate;
END_RULE;

RULE 
approval_event_with_approval_date_time
FOR(approval);
LOCAL
    t1_set:  SET OF approval := [];
    t2_set:  SET OF approval_date_time := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
  t1_set := QUERY(i <* approval | 
    VALUE_IN(WHICH_CLASS(i), 'approval event')); 
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
    t2_set := bag_to_set(USEDIN(t1_set[i], 
      'SHIP_MOULDED_FORM_SCHEMA.APPROVAL_DATE_TIME.' + 
      'DATED_APPROVAL'));
    violate := NOT (SIZEOF(t2_set) = 1);
  END_REPEAT;
  WHERE
    WR1: NOT violate;
END_RULE;

RULE 
approval_history_approves_same_definition
FOR (applied_group_assignment, applied_approval_assignment);
LOCAL
    t2_set:  SET OF APPLIED_GROUP_ASSIGNMENT := [];
    t3_set:  SET OF approval :=[];   
    t4_set:  SET OF group_item :=[];   
    t5_set:  SET OF APPLIED_APPROVAL_ASSIGNMENT := [];
    violate: LOGICAL := FALSE;
END_LOCAL;
t2_set := QUERY(a <* APPLIED_GROUP_ASSIGNMENT | 
                VALUE_IN(WHICH_CLASS(a.ASSIGNED_GROUP), 
                'approval history'));
t3_set := QUERY(b <* t2_set[1].items | 
  'SHIP_MOULDED_FORM_SCHEMA.APPROVAL' IN TYPEOF(b));
t4_set := QUERY(b <* t2_set[1].items | 
  VALUE_IN(WHICH_CLASS(b), 'DEFINITION'));
violate := NOT(SIZEOF(t4_set) = 1);

REPEAT i := 1 TO HIINDEX(t3_set) WHILE NOT violate;
    t5_set := QUERY(a <* APPLIED_APPROVAL_ASSIGNMENT | 
    (a.ASSIGNED_APPROVAL = t3_set[i]) AND 
    (NOT (VALUE_IN(a.items, t4_set[1]))));
   violate := (SIZEOF(t5_set) > 0);
  END_REPEAT;
WHERE
    WR1: NOT violate; 
    wr2: (SIZEOF(t4_set) = 1);
END_RULE;

RULE 
approval_history_has_at_least_one_member
FOR (group, applied_group_assignment);
LOCAL
    t1_set:  SET OF GROUP := [];
    t2_set:  SET OF APPLIED_GROUP_ASSIGNMENT := [];
    violate: LOGICAL := FALSE;
END_LOCAL;
  T1_set := QUERY(i <* group | VALUE_IN(WHICH_CLASS(i), 
  'approval history')); 
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
    t2_set := QUERY(a <* APPLIED_GROUP_ASSIGNMENT | 
      a.ASSIGNED_GROUP = t1_set[i]);
 
    violate := NOT(SIZEOF(t2_set) = 1);
  END_REPEAT;
WHERE
    WR1: NOT violate; 
END_RULE;

RULE  approvals_references_approval_history
FOR(applied_group_assignment, group);
  LOCAL
    t1_set:  SET OF group := [];
    a_set:  SET OF applied_group_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;


t1_set := QUERY(a <* group | VALUE_IN(WHICH_CLASS(a), 'approval history'));


REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
   a_set := QUERY(b <* applied_group_assignment | 
       NOT ((b.assigned_group = t1_set[i]) AND (b.role.name = 'approvals')));


    violate := SIZEOF(a_set) > 0;
  END_REPEAT;

WHERE
    wr1: NOT violate;
END_RULE;

RULE  
author_for_change_plan
FOR(applied_person_and_organization_assignment, action_request_solution);
  LOCAL
    t1_set:  SET OF action_request_solution := [];
    a_set:  SET OF applied_person_and_organization_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
   t1_set := QUERY(a <* action_request_solution | 
             VALUE_IN(WHICH_CLASS(a), 'change plan'));
 
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
  a_set := QUERY(b <* applied_person_and_organization_assignment | 
               (VALUE_IN(b.items, t1_set[i]) AND 
               (b.role.name = 'author')));
    violate := SIZEOF(a_set) <> 1;
  END_REPEAT;
  WHERE
    WR1: NOT violate;
END_RULE;

RULE  
author_for_change_realisation
FOR(applied_person_and_organization_assignment,executed_action);
  LOCAL
    t1_set:  SET OF executed_action := [];
    a_set:  SET OF applied_person_and_organization_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
   t1_set := QUERY(a <* executed_action | 
             VALUE_IN(WHICH_CLASS(a), 'change realization'));
 
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
  a_set := QUERY(b <* applied_person_and_organization_assignment | 
               (VALUE_IN(b.items, t1_set[i]) AND 
               (b.role.name = 'author')));
    violate := SIZEOF(a_set) <> 1;
  END_REPEAT;
  WHERE
    WR1: NOT violate;
END_RULE;

RULE  
author_for_change_request
FOR(applied_person_and_organization_assignment, versioned_action_request);
  LOCAL
    t1_set:  SET OF versioned_action_request := [];
    a_set:  SET OF applied_person_and_organization_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
   t1_set := QUERY(a <* versioned_action_request | 
             VALUE_IN(WHICH_CLASS(a), 'change request'));
 
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
  a_set := QUERY(b <* applied_person_and_organization_assignment | 
               (VALUE_IN(b.items, t1_set[i]) AND 
               (b.role.name = 'author')));
    violate := SIZEOF(a_set) <> 1;
  END_REPEAT;
  WHERE
    WR1: NOT violate;
END_RULE;

RULE  
caused_by_for_check
FOR(applied_person_and_organization_assignment, action);
  LOCAL
    t1_set:  SET OF action := [];
    a_set:  SET OF applied_person_and_organization_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
   t1_set := QUERY(a <* action | VALUE_IN(WHICH_CLASS(a), 'check'));
 
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
  a_set := QUERY(b <* applied_person_and_organization_assignment | 
               (VALUE_IN(b.items, t1_set[i]) AND 
               (b.role.name = 'caused by')));
    violate := SIZEOF(a_set) <> 1;
  END_REPEAT;
  WHERE
    WR1: NOT violate;
END_RULE;

RULE  
caused_by_for_envisaged_version_creation
FOR(applied_person_and_organization_assignment, action);
  LOCAL
    t1_set:  SET OF action := [];
    a_set:  SET OF applied_person_and_organization_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
   t1_set := QUERY(a <* action | 
             VALUE_IN(WHICH_CLASS(a), 'envisaged version creation'));
 
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
  a_set := QUERY(b <* applied_person_and_organization_assignment | 
               (VALUE_IN(b.items, t1_set[i]) AND 
               (b.role.name = 'caused by')));
    violate := SIZEOF(a_set) <> 1;
  END_REPEAT;
  WHERE
    WR1: NOT violate;
END_RULE;

RULE  
caused_by_for_version_creation
FOR(applied_person_and_organization_assignment, action);
  LOCAL
    t1_set:  SET OF action := [];
    a_set:   SET OF applied_person_and_organization_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
   t1_set := QUERY(a <* action | 
             VALUE_IN(WHICH_CLASS(a), 'version creation'));
 
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
  a_set := QUERY(b <* applied_person_and_organization_assignment | 
               (VALUE_IN(b.items, t1_set[i]) AND 
               (b.role.name = 'caused by')));
    violate := SIZEOF(a_set) <> 1;
  END_REPEAT;
  WHERE
    WR1: NOT violate;
END_RULE;

RULE  
caused_by_for_version_deletion
FOR(applied_person_and_organization_assignment, action);
  LOCAL
    t1_set:  SET OF action := [];
    a_set:  SET OF applied_person_and_organization_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
   t1_set := QUERY(a <* action | 
             VALUE_IN(WHICH_CLASS(a), 'version deletion'));
 
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
  a_set := QUERY(b <* applied_person_and_organization_assignment | 
               (VALUE_IN(b.items, t1_set[i]) AND 
               (b.role.name = 'caused by')));
    violate := SIZEOF(a_set) <> 1;
  END_REPEAT;
  WHERE
    WR1: NOT violate;
END_RULE;

RULE  
caused_by_for_version_modification
FOR(applied_person_and_organization_assignment, action);
  LOCAL
    t1_set:  SET OF action := [];
    a_set:   SET OF applied_person_and_organization_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
   t1_set := QUERY(a <* action | 
             VALUE_IN(WHICH_CLASS(a), 'version modification'));
 
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
  a_set := QUERY(b <* applied_person_and_organization_assignment | 
               (VALUE_IN(b.items, t1_set[i]) AND 
               (b.role.name = 'caused by')));
    violate := SIZEOF(a_set) <> 1;
  END_REPEAT;
  WHERE
    WR1: NOT violate;
END_RULE;

RULE  
caused_when_for_check
FOR(applied_date_and_time_assignment, action);
  LOCAL
    t1_set:  SET OF action := [];
    a_set:  SET OF applied_date_and_time_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
   t1_set := QUERY(a <* action | VALUE_IN(WHICH_CLASS(a), 'check'));
 
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
  a_set := QUERY(b <* applied_date_and_time_assignment | 
               (VALUE_IN(b.items, t1_set[i]) AND 
               (b.role.name = 'caused when')));
    violate := SIZEOF(a_set) <> 1;
  END_REPEAT;
  WHERE
    WR1: NOT violate;
END_RULE;

RULE  
caused_when_for_envisaged_version_creation
FOR(applied_date_and_time_assignment, action);
  LOCAL
    t1_set:  SET OF action := [];
    a_set:  SET OF applied_date_and_time_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
   t1_set := QUERY(a <* action | VALUE_IN(WHICH_CLASS(a), 
             'envisaged version creation'));
 
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
  a_set := QUERY(b <* applied_date_and_time_assignment | 
               (VALUE_IN(b.items, t1_set[i]) AND 
               (b.role.name = 'caused when')));
    violate := SIZEOF(a_set) <> 1;
  END_REPEAT;
  WHERE
    WR1: NOT violate;
END_RULE;

RULE  
caused_when_for_version_creation
FOR(applied_date_and_time_assignment, action);
  LOCAL
    t1_set:  SET OF action := [];
    a_set:  SET OF applied_date_and_time_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
   t1_set := QUERY(a <* action | 
             VALUE_IN(WHICH_CLASS(a), 'version creation'));
 
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
  a_set := QUERY(b <* applied_date_and_time_assignment | 
               (VALUE_IN(b.items, t1_set[i]) AND 
               (b.role.name = 'caused when')));
    violate := SIZEOF(a_set) <> 1;
  END_REPEAT;
  WHERE
    WR1: NOT violate;
END_RULE;

RULE  
caused_when_for_version_modification
FOR(applied_date_and_time_assignment, action);
  LOCAL
    t1_set:  SET OF action := [];
    a_set:  SET OF applied_date_and_time_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
   t1_set := QUERY(a <* action | 
             VALUE_IN(WHICH_CLASS(a), 'version modification'));
 
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
  a_set := QUERY(b <* applied_date_and_time_assignment | 
               (VALUE_IN(b.items, t1_set[i]) AND 
               (b.role.name = 'caused when')));
    violate := SIZEOF(a_set) <> 1;
  END_REPEAT;
  WHERE
    WR1: NOT violate;
END_RULE;

RULE  
caused_when_for_version_deletion
FOR(applied_date_and_time_assignment, action);
  LOCAL
    t1_set:  SET OF action := [];
    a_set:  SET OF applied_date_and_time_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
   t1_set := QUERY(a <* action | 
             VALUE_IN(WHICH_CLASS(a), 'version deletion'));
 
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
  a_set := QUERY(b <* applied_date_and_time_assignment | 
               (VALUE_IN(b.items, t1_set[i]) AND 
               (b.role.name = 'caused when')));
    violate := SIZEOF(a_set) <> 1;
  END_REPEAT;
  WHERE
    WR1: NOT violate;
END_RULE;

RULE centre_location_compound_representation_has_specified_name
FOR (APPLIED_CLASSIFICATION_ASSIGNMENT);
LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF Compound_representation_item := [];
    t2_set:  SET OF representation_item := [];
    arg_list:  LIST OF STRING := ['longitudinal location', 'transversal location', 'vertical location'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* get all classification_assignment instances with id 'centre location' *)
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.ASSIGNED_CLASS.NAME = 'centre location');

  (* get all instances of compound_representation_item that have class id 'centre location' *)
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  (* iterate over all compound_representation_item found above; stop, if one of
     them has not exactly one rep_item for each name in the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(t1_set) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
        t2_set := t1_set[i].item_element; 
   violation := (SIZEOF(QUERY(items <* t2_set | items.name = arg_list[j])) <> 1);
 END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;

END_RULE;

RULE
change_impact_with_versionable_object_change_event
FOR(applied_action_request_assignment);
  LOCAL
    t1_set:  SET OF applied_action_request_assignment := [];
    a_set:   SET OF action := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
  
   t1_set := QUERY(b <* applied_action_request_assignment | 
                   (b.role.name= 'change impact'));
 
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
          a_set := QUERY(b <* t1_set[i].items | 
          ('SHIP_MOULDED_FORM_SCHEMA.ACTION' IN TYPEOF(b)) AND
             VALUE_IN(WHICH_CLASS(b), 'versionable object change event'));
         violate := SIZEOF(a_set) = 0;
      END_REPEAT;

WHERE
    WR1: NOT violate;
END_RULE;

RULE 
change_plan_has_mandatory_attribute_description
FOR (action_request_solution);
LOCAL
    t1_set:  SET OF action_request_solution := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
  t1_set := QUERY(i <* action_request_solution | 
  VALUE_IN(WHICH_CLASS(i), 'change plan')); 
  violate := (SIZEOF(QUERY(k <* t1_set | 
  NOT EXISTS (k.description))) > 0);
WHERE
    WR1: NOT violate; 
END_RULE;

RULE class_and_statutory_designation_has_properties
FOR (property_definition_representation, 
applied_classification_assignment);
LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_list: LIST OF product_definition := [];
    t2_set:  SET OF property_definition_representation := [];
    t3_list: LIST OF property_definition := [];
    t4_list: LIST OF product_definition := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'class and statutory designation');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_list := t1_list + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  t2_set:= QUERY(i <* PROPERTY_DEFINITION_REPRESENTATION |
                   i.NAME = 'class and statutory designation');
  REPEAT i := 1 TO HIINDEX(t2_set);
    t3_list := t3_list + t2_set[i].definition;
  END_REPEAT;
  REPEAT i := 1 TO HIINDEX(t3_list);
    t4_list := t4_list + t3_list[i].definition;
  END_REPEAT;
  violation := t1_list <> t4_list;
  WHERE
    WR1: NOT violation;
  
END_RULE;

RULE class_notation_with_named_representation_items
FOR (representation);
LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['class notations hull', 
                                  'class notations machinery'];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
             'SHIP_MOULDED_FORM_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
             'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 'class notation')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) < 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    WR1: NOT violation;
END_RULE;

RULE class_parameters_has_properties
FOR (property_definition_representation, 
applied_classification_assignment);
LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set: LIST OF product_definition := [];
    t2_set:  SET OF property_definition_representation := [];
    t3_set: LIST OF property_definition := [];
    t4_set: LIST OF product_definition := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'class parameters');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  t2_set:= QUERY(i <* PROPERTY_DEFINITION_REPRESENTATION |
                   i.NAME = 'class parameters');
  REPEAT i := 1 TO HIINDEX(t2_set);
    t3_set := t3_set + t2_set[i].definition;
  END_REPEAT;
  REPEAT i := 1 TO HIINDEX(t3_set);
    t4_set := t4_set + t3_set[i].definition;
  END_REPEAT;
  violation := t1_set <> t4_set;
  WHERE
    WR1: NOT violation;
  
END_RULE;

RULE
compound_representation_item_with_hydrostatic_properties
FOR (APPLIED_CLASSIFICATION_ASSIGNMENT);
LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF COMPOUND_REPRESENTATION_ITEM := [];
    t2_set:  LIST OF representation_item := [];
    arg_list:  LIST OF STRING := ['hydrostatic property value'];
    violation: LOGICAL := FALSE;
  END_LOCAL;


  (* get all classification_assignment instances with id 'hydrostatic properties for constant floating position' *)
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.Assigned_class.name = 'hydrostatic properties for constant floating position');

  (* get all instances of compound_representation_item that have class id 'hydrostatic properties for constant floating position' *)
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  (* iterate over all compound_representation_item found above; stop, if one of
     them has not one or more rep_item for each name in the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(t1_set) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
        t2_set := t1_set[i].item_element; 
   violation := (SIZEOF(QUERY(items <* t2_set | items.name = arg_list[j])) < 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;

END_RULE;

RULE compound_representation_item_with_class_id_knot

FOR (APPLIED_CLASSIFICATION_ASSIGNMENT);
LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT:= [];
    c_a_set2 : SET OF APPLIED_CLASSIFICATION_ASSIGNMENT:= [];
    t1_set:  SET OF COMPOUND_REPRESENTATION_ITEM := [];
    t2_set:  SET OF COMPOUND_REPRESENTATION_ITEM := [];
    t3_set:  SET OF REPRESENTATION_ITEM := [];  
    l_rep_item : list_representation_item;
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* get all classification_assignment instances with id 'knot' *)
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.ASSIGNED_CLASS.NAME = 'knot');

  (* get all instances of compound_representation_item that have class id 'knot' *)
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

(* get all classification_assignment instances with id 'ship curve' *)
  c_a_set2 := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.ASSIGNED_CLASS.NAME = 'ship curve');

  (* get all instances of compound_representation_item that have class id 'ship curve' *)
  REPEAT i := 1 TO HIINDEX(c_a_set2);
    REPEAT j := 1 TO HIINDEX(c_a_set2[i].items);
      t2_set := t2_set + c_a_set2[i].items[j];
    END_REPEAT;
  END_REPEAT;

  (* iterate over all compound_representation_item found in the first list; then iterate
   over all item_element for each compound_representation_item,
   check that the intersection of these item_elements and the second list of
   compound_representation_item is greater then or equal to 2
   *)
 REPEAT i:=1 TO HIINDEX(t1_set) WHILE (NOT violation);
   l_rep_item := t1_set[i].item_element;
      REPEAT j := 1 TO HIINDEX(t1_set[i].item_element);
          t3_set := t3_set + l_rep_item[j];
      END_REPEAT;
   violation := (SIZEOF(t3_set * t2_set) < 2);
   t3_set:= [];
  END_REPEAT;

  WHERE 
    wr1: NOT violation;

END_RULE;

RULE  compound_representation_item_with_section_identifier
FOR(APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF compound_representation_item := [];
    t2_set:  SET OF applied_identification_assignment := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* get all classification_assignment instances with id 'section of offset point table' *)
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.ASSIGNED_CLASS.NAME = 'section of offset point table');

  (* get all instances of compound_representation_item that have class id 'section of offset point table' *)
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  (* for all instances of compound_representation_item in t1_set:
     get the applied_identification_assignment instances that are referencing a compound_representation_item instance via items,
     filter out those applied_identification_assignment instances whose attribute role has the value 'section identifier'
     check if their number equals 1
   *)
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_MOULDED_FORM_SCHEMA.' + 'APPLIED_IDENTIFICATION_ASSIGNMENT' + '.ITEMS'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.role.name = 'section identifier')) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE  
date_time_for_change_plan
FOR(applied_date_and_time_assignment,  action_request_solution);
  LOCAL
    t1_set:  SET OF action_request_solution := [];
    a_set:  SET OF applied_date_and_time_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
   t1_set := QUERY(a <* action_request_solution | 
             VALUE_IN(WHICH_CLASS(a), 'change plan'));
 
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
  a_set := QUERY(b <* applied_date_and_time_assignment | 
               (VALUE_IN(b.items, t1_set[i]) AND 
               (b.role.name = 'date time')));
    violate := SIZEOF(a_set) <> 1;
  END_REPEAT;
  WHERE
    WR1: NOT violate;
END_RULE;

RULE  
date_time_for_change_request
FOR(applied_date_and_time_assignment,  versioned_action_request);
  LOCAL
    t1_set:  SET OF versioned_action_request := [];
    a_set:  SET OF applied_date_and_time_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
   t1_set := QUERY(a <* versioned_action_request | 
             VALUE_IN(WHICH_CLASS(a), 'change request'));
 
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
  a_set := QUERY(b <* applied_date_and_time_assignment | 
               (VALUE_IN(b.items, t1_set[i]) AND 
               (b.role.name = 'date time')));
    violate := SIZEOF(a_set) <> 1;
  END_REPEAT;
  WHERE
    WR1: NOT violate;
END_RULE;

RULE  
date_time_for_change_realisation
FOR(applied_date_and_time_assignment, executed_action);
  LOCAL
    t1_set:  SET OF executed_action := [];
    a_set:  SET OF applied_date_and_time_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
   t1_set := QUERY(a <* executed_action | 
             VALUE_IN(WHICH_CLASS(a), 'change realisation'));
 
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
  a_set := QUERY(b <* applied_date_and_time_assignment | 
               (VALUE_IN(b.items, t1_set[i]) AND 
               (b.role.name = 'date time')));
    violate := SIZEOF(a_set) <> 1;
  END_REPEAT;
  WHERE
    WR1: NOT violate;
END_RULE;

RULE document_has_at_least_one_references
FOR(document);
  LOCAL
    t1_set:  SET OF document := [];
    t2_set:  SET OF document_representation_type := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
  t1_set := QUERY(i <* document | VALUE_IN(WHICH_CLASS(i), 
                                   'document')); 
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
    t2_set := bag_to_set(USEDIN(t1_set[i], 
      'SHIP_MOULDED_FORM_SCHEMA.DOCUMENT_REPRESENTATION_TYPE.'+
      'REPRESENTED_DOCUMENT'));
    violate := SIZEOF(t2_set) < 1;
END_REPEAT;
  WHERE
    WR1: NOT violate;
END_RULE;

RULE document_has_exactly_one_author
FOR(document);
  LOCAL
    bag_1: BAG OF applied_person_assignment := [];
    bag_2: BAG OF applied_person_and_organization_assignment := [];
    bag_3: BAG OF applied_organization_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
REPEAT i := 1 TO SIZEOF(document) WHILE (NOT violate);
  bag_1 := USEDIN(document[i], 'SHIP_MOULDED_FORM_SCHEMA.' + 
         'APPLIED_PERSON_ASSIGNMENT.ITEMS'); 
     bag_1 := QUERY( assign <* bag_1 | assign.role.name = 'author');
   bag_2 := USEDIN(document[i], 'SHIP_MOULDED_FORM_SCHEMA.' + 
         'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS');
  bag_2 := QUERY( assign <* bag_2 | assign.role.name = 'author');
  bag_3 := USEDIN(document[i], 'SHIP_MOULDED_FORM_SCHEMA.' + 
         'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS');
  bag_3 := QUERY( assign <* bag_3 | assign.role.name = 'author');
    violate := NOT ((SIZEOF( bag_1 ) + SIZEOF( bag_2 )+ SIZEOF( bag_3 ))= 1);
END_REPEAT;
  WHERE
    WR1: NOT violate;
END_RULE;

RULE document_reference_with_address_has_at_least_one_references
FOR(document);
  LOCAL
    t1_set:  SET OF document := [];
    t2_set:  SET OF applied_external_identification_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
t1_set := QUERY(i <* document | VALUE_IN(WHICH_CLASS(i), 
                                'document reference with address')); 
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
    t2_set := bag_to_set(USEDIN(t1_set[i], 
  'SHIP_MOULDED_FORM_SCHEMA.APPLIED_EXTERNAL_IDENTIFICATION_ASSIGNMENT.ITEMS'));
    violate := SIZEOF(t2_set) < 1;
END_REPEAT;
  WHERE
    WR1: NOT violate;
END_RULE;

RULE 
envisaged_version_creation_has_mandatory_attribute_description
FOR (action);
LOCAL
    t1_set:  SET OF action := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
   t1_set := QUERY(i <* action | VALUE_IN(WHICH_CLASS(i), 
   'envisaged version creation')); 
   violate := (SIZEOF(QUERY(k <* t1_set | 
   NOT EXISTS (k.description))) > 0);
WHERE
    WR1: NOT violate; 
END_RULE;

RULE executed_action_with_identification_assignment
FOR (APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF executed_action := [];
    t2_set:  SET OF applied_identification_assignment := [];
    arg_list:  LIST OF STRING := [ 'change realization'];
    violation: LOGICAL := FALSE;
  END_LOCAL;


    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
        c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME =  arg_LIST[j]);
   END_REPEAT;

  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;


    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
'SHIP_MOULDED_FORM_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
	t2_set := QUERY ( j <* t2_set | j.role.name = 'globally unambiguous identifier');
      	violation := NOT (SIZEOF(T2_SET) = 1);
    END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE external_instance_reference_has_same_identifier FOR (
             applied_external_identification_assignment);
LOCAL
 violation    : LOGICAL := FALSE;
 extref_set   : SET OF applied_external_identification_assignment := [];
 aia_set      : SET OF applied_identification_assignment := [];
END_LOCAL;

	 extref_set := QUERY ( i <* applied_external_identification_assignment | (i.role.name = 'external instance reference') );

 REPEAT i := 1 TO HIINDEX(extref_set) BY 1 WHILE NOT violation;
   aia_set := USEDIN(extref_set[i].items[1],
       'SHIP_MOULDED_FORM_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS');
   violation := NOT (aia_set[1].assigned_id = extref_set[i].assigned_id);
 END_REPEAT;
 WHERE
   wr1: NOT violation;
 END_RULE; -- external_instance_reference_has_same_identifier

RULE floating_position_compound_representation_with_name
FOR (APPLIED_CLASSIFICATION_ASSIGNMENT);
LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF Compound_representation_item := [];
    t2_set:  SET OF representation_item := [];
    arg_list:  LIST OF STRING := ['moulded form displacement', 'draught at amidships', 'length of waterline', 'breadth of waterline', 'angle of trim', 'angle of heel'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* get all classification_assignment instances with id 'floating position' *)
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.Assigned_class.name = 'floating position');

  (* get all instances of compound_representation_item that have class id 'floating position' *)
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  (* iterate over all compound_representation_item found above; stop, if one of
     them has not exactly one rep_item for each name in the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(t1_set) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
        t2_set := t1_set[i].item_element; 
  violation := (SIZEOF(QUERY(items <* t2_set | items.name = arg_list[j])) <> 1);
 END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;

END_RULE;

RULE global_axis_placement_has_properties
FOR (property_definition_representation, 
group, applied_classification_assignment);
LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set: LIST OF product_definition := [];
    t2_set: SET OF property_definition_representation := [];
    t3_set: LIST OF property_definition := [];
    t4_set: LIST OF product_definition := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'global axis placement');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  t2_set:= QUERY(i <* PROPERTY_DEFINITION_REPRESENTATION |
                   i.NAME = 'global axis placement');
  REPEAT i := 1 TO HIINDEX(t2_set);
    t3_set := t3_set + t2_set[i].definition;
  END_REPEAT;
  REPEAT i := 1 TO HIINDEX(t3_set);
    t4_set := t4_set + t3_set[i].definition;
  END_REPEAT;
  violation := t1_set <> t4_set;
  WHERE
    WR1: NOT violation;
  
END_RULE;

RULE global_id_is_unique 
FOR (APPLIED_IDENTIFICATION_ASSIGNMENT);
  LOCAL
    set_1:  SET OF APPLIED_IDENTIFICATION_ASSIGNMENT:= [];
    bag_2:     BAG OF STRING := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* get all instances of guid  *)


  set_1 := QUERY(i <* APPLIED_IDENTIFICATION_ASSIGNMENT |
                          (i.role.name = 'globally unambiguous identifier'));

REPEAT i := 1 TO HIINDEX(set_1);
    bag_2 := bag_2 + [set_1[i].assigned_id];

END_REPEAT;
violation := SIZEOF (QUERY(i <* set_1 | (SIZEOF(i.items) = 1))) <> SIZEOF(set_1);

WHERE
    WR1: VALUE_UNIQUE(bag_2);
    WR2: NOT violation;
END_RULE;

RULE hull_moulded_form_design_parameter_with_class_references 
FOR(APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF property_definition := [];
    t2_set:  SET OF property_definition_representation := [];
    t3_set:  SET OF representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* get all classification_assignment instances with id 
  'hull moulded form design parameter' *)
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.ASSIGNED_CLASS.NAME = 'hull moulded form design parameter');

  (* get all instances of property_definition that have class id 
  'hull moulded form design parameter' *)
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  (* for all instances of property_definition in t1_set:
     get the property_definition_representation instances that are       referencing a property_definition instance via definition, get those property_definition_representation.used_representation instances whose       class id is 'midship_tumble' and make sure their number is less than or equal to 1
   *)
 REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i],
   'SHIP_MOULDED_FORM_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
   'DEFINITION'));
 
   REPEAT j := 1 to HIINDEX(t2_set);
        t3_set := t3_set + t2_set[j].used_representation;
   END_REPEAT;   
          
   violation := SIZEOF(QUERY(t2_inst <* t3_set | 'midship tumble' IN WHICH_CLASS(t2_inst))) > 1;
 END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE 
hydrostatic_properties_with_specified_class
FOR (APPLIED_CLASSIFICATION_ASSIGNMENT);
LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    c_a_set2 : SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF COMPOUND_REPRESENTATION_ITEM := [];
    t2_set:  SET OF COMPOUND_REPRESENTATION_ITEM := [];
    t3_set:  SET OF REPRESENTATION_ITEM := [];    
    l_rep_item : list_representation_item;
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* get all classification_assignment instances with id 'hydrostatic properties for constant floating position' *)
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.Assigned_class.name = 'hydrostatic properties for constant floating position');

  (* get all instances of compound_representation_item that have class id 'hydrostatic properties for constant floating position' *)
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

(* get all classification_assignment instances with id 'floating position' *)
  c_a_set2 := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.Assigned_class.name = 'floating position');

  (* get all instances of compound_representation_item that have class id 'floating position' *)
  REPEAT i := 1 TO HIINDEX(c_a_set2);
    REPEAT j := 1 TO HIINDEX(c_a_set2[i].items);
      t2_set := t2_set + c_a_set2[i].items[j];
    END_REPEAT;
  END_REPEAT;

  (* iterate over all compound_representation_item found in the first list; then iterate
   over all item_element for each compound_representation_item,
   check that the intersection of these item_elements and and the second list of
   compound_representation_item is equal 1
   *)
  REPEAT i:=1 TO HIINDEX(t1_set) WHILE (NOT violation);
     l_rep_item := t1_set[i].item_element;
     REPEAT j := 1 TO HIINDEX(t1_set[i].item_element);
      t3_set := t3_set + l_rep_item[j];
     END_REPEAT;
     violation := (SIZEOF(t3_set * t2_set) <> 1);
     t3_set:= [];
  END_REPEAT;

  WHERE 
    wr1: NOT violation;

END_RULE;

RULE hydrostatic_property_with_specified_name
FOR (APPLIED_CLASSIFICATION_ASSIGNMENT);
LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF Compound_representation_item := [];
    t2_set:  SET OF representation_item := [];
    arg_list:  LIST OF STRING := ['property type'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* get all classification_assignment instances with id 'hydrostatic property' *)
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.Assigned_class.name = 'hydrostatic property');

  (* get all instances of compound_representation_item that have class id 'hydrostatic property' *)
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  (* iterate over all compound_representation_item found above; stop, if one of
     them has not exactly one rep_item for each name in the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(t1_set) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
        t2_set := t1_set[i].item_element; 
   violation := (SIZEOF(QUERY(items <* t2_set | items.name = arg_list[j])) <> 1);
 END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;

END_RULE;

RULE identification_role_optional_attribute_description_required
FOR (identification_role);
WHERE
 WR1: SIZEOF(QUERY(i <* identification_role | 
      ((i.name = 'external reference') 
      AND NOT(EXISTS (i.description))))) = 0;
END_RULE;

RULE  
initiator_for_change_request
FOR(applied_person_and_organization_assignment,
    versioned_action_request);
  LOCAL
    t1_set:  SET OF versioned_action_request := [];
    a_set:  SET OF applied_person_and_organization_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
   t1_set := QUERY(a <* versioned_action_request | 
             VALUE_IN(WHICH_CLASS(a), 'change request'));
 
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
  a_set := QUERY(b <* applied_person_and_organization_assignment | 
               (VALUE_IN(b.items, t1_set[i]) AND 
               (b.role.name = 'initiator')));
    violate := SIZEOF(a_set) <> 1;
  END_REPEAT;
  WHERE
    WR1: NOT violate;
END_RULE;

RULE mandatory_entity_type_for_external_instance_reference  
FOR(external_source, 
    external_source_relationship);
  LOCAL
    bag_1: BAG OF external_source := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
bag_1 := QUERY(a <* external_source | a.description = 'schema name');
 
REPEAT i := 1 TO SIZEOF(bag_1) WHILE (NOT violate);
violate := (SIZEOF( QUERY(
    a <* external_source_relationship | (a.relating_source :=: bag_1[i]) AND 
           (a.related_source.description = 'entity type'))) = 0 );
END_REPEAT;
  WHERE
    WR1: NOT violate;
END_RULE;

RULE members_is_referenced_by_at_least_one_revision
FOR(applied_group_assignment, group);
  LOCAL
    t1_set:  SET OF group := [];
    a_set:  SET OF applied_group_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;

t1_set := QUERY(a <* group | VALUE_IN(WHICH_CLASS(a), 'revision'));

REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
   a_set := QUERY(b <* applied_group_assignment | 
               (b.assigned_group :=: t1_set[i]) AND (b.role.name = 'members'));

    violate := SIZEOF(a_set) < 1;
  END_REPEAT;

WHERE
    wr1: NOT violate;
END_RULE;

RULE 
no_approvals_except_in_approval_history 
FOR (approval);
LOCAL
    t1_set:  SET OF approval := [];
    t2_set:  SET OF APPLIED_GROUP_ASSIGNMENT := [];
    violate: LOGICAL := FALSE;
END_LOCAL;
   t1_set := QUERY(a <* approval | VALUE_IN(WHICH_CLASS(a), 
                                   'approval event'));
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
   t2_set := bag_to_set(USEDIN(t1_set[i], 
   'SHIP_MOULDED_FORM_SCHEMA.APPLIED_GROUP_ASSIGNMENT.ITEMS'));
    violate := (SIZEOF(t2_set) = 0);
   REPEAT k := 1 TO HIINDEX(t2_set) WHILE NOT violate;
      violate := NOT (VALUE_IN(WHICH_CLASS(t2_set[k].ASSIGNED_GROUP), 
      'approval history'));
   END_REPEAT;
END_REPEAT;
WHERE
    WR1: NOT violate; 
END_RULE;

RULE offset_point_table_model_compound_representation_has_name
FOR (APPLIED_CLASSIFICATION_ASSIGNMENT);
LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF Compound_representation_item := [];
    t2_set:  SET OF representation_item := [];
    arg_list:  LIST OF STRING := ['offset point table type'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* get all classification_assignment instances with id 'offset point table model' *)
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.ASSIGNED_CLASS.NAME = 'offset point table model');

  (* get all instances of compound_representation_item that have class id 'offset point table model' *)
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  (* iterate over all compound_representation_item found above; stop, if one of
     them has not exactly one rep_item for each name in the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(t1_set) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
        t2_set := t1_set[i].item_element; 
  violation := (SIZEOF(QUERY(items <* t2_set | items.name = arg_list[j])) <> 1);
 END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;

END_RULE;

RULE principal_characteristics_has_properties
FOR (property_definition_representation,
applied_classification_assignment);
LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set: LIST OF product_definition := [];
    t2_set: SET OF property_definition_representation := [];
    t3_set: LIST OF property_definition := [];
    t4_set: LIST OF product_definition := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'principal characteristics');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  t2_set:= QUERY(i <* PROPERTY_DEFINITION_REPRESENTATION |
                   i.NAME = 'principal characteristics');
  REPEAT i := 1 TO HIINDEX(t2_set);
    t3_set := t3_set + t2_set[i].definition;
  END_REPEAT;
  REPEAT i := 1 TO HIINDEX(t3_set);
    t4_set := t4_set + t3_set[i].definition;
  END_REPEAT;
  violation := t1_set <> t4_set;
  WHERE
    WR1: NOT violation;
  
END_RULE;

RULE  
product_definition_for_call_sign
FOR(applied_classification_assignment);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition := [];
    t2_set:  SET OF applied_identification_assignment := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 'ship designation');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i],         'SHIP_MOULDED_FORM_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.role.name = 
        'call sign')) = 1);
  END_REPEAT;
  WHERE
    wr1: NOT violation;
END_RULE;

RULE 
product_definition_for_class_notation
FOR(applied_classification_assignment);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition := [];
    t2_set:  SET OF property_definition := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'class and statutory designation');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i],
      'SHIP_MOULDED_FORM_SCHEMA.PROPERTY_DEFINITION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | 'class notation' 
      IN WHICH_CLASS(t2_inst))) = 1);
END_REPEAT;
  WHERE
    WR1: NOT violation;
END_RULE;

RULE  
product_definition_for_flag_state
FOR(applied_classification_assignment);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition := [];
    t2_set:  SET OF applied_identification_assignment := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 'ship designation');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 
    'SHIP_MOULDED_FORM_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.role.name = 
    'flag state')) = 1);
  END_REPEAT;
  WHERE
    wr1: NOT violation;
END_RULE;

RULE product_definition_for_hydrostatic_definition_requires_reference
FOR (APPLIED_CLASSIFICATION_ASSIGNMENT);
LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT:= [];
    c2_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT:= [];
    t1_set:  SET OF property_definition := [];
    t2_set:  SET OF representation := [];
    t3_set:  SET OF property_definition_representation := [];
    t4_set:  SET OF property_definition := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* get all classification_assignment instances with id 'hydrostatic definition' *)
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.ASSIGNED_CLASS.NAME = 'hydrostatic definition');

  (* get all instances of property_definition that have class id 'hydrostatic definition' *)
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

(* get all classification_assignment instances with id 'hydrostatic table' *)
  c2_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.ASSIGNED_CLASS.NAME = 'hydrostatic table');

  (* get all instances of representation that have class id 'hydrostatic table' *)
  REPEAT i := 1 TO HIINDEX(c2_a_set);
    REPEAT j := 1 TO HIINDEX(c2_a_set[i].items);
      t2_set := t2_set + c2_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

(* get all property_definition_representation instances which have as the 
.used_representation the representation instances that have class id 'hydrostatic table' *)
  REPEAT i := 1 TO HIINDEX(t2_set);
    t3_set := t3_set + bag_to_set(USEDIN(t2_set[i], 
            'SHIP_MOULDED_FORM_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'));
  END_REPEAT;

(* get all property_definition instances which are the .definition of the 
property_definition_representation *)
  REPEAT i := 1 TO HIINDEX(t3_set);
    t4_set := t4_set + t3_set[i].definition;
  END_REPEAT;

(* compare both lists with property_definition instances which have to be identical *)
  violation := t1_set <> t4_set;

  WHERE
    wr1: NOT violation;
  
END_RULE;

RULE  
product_definition_for_managing_company
FOR(applied_classification_assignment);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition := [];
    t2_set:  SET OF applied_organization_assignment := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME =
                    'owner designation');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_MOULDED_FORM_SCHEMA.' + 
    'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.role.name = 
    'managing company')) = 1);
  END_REPEAT;
  WHERE
    wr1: NOT violation;
END_RULE;

RULE  
product_definition_for_ordering_company
FOR(applied_classification_assignment);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition := [];
    t2_set:  SET OF applied_organization_assignment := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 'owner designation');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_MOULDED_FORM_SCHEMA.' + 
    'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.role.name = 
    'ordering company')) = 1);
  END_REPEAT;
  WHERE
    wr1: NOT violation;
END_RULE;

RULE  
product_definition_for_owning_company
FOR(applied_classification_assignment);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition := [];
    t2_set:  SET OF applied_organization_assignment := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'owner designation');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 
     'SHIP_MOULDED_FORM_SCHEMA.APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.role.name = 
    'owning company')) = 1);
  END_REPEAT;
  WHERE
    wr1: NOT violation;
END_RULE;

RULE  
product_definition_for_port_of_registration
FOR(APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition := [];
    t2_set:  SET OF applied_identification_assignment := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 'ship designation');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 
    'SHIP_MOULDED_FORM_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.role.name =
     'port of registration')) = 1);
  END_REPEAT;
  WHERE
    wr1: NOT violation;
END_RULE;

RULE 
product_definition_for_regulation
FOR(APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition := [];
    t2_set:  SET OF property_definition := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'class and statutory designation');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 
     'SHIP_MOULDED_FORM_SCHEMA.PROPERTY_DEFINITION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | 'regulation' 
    IN WHICH_CLASS(t2_inst))) = 1);
END_REPEAT;
  WHERE
    WR1: NOT violation;
END_RULE;

RULE  
product_definition_for_shipyard
FOR(APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition := [];
    t2_set:  SET OF applied_organization_assignment := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'shipyard designation');
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 
    'SHIP_MOULDED_FORM_SCHEMA.APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.role.name = 
    'shipyard')) = 1);
  END_REPEAT;
  WHERE
    wr1: NOT violation;
END_RULE;

RULE product_definition_for_stability_definition
FOR (APPLIED_CLASSIFICATION_ASSIGNMENT);
LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT:= [];
    c2_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT:= [];
    t1_set:  SET OF property_definition := [];
    t2_set:  SET OF representation := [];
    t3_set:  SET OF property_definition_representation := [];
    t4_set:  SET OF property_definition := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* get all classification_assignment instances with id 'stability definition' *)
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.Assigned_class.name = 'stability definition');

  (* get all instances of property_definition that have class id 'stability definition' *)
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

(* get all classification_assignment instances with id 'stability table' *)
  c2_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.Assigned_class.name = 'stability table');

  (* get all instances of representation that have class id 'stability table' *)
  REPEAT i := 1 TO HIINDEX(c2_a_set);
    REPEAT j := 1 TO HIINDEX(c2_a_set[i].items);
      t2_set := t2_set + c2_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

(* get all property_definition_representation instances which have as the 
.used_representation the representation instances that have class id 'stability table' *)
  REPEAT i := 1 TO HIINDEX(t2_set);
    t3_set := t3_set + bag_to_set(USEDIN(t2_set[i], 
            'SHIP_MOULDED_FORM_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'));
  END_REPEAT;

(* get all property_definition instances which are the .definition of the 
property_definition_representaiton *)
  REPEAT i := 1 TO HIINDEX(t3_set);
    t4_set := t4_set + t3_set[i].definition;
  END_REPEAT;

(* compare both lists with property_definition instances which have to be identical *)
  violation := t1_set <> t4_set;

  WHERE
    wr1: NOT violation;
  
END_RULE;

RULE product_definition_relationship_references_are_distinct
FOR (product_definition_relationship);
  LOCAL
    cyclic_relationship: LOGICAL := FALSE;
  END_LOCAL;

  REPEAT i := 1 TO HIINDEX(product_definition_relationship) 
                                               WHILE NOT cyclic_relationship;
    cyclic_relationship:= 
                product_definition_relationship[i].related_product_definition 
                  :=: product_definition_relationship[i].relating_product_definition;
  END_REPEAT;

  WHERE
    wr1: NOT cyclic_relationship;
END_RULE;

RULE
 product_definition_relationship_related_to_class_moulded_form

FOR (APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    c2_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set: SET OF product_definition_RELATIONSHIP := [];
    t2_set:  SET OF product_definition := [];
    t3_set:  SET OF product_definition := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* get all classification_assignment instances with id 'moulded form relationship' *)
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.ASSIGNED_CLASS.NAME = 'moulded form relationship');

  (* get all instances of product_definition_relationship that have class id 'moulded form relationship' *)
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

(* get all related_product_definition attribute instances and relating_product_definition attribute instances of the product_definition_relationship *)
  REPEAT i := 1 TO HIINDEX(t1_set);
    t2_set := t2_set + t1_set[i].related_product_definition;
    t2_set := t2_set + t1_set[i].relating_product_definition;
   END_REPEAT;

(* get all classification_assignment instances with id 'moulded form' *)
  c2_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                    i.ASSIGNED_CLASS.NAME = 'moulded form');
 
  (* get all instances of product_definition that have class id 'moulded form' *)
  REPEAT i := 1 TO HIINDEX(c2_a_set);
    REPEAT j := 1 TO HIINDEX(c2_a_set[i].items);
      t3_set := t3_set + c2_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
violation := NOT(t2_set<= t3_set);

  WHERE 
    wr1: NOT violation;

END_RULE;

RULE product_definition_relationship_with_identification_assignment
FOR (APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition_relationship := [];
    t2_set:  SET OF applied_identification_assignment := [];
    arg_list:  LIST OF STRING := ['item relationship'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* get all classification_assignment instances with id in arg_list *)
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
        c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME =  arg_LIST[j]);
   END_REPEAT;

  (* get all instances of property_definition_representation *)
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;


    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
'SHIP_MOULDED_FORM_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
	t2_set := QUERY ( j <* t2_set | j.role.name = 'globally unambiguous identifier');
     violation := NOT (SIZEOF(T2_SET) = 1);
    END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE product_definition_shape_with_identification_assignment
 FOR (APPLIED_CLASSIFICATION_ASSIGNMENT);
LOCAL
 c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
 t1_set: SET OF product_definition_shape := [];
 t2_set: SET OF applied_identification_assignment := [];
 arg_list: LIST OF STRING := ['definition'];
 violation: LOGICAL := FALSE;
END_LOCAL;

(* get all classification_assignment instances with id in arg_list *)
REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
		   i.assigned_class.NAME = arg_LIST[j]);
END_REPEAT;

(* get all instances of product_definition_shape that have class id *)
REPEAT i := 1 TO HIINDEX(c_a_set);
 REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
  t1_set := t1_set + c_a_set[i].items[j];
 END_REPEAT;
END_REPEAT;

REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
 t2_set := bag_to_set(USEDIN(t1_set[i],
    'SHIP_MOULDED_FORM_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
 t2_set := QUERY ( j <* t2_set | 
		     j.role.name = 'globally unambiguous identifier'); 
 violation := NOT (SIZEOF(T2_SET) = 1);
END_REPEAT;

WHERE
wr1: NOT violation;
END_RULE;

RULE product_definition_with_identification_assignment
FOR (APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition := [];
    t2_set:  SET OF applied_identification_assignment := [];
    arg_list:  LIST OF STRING := [ 'definition',
                                   'definable object'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* get all classification_assignment instances  *)
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
        c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME =  arg_LIST[j]);
   END_REPEAT;

  (* get all instances of product_definition that have class id *)
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;


    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
'SHIP_MOULDED_FORM_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
      t2_set := QUERY ( j <* t2_set | 
		     j.role.name = 'globally unambiguous identifier');              violation := NOT (SIZEOF(T2_SET) = 1);
    END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE product_related_product_category_with_identification_assignment
FOR (APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_related_product_category := [];
    t2_set:  SET OF applied_identification_assignment := [];
    arg_list:  LIST OF STRING := [ 'Shiptype'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* get all classification_assignment instances with id  *)
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
        c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME =  arg_LIST[j]);
   END_REPEAT;

  (* get all instances that have class id *)
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;


    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
'SHIP_MOULDED_FORM_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
      t2_set := QUERY ( j <* t2_set | 
	       	     j.role.name = 'globally unambiguous identifier');           violation := NOT (SIZEOF(T2_SET) = 1);
    END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE product_with_identification_assignment
FOR (APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product := [];
    t2_set:  SET OF applied_identification_assignment := [];
    arg_list:  LIST OF STRING := [ 'ship'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* get all classification_assignment instances *)
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
        c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME =  arg_LIST[j]);
   END_REPEAT;

  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;


    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
'SHIP_MOULDED_FORM_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
      t2_set := QUERY ( j <* t2_set | 
	       	     j.role.name = 'globally unambiguous identifier');           violation := NOT (SIZEOF(T2_SET) = 1);
    END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE propeller_moulded_form_design_parameter_with_class_references 
FOR(APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF property_definition := [];
    t2_set:  SET OF property_definition_representation := [];
    t3_set:  SET OF representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.ASSIGNED_CLASS.NAME = 'propeller moulded form design parameter');

  (* get all instances of property_definition that have class id 
  'propeller moulded form design parameter' *)
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  (* for all instances of property_definition in t1_set:
     get the property_definition_representation instances that are       referencing a property_definition instance via definition, get those property_definition_representation.used_representation instances whose       class id is 'midship_tumble' and make sure their number is less than or equal to 1
   *)
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i],
   'SHIP_MOULDED_FORM_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
   'DEFINITION'));
 
   REPEAT j := 1 to HIINDEX(t2_set);
        t3_set := t3_set + t2_set[j].used_representation;
   END_REPEAT;
           
    violation := SIZEOF(QUERY(t2_inst <* t3_set | 'propeller location' IN WHICH_CLASS(t2_inst))) > 1;
END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE  property_definition_appendage_moulded_form_design_parameter
FOR(APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF property_definition := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* get all classification_assignment instances with id 'appendage moulded form design parameter' *)
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.ASSIGNED_CLASS.NAME = 'appendage moulded form design parameter');

  (* get all instances that have class id 'appendage moulded form design parameter' *)
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  (* for all instances of property_definition in t1_set:
     get the property_definition_representation instances that are referencing a property_definition instance via definition,
     filter out those property_definition_representation instances whose attribute name has the value 'appendage moulded form design parameter'
     check if their number equals 1
   *)
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_MOULDED_FORM_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION' + '.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.name = 'appendage moulded form design parameter')) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE  property_definition_for_bottom_moulded_form_design_parameter
FOR(APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF property_definition := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* get all classification_assignment instances with id 'bottom moulded form design parameter' *)
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.ASSIGNED_CLASS.NAME = 'bottom moulded form design parameter');

  (* get all instances that have class id 'bottom moulded form design parameter' *)
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  (* for all instances of property_definition in t1_set:
     get the property_definition_representation instances that are referencing a property_definition instance via definition,
     filter out those property_definition_representation instances whose attribute name has the value 'bottom moulded form design parameter'
     check if their number equals 1
   *)
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_MOULDED_FORM_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION' + '.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.name = 'bottom moulded form design parameter')) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE  property_definition_for_bulb_moulded_form_design_parameter
FOR(APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF property_definition := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* get all classification_assignment instances with id 'bulb moulded form design parameter' *)
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.ASSIGNED_CLASS.NAME = 'bulb moulded form design parameter');

  (* get all instances that have class id 'bulb moulded form design parameter' *)
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  (* for all instances of property_definition in t1_set:
     get the property_definition_representation instances that are referencing a property_definition instance via definition,
     filter out those property_definition_representation instances whose attribute name has the value 'bulb moulded form design parameter'
     check if their number equals 1
   *)
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_MOULDED_FORM_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION' + '.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.name = 'bulb moulded form design parameter')) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE  
property_definition_for_class_notation
FOR(applied_classification_assignment);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF property_definition := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 'class notation');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 
      'SHIP_MOULDED_FORM_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.name = 
      'class notation')) = 1);
  END_REPEAT;
  WHERE
    WR1: NOT violation;
END_RULE;

RULE  
property_definition_for_class_society
FOR(applied_classification_assignment);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF property_definition := [];
    t2_set:  SET OF applied_organization_assignment := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 'class notation');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 
      'SHIP_MOULDED_FORM_SCHEMA.APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.role.name = 
      'class society')) = 1);
  END_REPEAT;
  WHERE
    WR1: NOT violation;
END_RULE;

RULE  property_definition_for_deck_moulded_form_design_parameter
FOR(APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF property_definition := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* get all classification_assignment instances with id 'deck moulded form design parameter' *)
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.ASSIGNED_CLASS.NAME = 'deck moulded form design parameter');

  (* get all instances that have class id 'deck moulded form design parameter' *)
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  (* for all instances of property_definition in t1_set:
     get the property_definition_representation instances that are referencing a property_definition instance via definition,
     filter out those property_definition_representation instances whose attribute name has the value 'deck moulded form design parameter'
     check if their number equals 1
   *)
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_MOULDED_FORM_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION' + '.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.name = 'deck moulded form design parameter')) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE  property_definition_for_hull_moulded_form_design_parameter
FOR(APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF property_definition := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* get all classification_assignment instances with id 'hull moulded form design parameter' *)
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.ASSIGNED_CLASS.NAME = 'hull moulded form design parameter');

  (* get all instances that have class id 'hull moulded form design parameter' *)
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  (* for all instances of property_definition in t1_set:
     get the property_definition_representation instances that are referencing a property_definition instance via definition,
     filter out those property_definition_representation instances whose attribute name has the value 'hull moulded form design parameter'
     check if their number equals 1
   *)
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_MOULDED_FORM_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION' + '.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.name = 'hull moulded form design parameter')) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE  property_definition_for_local_coordinate_system
FOR(APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF property_definition := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* get all classification_assignment instances with id 'local coordinate system' *)
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.ASSIGNED_CLASS.NAME = 'local co ordinate system');

  (* get all instances that have class id 'local co ordinate system' *)
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  (* for all instances of property_definition in t1_set:       get the property_definition_representation instances that are referencing a property_definition instance via definition, filter out those property_definition_representation instances whose attribute name has the value 'local coordinate system'
     check if their number equals 1
   *)
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_MOULDED_FORM_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION' + '.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.name = 'local coordinate system')) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE  
property_definition_for_local_coordinate_system_with_position
FOR(APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF property_definition := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'local co ordinate system with position reference');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 
      'SHIP_MOULDED_FORM_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.name = 
      'local coordinate system with position reference')) = 1);
  END_REPEAT;
  WHERE
    WR1: NOT violation;
END_RULE;

RULE 
 property_definition_for_moulded_form_function_parameters
FOR(APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF property_definition := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* get all classification_assignment instances with id 'moulded form functional definition' *)
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.ASSIGNED_CLASS.NAME = 'moulded form functional definition');

  (* get all instances that have class id 'moulded form functional definition' *)
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  (* for all instances of property_definition in t1_set:
     get the property_definition_representation instances that are referencing a property_definition instance via definition,
     filter out those property_definition_representation instances whose attribute name has the value 'moulded form function parameters'
     check if their number equals 1
   *)
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_MOULDED_FORM_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION' + '.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.name = 'moulded form function parameters')) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE  property_definition_of_propeller_moulded_form_design_parameter
FOR(APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF property_definition := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* get all classification_assignment instances with id 'propeller moulded form design parameter' *)
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.ASSIGNED_CLASS.NAME = 'propeller moulded form design parameter');

  (* get all instances that have class id 'propeller moulded form design parameter' *)
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  (* for all instances of property_definition in t1_set:
     get the property_definition_representation instances that are referencing a property_definition instance via definition,
     filter out those property_definition_representation instances whose attribute name has the value 'propeller moulded form design parameter'
     check if their number equals 1
   *)
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_MOULDED_FORM_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION' + '.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.name = 'propeller moulded form design parameter')) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE  property_definition_for_rudder_moulded_form_design_parameter
FOR(APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF property_definition := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* get all classification_assignment instances with id 'rudder moulded form design parameter' *)
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.ASSIGNED_CLASS.NAME = 'rudder moulded form design parameter');

  (* get all instances that have class id 'rudder moulded form design parameter' *)
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  (* for all instances of property_definition in t1_set:
     get the property_definition_representation instances that are referencing a property_definition instance via definition,
     filter out those property_definition_representation instances whose attribute name has the value 'rudder moulded form design parameter'
     check if their number equals 1
   *)
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_MOULDED_FORM_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION' + '.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.name = 'rudder moulded form design parameter')) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE  property_definition_for_thruster_moulded_form_design_parameter
FOR(APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF property_definition := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* get all classification_assignment instances with id 'thruster moulded form design parameter' *)
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.ASSIGNED_CLASS.NAME = 'thruster moulded form design parameter');

  (* get all instances that have class id 'thruster moulded form design parameter' *)
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  (* for all instances of property_definition in t1_set:
     get the property_definition_representation instances that are referencing a property_definition instance via definition,
     filter out those property_definition_representation instances whose attribute name has the value 'thruster moulded form design parameter'
     check if their number equals 1
   *)
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_MOULDED_FORM_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION' + '.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.name = 'thruster moulded form design parameter')) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE  property_definition_for_thruster_propeller_parameter
FOR(APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF property_definition := [];
    t2_set:  SET OF property_definition_relationship := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* get all classification_assignment instances with id 'thruster moulded form design parameter' *)
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.ASSIGNED_CLASS.NAME = 'thruster moulded form design parameter');

  (* get all instances that have class id 'thruster moulded form design parameter' *)
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  (* for all instances of property_definition in t1_set:
     get the property_definition_relationship instances that are referencing a property_definition instance via relating_property_definition,
     filter out those property_definition_relationship instances whose attribute name has the value 'thruster propeller parameter'
     check if their number equals 1
   *)
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_MOULDED_FORM_SCHEMA.' + 'PROPERTY_DEFINITION_RELATIONSHIP' + '.RELATING_PROPERTY_DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.name = 'thruster propeller parameter')) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE property_definition_with_identification_assignment
FOR (APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF property_definition := [];
    t2_set:  SET OF applied_identification_assignment := [];
    arg_list:  LIST OF STRING := [ 'moulded form characteristics definition',
                                    'moulded form functional definition',                                   	'local co ordinate system',
                                   	'spacing table',
                                   	'hydrostatic definition',
                                   	'stability definition'];
        violation: LOGICAL := FALSE;
  END_LOCAL;

 
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
        c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME =  arg_LIST[j]);
   END_REPEAT;

 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;


    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
'SHIP_MOULDED_FORM_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
      t2_set := QUERY ( j <* t2_set | 
	       	     j.role.name = 'globally unambiguous identifier');           violation := NOT (SIZEOF(T2_SET) = 1);
    END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE representation_for_appendage_moulded_form_design_parameter
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['appendage length','appendage breadth',
                                  'appendage depth','type of appendage'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* find all instances of representation  which are used
     by a property_definition_representation with name equal TO
      'appendage moulded form design parameter' *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
               'SHIP_MOULDED_FORM_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
               'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 
                     'appendage moulded form design parameter')
                   )
              ) > 0 
           );

 (* iterate over all representations found above; stop, if one of          *)
 (*  them has not exactly one rep_item with for each name of the arg_list  *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_for_bottom_moulded_form_design_parameter
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['bilge radius','rise of floor','aft end of flat of bottom','front end of flat of bottom','flat of bottom breadth','rake of keel'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* find all instances of representation  which are used
     by a property_definition_representation with name equal to 'bottom moulded form design parameter' *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_MOULDED_FORM_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 'bottom moulded form design parameter')
                   )
              ) > 0 
           );

  (* iterate over all representations found above; stop, if one of
     them has not exactly one rep_item with for each name of the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_for_bulb_moulded_form_design_parameter
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['bulb length','bulb length from pp','bulb breadth','bulb breadth pp','bulb depth','bulb depth pp','bulb frame section area at pp','bulb location'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* find all instances of representation  which are used
     by a property_definition_representation with name equal to 'bulb moulded form design parameter' *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_MOULDED_FORM_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 'bulb moulded form design parameter')
                   )
              ) > 0 
           );

  (* iterate over all representations found above; stop, if one of
     them has not exactly one rep_item with for each name of the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE
representation_for_class_and_statutory_designation
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['class number'];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
               'SHIP_MOULDED_FORM_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
               'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 
                                      'class and statutory designation')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_for_deck_moulded_form_design_parameter
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['camber','sheer at ap','sheer at fp'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* find all instances of representation  which are used
     by a property_definition_representation with name equal to 'deck moulded form design parameter' *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_MOULDED_FORM_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 'deck moulded form design parameter')
                   )
              ) > 0 
           );

  (* iterate over all representations found above; stop, if one of
     them has not exactly one rep_item with for each name of the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_for_global_axis_placement
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['global axes and origin', 
                            'after perpendicular offset', 'orientation'];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
                'SHIP_MOULDED_FORM_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
                'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 'global axis placement')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_for_hull_moulded_form_design_parameter
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['aft end of parallel midbody at design draught', 'front end of parallel midbody at design draught', 'aft end of flat of side', 'front end of flat of side', 'block coefficient', 'prismatic coefficient', 'max wetted frame section area', 'waterplane coefficient'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* find all instances of representation  which are used
     by a property_definition_representation with name equal to 'hull moulded form design parameter' *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_MOULDED_FORM_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 'hull moulded form design parameter')
                   )
              ) > 0 
           );

  (* iterate over all representations found above; stop, if one of
     them has not exactly one rep_item with for each name of the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_for_hydrostatic_table_constrained
FOR (APPLIED_CLASSIFICATION_ASSIGNMENT);
LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    c2_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT:= [];
    t1_set:  SET OF representation := [];
    t2_set:  SET OF representation_item := [];
    t3_set:  SET OF representation_item := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* get all classification_assignment instances with id 'hydrostatic table' *)
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.ASSIGNED_CLASS.NAME = 'hydrostatic table');

  (* get all instances of representation that have class id 'hydrostatic table' *)
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

(* get all classification_assignment instances with id 'hydrostatic properties for constant floating position' *)
  c2_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.ASSIGNED_CLASS.NAME = 'hydrostatic properties for constant floating position');

  (* get all instances of representation_item that have class id 'hydrostatic properties for constant floating position' *)
  REPEAT i := 1 TO HIINDEX(c2_a_set);
    REPEAT j := 1 TO HIINDEX(c2_a_set[i].items);
      t2_set := t2_set + c2_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

(* get all representation_item instances which are the .items of the representation 
instances that have class id 'hydrostatic table' *)
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE (NOT violation);
    REPEAT j := 1 TO HIINDEX(t1_set[i].items);
(* compare both lists with representation_item instances and the intersection has to be 
greater 0 *)
      t3_set := t3_set + t1_set[i].items[j];
    END_REPEAT;
  violation := (SIZEOF(t3_set* t2_set) < 1);
  t3_set:= [];
  END_REPEAT;

WHERE
    wr1: NOT violation;

  
END_RULE;

RULE representation_for_hydrostatic_table_restricted
FOR (APPLIED_CLASSIFICATION_ASSIGNMENT);
LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    c2_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT:= [];
    t1_set:  SET OF representation := [];
    t2_set:  SET OF representation_item := [];
    t3_set:  SET OF representation_item := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* get all classification_assignment instances with id 'hydrostatic table' *)
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.ASSIGNED_CLASS.NAME = 'hydrostatic table');

  (* get all instances of representation that have class id 'hydrostatic table' *)
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

(* get all classification_assignment instances with id 'hydrostatic property' *)
  c2_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.ASSIGNED_CLASS.NAME = 'hydrostatic property');

  (* get all instances of representation_item that have class id 'hydrostatic property' *)
  REPEAT i := 1 TO HIINDEX(c2_a_set);
    REPEAT j := 1 TO HIINDEX(c2_a_set[i].items);
      t2_set := t2_set + c2_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

(* get all representation_item instances which are the .items of the representation 
instances that have class id 'hydrostatic table' *)
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE (NOT violation);
    REPEAT j := 1 TO HIINDEX(t1_set[i].items);
(* compare both lists with representation_item instances and the intersection has to be 
greater 0 *)
      t3_set := t3_set + t1_set[i].items[j];
    END_REPEAT;
  violation := (SIZEOF(t3_set* t2_set) < 1);
  t3_set:= [];
  END_REPEAT;

WHERE
    wr1: NOT violation;

  
END_RULE;

RULE representation_for_hydrostatic_table_restricted_by_class_id
FOR (APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT:= [];
    t1_set:  SET OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['mean shell thickness'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* get all classification_assignment instances with id 'hydrostatic table' *)
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.ASSIGNED_CLASS.NAME = 'hydrostatic table');

  (* get all instances of representation that have class id 'hydrostatic table' *)
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  (* iterate over all representation instances found above; stop, if one of
     them has not exactly one rep_item for each name in the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(t1_set) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* t1_set[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;

END_RULE;

RULE representation_for_local_coordinate_system
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['local axes and origin'];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
               'SHIP_MOULDED_FORM_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
                 'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 'local coordinate system')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT violation;
END_RULE;

RULE
representation_of_local_coordinate_system_with_position_reference
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['local axes and origin'];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
               'SHIP_MOULDED_FORM_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
               'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 
                          'local coordinate system with position reference')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_for_midship_tumble_restricted_by_class_id
FOR (APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT:= [];
    t1_set:  SET OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['tumble out at bottom', 'tumble in at top', 'tumble out at side', 'tumble in at side'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* get all classification_assignment instances with id 'midship tumble' *)
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.ASSIGNED_CLASS.NAME = 'midship tumble');

  (* get all instances of representation that have class id 'midship tumble' *)
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  (* iterate over all representation instances found above; stop, if one of
     them has not exactly one rep_item for each name in the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(t1_set) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* t1_set[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;

END_RULE;

RULE representation_for_moulded_form_function_parameters
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['function'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* find all instances of representation  which are used
     by a property_definition_representation with name equal to 'moulded form function parameters' *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_MOULDED_FORM_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 'moulded form function parameters')
                   )
              ) > 0 
           );

  (* iterate over all representations found above; stop, if one of
     them has not exactly one rep_item with for each name of the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_for_offset_point_table_model_for_point
FOR (APPLIED_CLASSIFICATION_ASSIGNMENT);
LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF Compound_representation_item := [];
    t2_set:  SET OF representation_item := [];
    arg_list:  LIST OF STRING := ['section point'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.ASSIGNED_CLASS.NAME = 'section of offset point table');

  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  (* iterate over all compound_representation_item found above; stop, if one of
     them has not one or more rep_item for each name in the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(t1_set) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
        t2_set := t1_set[i].item_element; 
  violation := (SIZEOF(QUERY(items <* t2_set | items.name = arg_list[j])) < 1);
 END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;

END_RULE;

RULE representation_for_offset_point_table_model_for_section
FOR (APPLIED_CLASSIFICATION_ASSIGNMENT);
LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF Compound_representation_item := [];
    t2_set:  SET OF representation_item := [];
    arg_list:  LIST OF STRING := ['offset point table section'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.ASSIGNED_CLASS.NAME = 'offset point table model');

  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  (* iterate over all compound_representation_item found above; stop, if one of
     them has not one or more rep_item for each name in the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(t1_set) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
        t2_set := t1_set[i].item_element; 
  violation := (SIZEOF(QUERY(items <* t2_set | items.name = arg_list[j])) < 1);
 END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;

END_RULE;

RULE representation_for_offset_table_shape_representation_restricted
FOR (APPLIED_CLASSIFICATION_ASSIGNMENT);
LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    c2_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT:= [];
    t1_set:  SET OF representation := [];
    t2_set:  SET OF representation_item := [];
    t3_set:  SET OF representation_item := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* get all classification_assignment instances with id 'offset table shape representation' *)
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                 i.ASSIGNED_CLASS.NAME = 'offset table shape representation');

  (* get all instances of representation that have class id 'offset table shape representation' *)
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

(* get all classification_assignment instances with id 'offset point table model' *)
  c2_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.ASSIGNED_CLASS.NAME = 'offset point table model');

  (* get all instances of representation_item that have class id 'offset point table model' *)
  REPEAT i := 1 TO HIINDEX(c2_a_set);
    REPEAT j := 1 TO HIINDEX(c2_a_set[i].items);
      t2_set := t2_set + c2_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

(* get all representation_item instances which are the .items of the representation 
instances that have class id 'offset table shape representation' *)
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE (NOT violation);
    REPEAT j := 1 TO HIINDEX(t1_set[i].items);
(* compare both lists with representation_item instances and the intersection has to be greater than 0 *)
      t3_set := t3_set + t1_set[i].items[j];
    END_REPEAT;
  violation := (SIZEOF(t3_set* t2_set) < 1);
  t3_set:= [];
  END_REPEAT;

WHERE
    wr1: NOT violation;
 
END_RULE;

RULE representation_for_propeller_location_restricted_by_class_id
FOR (APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT:= [];
    t1_set:  SET OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['shaft line inclination x', 'shaft line inclination y', 'shaft line location', 'propeller location'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* get all classification_assignment instances with id 'propeller location' *)
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.ASSIGNED_CLASS.NAME = 'propeller location');

  (* get all instances of representation that have class id 'propeller location' *)
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  (* iterate over all representation instances found above; stop, if one of
     them has not exactly one rep_item for each name in the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(t1_set) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* t1_set[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;

END_RULE;

RULE representation_for_propeller_moulded_form_design_parameter
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['type of propulsion', 'propeller diameter', 'chord length at 0 7 radius', 'thickness at 0 7 radius', 'number of propeller blades', 'expanded area ratio', 'hub diameter ratio', 'nominal design pitch ratio', 'type of propeller blades', 'rake', 'skew', 'design sense of rotation'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* find all instances of representation  which are used
     by a property_definition_representation with name equal to 'propeller moulded form design parameter' *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
'SHIP_MOULDED_FORM_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'))
           | (temp_prop_def_rep.name = 'propeller moulded form design parameter')
                   )
              ) > 0 
           );

  (* iterate over all representations found above; stop, if one of
     them has not exactly one rep_item with for each name of the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_for_rudder_moulded_form_design_parameter
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['rudder height', 'rudder mean height', 'rudder length', 'rudder mean length', 'rudder thickness', 'projected rudder area', 'type of the rudder', 'rudder location'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* find all instances of representation  which are used
     by a property_definition_representation with name equal to 'rudder moulded form design parameter' *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_MOULDED_FORM_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 'rudder moulded form design parameter')
                   )
              ) > 0 
           );

  (* iterate over all representations found above; stop, if one of
     them has not exactly one rep_item with for each name of the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE 
representation_for_stability_table_restricted
FOR (APPLIED_CLASSIFICATION_ASSIGNMENT);
LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    c2_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT:= [];
    t1_set:  SET OF representation := [];
    t2_set:  SET OF representation_item := [];
    t3_set:  SET OF representation_item := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* get all classification_assignment instances with id 'stability table' *)
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.Assigned_class.name = 'stability table');

  (* get all instances of representation that have class id 'stability table' *)
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

(* get all classification_assignment instances with id 'stability properties for one floating position' *)
  c2_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.Assigned_class.name = 'stability properties for one floating position');

  (* get all instances of representation_item that have class id 'stability properties for one floating position' *)
  REPEAT i := 1 TO HIINDEX(c2_a_set);
    REPEAT j := 1 TO HIINDEX(c2_a_set[i].items);
      t2_set := t2_set + c2_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

(* get all representation_item instances which are the .items of the representation 
instances that have class id 'stability table' *)
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE (NOT violation);
    REPEAT j := 1 TO HIINDEX(t1_set[i].items);
(* compare both lists with representation_item instances and the intersection has to be 
greater 0 *)
      t3_set := t3_set + t1_set[i].items[j];
    END_REPEAT;
  violation := (SIZEOF(t3_set* t2_set) < 1);
  t3_set:= [];
  END_REPEAT;

WHERE
    wr1: NOT violation;

  
END_RULE;

RULE representation_for_stability_table_restricted_by_class_id
FOR (APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT:= [];
    t1_set:  SET OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['mean shell thickness'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* get all classification_assignment instances with id 'stability table' *)
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.Assigned_class.name = 'stability table');

  (* get all instances of representation that have class id 'stability table' *)
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  (* iterate over all representation instances found above; stop, if one of
     them has not exactly one rep_item for each name in the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(t1_set) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* t1_set[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;

END_RULE;

RULE representation_for_thruster_moulded_form_design_parameter
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['thruster tunnel diameter', 'thruster tunnel min length', 'thruster tunnel max length', 'geometric thruster location', 'thruster location'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* find all instances of representation  which are used
     by a property_definition_representation with name equal to 'thruster moulded form design parameter' *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_MOULDED_FORM_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 'thruster moulded form design parameter')
                   )
              ) > 0 
           );

  (* iterate over all representations found above; stop, if one of
     them has not exactly one rep_item with for each name of the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_has_global_uncertainty_assigned_context      
     FOR (SHAPE_REPRESENTATION);  
LOCAL    
 has_gunac: LOGICAL := TRUE;  
END_LOCAL;  

REPEAT i := 1 TO HIINDEX(SHAPE_REPRESENTATION) WHILE has_gunac;
 has_gunac := ('SHIP_MOULDED_FORM_SCHEMA.GLOBAL_UNCERTAINTY_ASSIGNED_CONTEXT' IN 
               TYPEOF(SHAPE_REPRESENTATION[i].CONTEXT_OF_ITEMS));
END_REPEAT;

WHERE    
 WR1: has_gunac;  
END_RULE;

RULE representation_has_global_unit_assigned_context 
     FOR (REPRESENTATION);
  LOCAL
    has_guac: LOGICAL := TRUE;
  END_LOCAL;
  REPEAT i := 1 TO HIINDEX(REPRESENTATION) WHILE has_guac;
    REPEAT j := 1 TO SIZEOF(REPRESENTATION[i].ITEMS) WHILE has_guac;
      IF (('SHIP_MOULDED_FORM_SCHEMA.VALUE_REPRESENTATION_ITEM' 
          IN TYPEOF(REPRESENTATION[i].ITEMS[j])) OR
          ('SHIP_MOULDED_FORM_SCHEMA.GEOMETRIC_REPRESENTATION_ITEM'
           IN TYPEOF(REPRESENTATION[i].ITEMS[j]))) THEN
        has_guac := ('SHIP_MOULDED_FORM_SCHEMA.GLOBAL_UNIT_ASSIGNED_CONTEXT'
         IN TYPEOF(REPRESENTATION[i].CONTEXT_OF_ITEMS));
      END_IF;
    END_REPEAT;
  END_REPEAT;
  WHERE
    WR1: has_guac;  
END_RULE; 

RULE representation_items_appendage_moulded_form_design_parameter 
FOR (representation);
  LOCAL
    reps: BAG OF REPRESENTATION := [];
    arg_list: LIST OF STRING := ['moulded form outer surface',
      'moulded form displacement', 'user def appendage type'];
    found: LOGICAL := FALSE;
  END_LOCAL;

  (* Find all instances of representation  which are used
     by a property_definition_representation with name equal to 
     'appendage moulded form design parameter'  *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
      'SHIP_MOULDED_FORM_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
      'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name =
                    'appendage moulded form design parameter')
                   )
              ) > 0 
           );

  (* iterate over all representations found above. Stop, if for one of
     them the names of its representation_items are duplicated.
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT found);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT found);
      found := (SIZEOF(QUERY(rep_item <* reps[i].items |
                rep_item.name=arg_list[j])) > 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT found;
END_RULE;

RULE representation_items_for_bottom_moulded_form_design_parameter 
FOR (representation);
  LOCAL
    reps: BAG OF REPRESENTATION := [];
    arg_list: LIST OF STRING := ['moulded form outer surface',
                                 'moulded form displacement'];
    found: LOGICAL := FALSE;
  END_LOCAL;

  (* Find all instances of representation  which are used
     by a property_definition_representation with name equal to 
     'bottom moulded form design parameter' *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
             'SHIP_MOULDED_FORM_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
             'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 
                    'bottom moulded form design parameter')
                   )
              ) > 0 
           );

  (* iterate over all representations found above. Stop, if for one of *)
 (*     them the names of its representation_items are duplicated.   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT found);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT found);
      found := (SIZEOF(QUERY(rep_item <* reps[i].items |
                rep_item.name=arg_list[j])) > 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT found;
END_RULE;

RULE representation_items_for_bulb_moulded_form_design_parameter 
FOR (representation);
  LOCAL
    reps: BAG OF REPRESENTATION := [];
    arg_list: LIST OF STRING := ['moulded form outer surface',
                                 'moulded form displacement'];
    found: LOGICAL := FALSE;
  END_LOCAL;

  (* Find all instances of representation  which are used
     by a property_definition_representation with name equal to 
     'bulb moulded form design parameter'  *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
            'SHIP_MOULDED_FORM_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
            'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 
                    'bulb moulded form design parameter')
                   )
              ) > 0 
           );

  (* iterate over all representations found above. Stop, if for one of
     them the names of its representation_items are duplicated.
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT found);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT found);
      found := (SIZEOF(QUERY(rep_item <* reps[i].items |
                rep_item.name=arg_list[j])) > 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT found;
END_RULE;

RULE representation_items_for_deck_moulded_form_design_parameter 
FOR (representation);
  LOCAL
    reps: BAG OF REPRESENTATION := [];
    arg_list: LIST OF STRING := ['moulded form outer surface',
                                 'moulded form displacement'];
    found: LOGICAL := FALSE;
  END_LOCAL;

  (* Find all instances of representation  which are used
     by a property_definition_representation with name equal to 
     'deck moulded form design parameter'   *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
            'SHIP_MOULDED_FORM_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
            'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 
                    'deck moulded form design parameter')
                   )
              ) > 0 
           );

  (* iterate over all representations found above. Stop, if for one of
     them the names of its representation_items are duplicated.
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT found);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT found);
      found := (SIZEOF(QUERY(rep_item <* reps[i].items |
                rep_item.name=arg_list[j])) > 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT found;
END_RULE;

RULE representation_items_for_hull_moulded_form_design_parameter 
FOR (representation);
  LOCAL
    reps: BAG OF REPRESENTATION := [];
    arg_list: LIST OF STRING := ['moulded form outer surface', 
                                 'moulded form displacement', 
                                 'waterline angle of entrance at stern', 
                                 'waterline angle of entrance at bow', 
                                 'max frame section area location', 
                                 'hull length pp', 
                                 'hull length waterline', 
                                 'hull breadth', 
                                 'hull depth', 
                                 'hull design draught',
                                 'gunwale radius'];
    found: LOGICAL := FALSE;
  END_LOCAL;

  (* Find all instances of representation  which are used
     by a property_definition_representation with name equal to 
     'hull moulded form design parameter'  *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
             'SHIP_MOULDED_FORM_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
             'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 
                    'hull moulded form design parameter')
                   )
              ) > 0 
           );

  (* iterate over all representations found above. Stop, if for one of
     them the names of its representation_items are duplicated.
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT found);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT found);
      found := (SIZEOF(QUERY(rep_item <* reps[i].items |
                rep_item.name=arg_list[j])) > 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT found;
END_RULE;

RULE representation_items_for_moulded_form_design_parameters 
FOR (representation);
  LOCAL
    reps: BAG OF REPRESENTATION := [];
    arg_list: LIST OF STRING := ['status'];
    found: LOGICAL := FALSE;
  END_LOCAL;

  (* Find all instances of representation  which are used
     by a property_definition_representation with name equal to 
     'moulded form design parameters'  *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
             'SHIP_MOULDED_FORM_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
             'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 
                    'moulded form design parameters')
                   )
              ) > 0 
           );

  (* iterate over all representations found above. Stop, if for one of
     them the names of its representation_items are duplicated.
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT found);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT found);
      found := (SIZEOF(QUERY(rep_item <* reps[i].items |
                rep_item.name=arg_list[j])) > 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT found;
END_RULE;

RULE representation_items_for_moulded_form_function_parameters 
FOR (representation);
  LOCAL
    reps: BAG OF REPRESENTATION := [];
    arg_list: LIST OF STRING := ['user def function'];
    found: LOGICAL := FALSE;
  END_LOCAL;

  (* Find all instances of representation  which are used
     by a property_definition_representation with name equal to 'moulded form function parameters'
   *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_MOULDED_FORM_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 'moulded form function parameters')
                   )
              ) > 0 
           );

  (* iterate over all representations found above. Stop, if for one of
     them the names of its representation_items are duplicated.
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT found);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT found);
      found := (SIZEOF(QUERY(rep_item <* reps[i].items |
                rep_item.name=arg_list[j])) > 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT found;
END_RULE;

RULE representation_items_propeller_moulded_form_design_parameter 
FOR (representation);
  LOCAL
    reps: BAG OF REPRESENTATION := [];
    arg_list: LIST OF STRING := ['blade_mean_height', 
                                 'moulded form outer surface', 
                                 'moulded form displacement'];
    found: LOGICAL := FALSE;
  END_LOCAL;

  (* Find all instances of representation  which are used
     by a property_definition_representation with name equal to 
     'propeller moulded form design parameter'  *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
         'SHIP_MOULDED_FORM_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
         'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 
                    'propeller moulded form design parameter')
                   )
              ) > 0 
           );

  (* iterate over all representations found above. Stop, if for one of
     them the names of its representation_items are duplicated.
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT found);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT found);
      found := (SIZEOF(QUERY(rep_item <* reps[i].items |
                rep_item.name=arg_list[j])) > 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT found;
END_RULE;

RULE representation_items_for_rudder_moulded_form_design_parameter 
FOR (representation);
  LOCAL
    reps: BAG OF REPRESENTATION := [];
    arg_list: LIST OF STRING := ['moulded form outer surface', 
                                 'moulded form displacement'];
    found: LOGICAL := FALSE;
  END_LOCAL;

  (* Find all instances of representation  which are used
     by a property_definition_representation with name equal to  
     'rudder moulded form design parameter'  *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
            'SHIP_MOULDED_FORM_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
            'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name =
                     'rudder moulded form design parameter')
                   )
              ) > 0 
           );

  (* iterate over all representations found above. Stop, if for one of
     them the names of its representation_items are duplicated.
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT found);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT found);
      found := (SIZEOF(QUERY(rep_item <* reps[i].items |
                rep_item.name=arg_list[j])) > 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT found;
END_RULE;

RULE representation_items_of_thruster_moulded_form_design_parameter 
FOR (representation);
  LOCAL
    reps: BAG OF REPRESENTATION := [];
    arg_list: LIST OF STRING := ['moulded form outer surface', 
                                 'moulded form displacement'];
    found: LOGICAL := FALSE;
  END_LOCAL;

  (* Find all instances of representation  which are used
     by a property_definition_representation with name equal to 
       'thruster moulded form design parameter'  *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
            'SHIP_MOULDED_FORM_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
            'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 
                    'thruster moulded form design parameter')
                   )
              ) > 0 
           );

  (* iterate over all representations found above. Stop, if for one of
     them the names of its representation_items are duplicated.
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT found);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT found);
      found := (SIZEOF(QUERY(rep_item <* reps[i].items |
                rep_item.name=arg_list[j])) > 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT found;
END_RULE;

RULE  
representation_item_for_transformation_to_parent
FOR(APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF property_definition := [];
    t2_set:  SET OF property_definition_representation := [];
    t3_set:  SET OF representation := [];
    t4_set:  SET OF representation_map := [];
    t5_set:  SET OF mapped_item := [];
    arg_list:  LIST OF STRING := 
['local coordinate system position in global coordinate system', 
'local coordinate system position in parent local coordinate system',
'local coordinate system position in parent local coordinate system with position reference'];
    violation1: LOGICAL := FALSE;
    violation2: LOGICAL := FALSE;

  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
            i.assigned_class.NAME =  'local co ordinate system');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation1;
    t2_set := bag_to_set(USEDIN(t1_set[i], 
      'SHIP_MOULDED_FORM_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation1 := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.used_representation.name = 
      'local axis representation')) = 1);
    t3_set := t3_set + t2_set[i].used_representation;
  END_REPEAT;
  
   REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation1;
    t4_set := bag_to_set(USEDIN(t3_set[i], 
      'SHIP_MOULDED_FORM_SCHEMA.REPRESENTATION_MAP.MAPPED_REPRESENTATION'));
  END_REPEAT;
  
   REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation1;
    t5_set := bag_to_set(USEDIN(t4_set[i], 
      'SHIP_MOULDED_FORM_SCHEMA.MAPPED_ITEM.MAPPING_SOURCE'));
      REPEAT j := 1 TO 3 WHILE NOT violation2;
      violation2 := NOT (SIZEOF(QUERY(t2_inst <* t5_set | t2_inst.name = 
      ARG_LIST[j])) = 1);
      END_REPEAT;
  END_REPEAT;  
  
  WHERE
    WR1: NOT violation1;
    WR2: NOT violation2;
END_RULE;

RULE representation_items_optional_for_class_notation 
FOR (representation);
  LOCAL
    reps: BAG OF REPRESENTATION := [];
    arg_list: LIST OF STRING := ['ice class notation','service factor',
                                 'approval required for heavy cargo'];
    found: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_MOULDED_FORM_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
  'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 'class notation')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT found);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT found);
      found := (SIZEOF(QUERY(rep_item <* reps[i].items |
                rep_item.name=arg_list[j])) > 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT found;
END_RULE;

RULE representation_items_optional_for_owner_designation 
     FOR (representation);
(* R12<'owner designation',['owner approval']> *)
LOCAL
  reps: BAG OF REPRESENTATION := [];
  arg_list: LIST OF STRING := ['owner approval'];
  found: LOGICAL := FALSE;
END_LOCAL;

(* Find all instances of representation which are used
by a property_definition_representation with name equal to 'owner 
designation'
*)
reps := QUERY(temp_rep <* representation | 
   SIZEOF (QUERY(temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
           'SHIP_MOULDED_FORM_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
           'USED_REPRESENTATION'))
           | (temp_prop_def_rep.name = 'owner designation'))) > 0 );

(* iterate over all representations found above. Stop, if for one of
them the names of its representation_items are duplicated.
*)
REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT found);
 REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT found);
  found := (SIZEOF(QUERY(rep_item <* reps[i].items |
                   rep_item.name = arg_list[j])) > 1);
 END_REPEAT;
END_REPEAT;

WHERE 
wr1: NOT found;
END_RULE;

RULE representation_items_optional_for_principal_characteristics 
FOR (representation);
  LOCAL
    reps: BAG OF REPRESENTATION := [];
    arg_list: LIST OF STRING := ['block coefficient',
                            'design draught', 
                            'design deadweight', 
                            'min draught at fp', 
                            'max draught at fp', 
                            'min draught at ap', 
                            'max draught at ap'];
    found: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_MOULDED_FORM_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
  'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 
                    'principal characteristics')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT found);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT found);
      found := (SIZEOF(QUERY(rep_item <* reps[i].items |
                rep_item.name=arg_list[j])) > 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT found;
END_RULE;

RULE representation_restricted_by_name_class_notation
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['service area', 
                           'approval required for oil cargo', 
                           'approval required for loading unloading aground', 
                           'approval required for unloading grabs'];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
                'SHIP_MOULDED_FORM_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
                'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 'class notation')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_restricted_by_name_class_parameters
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['length class', 'length solas', 
                             'scantlings draught', 'block coefficient class', 
                             'design speed ahead','design speed astern'];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
                'SHIP_MOULDED_FORM_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
                'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 'class parameters')
                   )
              ) > 0 
           );
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_restricted_by_name_principal_characteristics
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['length between perpendiculars', 
                                  'moulded breadth', 'moulded depth'];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_MOULDED_FORM_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
  'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 
                    'principal characteristics')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_restricted_by_name_ship_overall_dimensions
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['overall breadth', 'overall depth',
     'overall length', 'stem overhang', 'stern overhang'];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_MOULDED_FORM_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
  'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 
                    'ship overall dimensions')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT violation;
END_RULE;

RULE 
revision_has_mandatory_attribute_description
FOR (group);
LOCAL
    t1_set:  SET OF group := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
  t1_set := QUERY(i <* group | VALUE_IN(WHICH_CLASS(i), 'revision')); 
  violate := (SIZEOF(QUERY(k <* t1_set | 
  NOT EXISTS (k.description))) > 0);
WHERE
    WR1: NOT violate; 
END_RULE;

RULE 
revision_with_context_referenced_for_context_of_revision
FOR(applied_group_assignment, group);
  LOCAL
    t1_set:  SET OF group := [];
    a_set:  SET OF applied_group_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
t1_set := QUERY(a <* group | 
          VALUE_IN(WHICH_CLASS(a), 'revision with context'));
 
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
   a_set := QUERY(b <* applied_group_assignment | 
               (b.assigned_group = t1_set[i]) AND 
               (b.role.name = 'context of revision'));
    violate := SIZEOF(a_set) <> 1;
  END_REPEAT;
WHERE
    WR1: NOT violate;
END_RULE;

RULE ship_curve_has_name
FOR (APPLIED_CLASSIFICATION_ASSIGNMENT);
LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF Compound_representation_item := [];
    t2_set:  SET OF representation_item := [];
    arg_list:  LIST OF STRING := ['side condition', 'curve shape'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* get all classification_assignment instances with id 'ship curve' *)
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.ASSIGNED_CLASS.NAME = 'ship curve');

  (* get all instances of compound_representation_item that have class id 'ship curve' *)
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  (* iterate over all compound_representation_item found above; stop, if one of
     them has not exactly one rep_item for each name in the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(t1_set) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
        t2_set := t1_set[i].item_element; 
   violation := (SIZEOF(QUERY(items <* t2_set | items.name = arg_list[j])) <> 1);
 END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;

END_RULE;

RULE ship_curve_segment_has_class
FOR (APPLIED_CLASSIFICATION_ASSIGNMENT);
LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    c_a_set2 : SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF COMPOUND_REPRESENTATION_ITEM := [];
    t2_set:  SET OF COMPOUND_REPRESENTATION_ITEM := [];
    t3_set:  SET OF REPRESENTATION_ITEM := [];  
    l_rep_item : list_representation_item;
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* get all classification_assignment instances with id 'ship curve segment' *)
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.ASSIGNED_CLASS.NAME = 'ship curve segment');

  (* get all instances of compound_representation_item that have class id 'ship curve segment' *)
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

(* get all classification_assignment instances with id 'ship curve' *)
  c_a_set2 := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.ASSIGNED_CLASS.NAME = 'ship curve');

  (* get all instances of compound_representation_item that have class id 'ship curve' *)
  REPEAT i := 1 TO HIINDEX(c_a_set2);
    REPEAT j := 1 TO HIINDEX(c_a_set2[i].items);
      t2_set := t2_set + c_a_set2[i].items[j];
    END_REPEAT;
  END_REPEAT;

  (* iterate over all compound_representation_item found in the first list; then iterate
   over all item_element for each compound_representation_item,
   check that the intersection of these item_elements and and the second list of
   compound_representation_item is equal 1
   *)
  REPEAT i:=1 TO HIINDEX(t1_set) WHILE (NOT violation);
    REPEAT j := 1 TO HIINDEX(t1_set[i].item_element);
                l_rep_item := t1_set[i].item_element;
      t3_set := t3_set + l_rep_item[j];
    END_REPEAT;
    violation := (SIZEOF(t3_set * t2_set) <> 1);
    t3_set:= [];
  END_REPEAT;

  WHERE 
    wr1: NOT violation;

END_RULE;

RULE ship_curve_with_spacing_position_has_class
FOR (APPLIED_CLASSIFICATION_ASSIGNMENT);
LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    c_a_set2 : SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF COMPOUND_REPRESENTATION_ITEM := [];
    t2_set:  SET OF COMPOUND_REPRESENTATION_ITEM := [];
    t3_set:  SET OF REPRESENTATION_ITEM := [];
    l_rep_item : list_representation_item;
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* get all classification_assignment instances with id 'ship curve with spacing position' *)
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.ASSIGNED_CLASS.NAME = 'ship curve with spacing position');

  (* get all instances of compound_representation_item that have class id 'ship curve with spacing position' *)
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

(* get all classification_assignment instances with id 'spacing position' *)
  c_a_set2 := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.ASSIGNED_CLASS.NAME = 'spacing position');

  (* get all instances of compound_representation_item that have class id 'spacing position' *)
  REPEAT i := 1 TO HIINDEX(c_a_set2);
    REPEAT j := 1 TO HIINDEX(c_a_set2[i].items);
      t2_set := t2_set + c_a_set2[i].items[j];
    END_REPEAT;
  END_REPEAT;

  (* iterate over all compound_representation_item found in the first list; then iterate
   over all item_element for each compound_representation_item,
   check that the intersection of these item_elements and and the second list of
   compound_representation_item is equal 1
   *)
  REPEAT i:=1 TO HIINDEX(t1_set) WHILE (NOT violation);
    REPEAT j := 1 TO HIINDEX(t1_set[i].item_element);
          l_rep_item := t1_set[i].item_element;
      t3_set := t3_set + l_rep_item[j];
    END_REPEAT;
    violation := (SIZEOF(t3_set * t2_set) <> 1);
    t3_set:= [];
  END_REPEAT;

  WHERE 
    wr1: NOT violation;

END_RULE;

RULE ship_designation_has_one_specified_names 
FOR(applied_classification_assignment);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition := [];
    t2_set:  SET OF applied_identification_assignment := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'ship designation');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i],
      'SHIP_MOULDED_FORM_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | (t2_inst.role.name =
      'imo number')OR (t2_inst.role.name = 'pennant hull number') )) = 1);
  END_REPEAT;
  WHERE
    WR1: NOT violation;
END_RULE;

RULE ship_moulded_form_revision_has_description
FOR (product_definition_relationship);
LOCAL
    t1_set:  SET OF product_definition_relationship := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;

(* get all instances of product_definition_relatonship being classified as 'ship moulded form revision' *)
t1_set := QUERY(i <* product_definition_relationship | VALUE_IN(WHICH_CLASS(i), 'ship moulded form revision')); 

(* from all instances found above:
   find those for which attribute description is not instanciated
*)

violate := (SIZEOF(QUERY(k <* t1_set | NOT EXISTS (k.description))) > 0);

WHERE
    wr1: NOT violate; 
END_RULE;

RULE ship_overall_dimensions_has_properties
FOR (property_definition_representation,
applied_classification_assignment);
	LOCAL
		c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
		t1_set: LIST OF product_definition := [];
		t2_set: SET OF property_definition_representation := [];
		t3_set: LIST OF property_definition := [];
		t4_set: LIST OF product_definition := [];
		violation: LOGICAL := FALSE;
	END_LOCAL;
	c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
			i.assigned_class.NAME =
			'ship overall dimensions');
		REPEAT i := 1 TO HIINDEX(c_a_set);
			REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
				t1_set := t1_set + c_a_set[i].items[j];
			END_REPEAT;
		END_REPEAT;
	t2_set:= QUERY(i <* PROPERTY_DEFINITION_REPRESENTATION |
			i.NAME = 'ship overall dimensions');
		REPEAT i := 1 TO HIINDEX(t2_set);
			t3_set := t3_set + t2_set[i].definition;
		END_REPEAT;
	REPEAT i := 1 TO HIINDEX(t3_set);
		t4_set := t4_set + t3_set[i].definition;
	END_REPEAT;
violation := t1_set <> t4_set;
WHERE
	WR1: NOT violation;
END_RULE;

RULE ship_point_compound_representation_has_name
FOR (APPLIED_CLASSIFICATION_ASSIGNMENT);
LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF Compound_representation_item := [];
    t2_set:  SET OF representation_item := [];
    arg_list:  LIST OF STRING := ['point shape'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* get all classification_assignment instances with id 'ship point' *)
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.ASSIGNED_CLASS.NAME = 'ship point');

  (* get all instances of compound_representation_item that have class id 'ship point' *)
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  (* iterate over all compound_representation_item found above; stop, if one of
     them has not exactly one rep_item for each name in the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(t1_set) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
        t2_set := t1_set[i].item_element; 
   violation := (SIZEOF(QUERY(items <* t2_set | items.name = arg_list[j])) <> 1);
 END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;

END_RULE;

RULE ship_surface_compound_representation_has_name
FOR (APPLIED_CLASSIFICATION_ASSIGNMENT);
LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF Compound_representation_item := [];
    t2_set:  SET OF representation_item := [];
    arg_list:  LIST OF STRING := ['surface shape'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* get all classification_assignment instances with id 'ship surface' *)
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.ASSIGNED_CLASS.NAME = 'ship surface');

  (* get all instances of compound_representation_item that have class id 'ship surface' *)
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  (* iterate over all compound_representation_item found above; stop, if one of
     them has not exactly one rep_item for each name in the arg_list   *)
  REPEAT i:=1 TO HIINDEX(t1_set) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
        t2_set := t1_set[i].item_element; 
   violation := (SIZEOF(QUERY(items <* t2_set | items.name = arg_list[j])) <> 1);
 END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;

END_RULE;

RULE spacing_position_compound_representation_has_name
FOR (applied_classification_assignment);
LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF Compound_representation_item := [];
    t2_set:  SET Of representation_item := [];
    arg_list:  LIST OF STRING := ['position number', 'position'];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 'spacing position');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i:=1 TO HIINDEX(t1_set) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
        t2_set := t1_set[i].item_element; 
        violation := (SIZEOF(QUERY(items <* t2_set |
           items.name = arg_list[j])) <> 1);
 END_REPEAT;
  END_REPEAT;
  WHERE 
    WR1: NOT violation;
END_RULE;

RULE spacing_position_with_offset_compound_representation_has_class
FOR (applied_classification_assignment);
LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    c_a_set2 : SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF COMPOUND_REPRESENTATION_ITEM := [];
    t2_set:  SET OF COMPOUND_REPRESENTATION_ITEM := [];
    t3_set:  SET Of representation_item := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 'spacing position with offset');       REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
  c_a_set2 := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 'spacing position');
 
  REPEAT i := 1 TO HIINDEX(c_a_set2);
    REPEAT j := 1 TO HIINDEX(c_a_set2[i].items);
      t2_set := t2_set + c_a_set2[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i:=1 TO HIINDEX(t1_set) WHILE (NOT violation);
    REPEAT j := 1 TO HIINDEX(t1_set[i].item_element);
      t3_set := t3_set + t1_set[i].item_element;
    END_REPEAT;
    violation := (SIZEOF(t3_set * t2_set) <> 1);
    t3_set:= [];
  END_REPEAT;
  WHERE 
    WR1: NOT violation;
END_RULE;

RULE spacing_position_with_offset_compound_representation_has_name
FOR (applied_classification_assignment);
LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF Compound_representation_item := [];
    t2_set:  SET Of representation_item := [];
    arg_list:  LIST OF STRING := ['offset'];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'spacing position with offset');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i:=1 TO HIINDEX(t1_set) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
        t2_set := t1_set[i].item_element; 
        violation := (SIZEOF(QUERY(items <* t2_set | 
        items.name = arg_list[j])) <> 1);
 END_REPEAT;
  END_REPEAT;
  WHERE 
    WR1: NOT violation;
END_RULE;

RULE 
stability_properties_for_floating_position_has_class
FOR (APPLIED_CLASSIFICATION_ASSIGNMENT);
LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    c_a_set2 : SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF COMPOUND_REPRESENTATION_ITEM := [];
    t2_set:  SET OF COMPOUND_REPRESENTATION_ITEM := [];
    t3_set:  SET OF REPRESENTATION_ITEM := [];
    l_rep_item : list_representation_item;
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* get all classification_assignment instances with id 'stability properties for one floating position' *)
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.Assigned_class.name = 'stability properties for one floating position');

  (* get all instances of compound_representation_item that have class id 'stability properties for one floating position' *)
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

(* get all classification_assignment instances with id 'stability property' *)
  c_a_set2 := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.Assigned_class.name = 'stability property');

  (* get all instances of compound_representation_item that have class id 'stability property' *)
  REPEAT i := 1 TO HIINDEX(c_a_set2);
    REPEAT j := 1 TO HIINDEX(c_a_set2[i].items);
      t2_set := t2_set + c_a_set2[i].items[j];
    END_REPEAT;
  END_REPEAT;

  (* iterate over all compound_representation_item found in the first list; then iterate
   over all item_element for each compound_representation_item,
   check that the intersection of these item_elements and and the second list of
   compound_representation_item is greater than or equal to 1
   *)
  REPEAT i:=1 TO HIINDEX(t1_set) WHILE (NOT violation);
    REPEAT j := 1 TO HIINDEX(t1_set[i].item_element);
          l_rep_item := t1_set[i].item_element;
      t3_set := t3_set + l_rep_item[j];
    END_REPEAT;
    violation := (SIZEOF(t3_set * t2_set) < 1);
    t3_set:= [];
  END_REPEAT;

  WHERE 
    wr1: NOT violation;

END_RULE;

RULE 
stability_properties_for_floating_position_has_name
FOR (APPLIED_CLASSIFICATION_ASSIGNMENT);
LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF Compound_representation_item := [];
    t2_set:  SET OF representation_item := [];
    arg_list:  LIST OF STRING := ['centre of gravity above keel', 'definition of starting floating position'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* get all classification_assignment instances with id 'stability properties for one floating position' *)
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.Assigned_class.name = 'stability properties for one floating position');

  (* get all instances of compound_representation_item that have class id 'stability properties for one floating position' *)
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  (* iterate over all compound_representation_item found above; stop, if one of
     them has not exactly one rep_item for each name in the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(t1_set) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
        t2_set := t1_set[i].item_element; 
  violation := (SIZEOF(QUERY(items <* t2_set | items.name = arg_list[j])) <> 1);
 END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;

END_RULE;

RULE stability_property_has_name
FOR (APPLIED_CLASSIFICATION_ASSIGNMENT);
LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF Compound_representation_item := [];
    t2_set:  SET OF representation_item := [];
    arg_list:  LIST OF STRING := ['angle of heel', 'righting arm', 'centre of buoyancy'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* get all classification_assignment instances with id 'stability property' *)
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.Assigned_class.name = 'stability property');

  (* get all instances of compound_representation_item that have class id 'stability property' *)
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  (* iterate over all compound_representation_item found above; stop, if one of
     them has not exactly one rep_item for each name in the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(t1_set) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
        t2_set := t1_set[i].item_element; 
   violation := (SIZEOF(QUERY(items <* t2_set | items.name = arg_list[j])) <> 1);
 END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;

END_RULE;

RULE 
unique_approvals_in_approval_history
FOR (GROUP, APPLIED_GROUP_ASSIGNMENT);
LOCAL
    t1_set:  SET OF GROUP := [];
    t2_set:  SET OF APPLIED_GROUP_ASSIGNMENT := [];
    t3_set:  SET OF approval :=[];
    violate: LOGICAL := FALSE;
END_LOCAL;
  t1_set := QUERY(i <* GROUP | VALUE_IN(WHICH_CLASS(i), 
    'approval history')); 
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
   t2_set := QUERY(a <* APPLIED_GROUP_ASSIGNMENT | 
     a.ASSIGNED_GROUP = t1_set[i]);
   t3_set := QUERY(b <* t2_set[1].items | 
     'SHIP_MOULDED_FORM_SCHEMA.APPROVAL' IN TYPEOF(b));
    violate := NOT (VALUE_UNIQUE(t3_set));
END_REPEAT;
WHERE
    WR1: NOT violate; 
END_RULE;

RULE user_def_appendage_type_description_required
FOR (REPRESENTATION);

  LOCAL
        violation: LOGICAL := FALSE;
  END_LOCAL;
  REPEAT i := 1 TO HIINDEX(REPRESENTATION) WHILE NOT violation;
    violation := (SIZEOF(QUERY(r <* REPRESENTATION[i].ITEMS |
       ('SHIP_MOULDED_FORM_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM'
       IN TYPEOF(r)) AND
       (r.NAME = 'type of appendage') AND
       (r\DESCRIPTIVE_REPRESENTATION_ITEM.DESCRIPTION = 'user defined'))) > 0)
                 AND
                 (SIZEOF(QUERY(r <* REPRESENTATION[i].ITEMS |
                         (r.NAME = 'user def appendage type'))) = 0);
  END_REPEAT;

  WHERE
    WR1: NOT violation;
END_RULE;

RULE user_def_function_description_required
FOR (REPRESENTATION);

  LOCAL
    violation: LOGICAL := FALSE;
  END_LOCAL;
  REPEAT i := 1 TO HIINDEX(REPRESENTATION) WHILE NOT violation;
    violation := (SIZEOF(QUERY(r <* REPRESENTATION[i].ITEMS |
                         ('SHIP_MOULDED_FORM_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM'
                          IN TYPEOF(r)) AND
                         (r.NAME = 'function') AND
                         (r\DESCRIPTIVE_REPRESENTATION_ITEM.DESCRIPTION = 'user defined'))) > 0)
                 AND
                 (SIZEOF(QUERY(r <* REPRESENTATION[i].ITEMS |
                         (r.NAME = 'user def function'))) = 0);
  END_REPEAT;

  WHERE
    WR1: NOT violation;
END_RULE;

RULE
 valid_product_definition_for_class_moulded_form
FOR (APPLIED_CLASSIFICATION_ASSIGNMENT,APPLIED_GROUP_ASSIGNMENT);
LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT:= [];
    t1_set:  SET OF PRODUCT_DEFINITION := [];
    gr_ass:    SET OF APPLIED_GROUP_ASSIGNMENT := [];
    groups:    SET OF GROUP := [];
    violation: LOGICAL := FALSE;
    violate1, violate2 : LOGICAL;
  END_LOCAL;

  (* get all classification_assignment instances with id 'ship moulded form' *)
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.ASSIGNED_CLASS.NAME = 'ship moulded form');

  (* get all instances of product_definition that have class id 'ship moulded form' *)
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  (* get the groups associated with these product_definitions *)
  gr_ass := QUERY(i <* APPLIED_GROUP_ASSIGNMENT |
                  i.role.name = 'equivalence');
  REPEAT i := 1 TO HIINDEX(gr_ass);
    REPEAT j := 1 TO HIINDEX(gr_ass[i].items);  -- should always be just one
      IF (gr_ass[i].items[j] IN t1_set) THEN
        groups := groups + gr_ass[i].assigned_group;
      END_IF;
    END_REPEAT;
  END_REPEAT;

  (* get the non-empty group_assignments having role 'item structure' and
     referencing these groups
   *)
  gr_ass := QUERY(i <* APPLIED_GROUP_ASSIGNMENT |
                  (SIZEOF(i.items) <> 0) AND
                  (i.role.name = 'item structure') AND
                  (i.assigned_group IN groups));

  (* check if there are only instances of class 'moulded form' and of  class moulded form relationship'  in each group_assignment.items
   *)
  REPEAT i := 1 TO HIINDEX(gr_ass) WHILE NOT(violation);
    REPEAT j := 1 TO HIINDEX(gr_ass[i].items) WHILE NOT(violation);
      violate1 := VALUE_IN(WHICH_CLASS(gr_ass[i].items[j]),'moulded form');
      violate2 := VALUE_IN(WHICH_CLASS(gr_ass[i].items[j]),'moulded form relationship');
      violation := NOT(violate1 OR violate2);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;

END_RULE;

RULE 
version_creation_has_mandatory_attribute_description
FOR (action);
LOCAL
    t1_set:  SET OF action := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
  t1_set := QUERY(i <* action | VALUE_IN(WHICH_CLASS(i), 
  'version creation')); 
  violate := (SIZEOF(QUERY(k <* t1_set | 
  NOT EXISTS (k.description))) > 0);
WHERE
    WR1: NOT violate; 
END_RULE;

RULE 
version_deletion_has_mandatory_attribute_description
FOR (action);
LOCAL
    t1_set:  SET OF action := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
  t1_set := QUERY(i <* action | VALUE_IN(WHICH_CLASS(i), 
  'version deletion')); 
  violate := (SIZEOF(QUERY(k <* t1_set | 
NOT EXISTS (k.description))) > 0);
WHERE
    WR1: NOT violate; 
END_RULE;

RULE version_history_has_exactly_one_assigned_group
FOR(applied_group_assignment, group);
  LOCAL
    t1_set:  SET OF group := [];
    set_1, set_2: SET OF applied_group_assignment := [];
    set_3: SET OF group_item := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;


t1_set := QUERY(a <* group | VALUE_IN(WHICH_CLASS(a), 'version history'));

REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
   set_1 := QUERY(b <* applied_group_assignment | 
         (b.assigned_group = t1_set[i]) AND (b.role.name = 'current version'));
   set_2 := QUERY(c <* applied_group_assignment | 
               (c.assigned_group = t1_set[i]) AND (c.role.name = 'members'));
   violate := ((SIZEOF(set_1) <> 1) OR (SIZEOF(set_2) <> 1));
   IF not violate THEN

      set_3 := set_1[1].items * set_2[1].items;

      violate := (SIZEOF(set_3) <> 1) OR 
                  NOT (VALUE_IN(WHICH_CLASS(set_3[1]), 'versionable object'));
   END_IF;
END_REPEAT;

WHERE
    wr1: NOT violate;
END_RULE;

RULE version_history_is_referenced_by_at_least_one_versions
FOR(applied_group_assignment, group);
  LOCAL
    t1_set:  SET OF group := [];
    a_set:  SET OF applied_group_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;

t1_set := QUERY(a <* group | VALUE_IN(WHICH_CLASS(a), 'version history'));

REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
(* get the instances of applied_group_assignment that have a role 'versions' *)
   a_set := QUERY(b <* applied_group_assignment | 
               (b.assigned_group = t1_set[i]) AND (b.role.name = 'versions'));

(* there shall be at least one such instance *)
    violate := SIZEOF(a_set) < 1;
  END_REPEAT;

WHERE
    wr1: NOT violate;
END_RULE;

RULE version_history_referenced_by_exactly_one_current_version
FOR(applied_group_assignment, group);
  LOCAL
    t1_set:  SET OF group := [];
    a_set:  SET OF applied_group_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;

(* get all instances of group with class 'version history' *)
t1_set := QUERY(a <* group | VALUE_IN(WHICH_CLASS(a), 'version history'));

  (* for all instances found above *)
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
(* get the instances of applied_group_assignment that have a role 'current version' *)
   a_set := QUERY(b <* applied_group_assignment | 
               (b.assigned_group = t1_set[i]) AND (b.role.name = 'current version'));

(* there shall be one such instance *)
    violate := SIZEOF(a_set) <> 1;
  END_REPEAT;

WHERE
    wr1: NOT violate;
END_RULE;

RULE version_history_referenced_by_multiple_roles
FOR(applied_group_assignment, group);
  LOCAL
    t1_set:  SET OF group := [];
    a_set:  SET OF applied_group_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
t1_set := QUERY(a <* group | VALUE_IN(WHICH_CLASS(a), 'version history'));
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
   a_set := QUERY(b <* applied_group_assignment | 
    (b.assigned_group = t1_set[i]) AND NOT (b.role.name IN ['versions', 'current version', 'relationships']));
    violate := SIZEOF(a_set) < 1;
END_REPEAT;
WHERE
    wr1: NOT violate;
END_RULE;

RULE 
version_modification_has_mandatory_attribute_description
FOR (action);
LOCAL
    t1_set:  SET OF action := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
  t1_set := QUERY(i <* action | VALUE_IN(WHICH_CLASS(i), 
  'version modification')); 
  violate := (SIZEOF(QUERY(k <* t1_set | 
  NOT EXISTS (k.description))) > 0);
WHERE
    WR1: NOT violate; 
END_RULE;

RULE version_relationship_associates_with_versionable_object
	FOR (applied_identification_assignment);
LOCAL
    violate: LOGICAL := FALSE;
END_LOCAL;
REPEAT i := 1 TO HIINDEX(applied_identification_assignment) BY 1 WHILE NOT violate;
	 IF ( (SIZEOF(USEDIN(applied_identification_assignment[i],           ('SHIP_MOULDED_FORM_SCHEMA.IDENTIFICATION_ASSIGNMENT_RELATIONSHIP.'
             +'RELATING_IDENTIFICATION_ASSIGNMENT'))) > 0) OR
      (SIZEOF(USEDIN(applied_identification_assignment[i],
      ('SHIP_MOULDED_FORM_SCHEMA.IDENTIFICATION_ASSIGNMENT_RELATIONSHIP.'
             +'RELATED_IDENTIFICATION_ASSIGNMENT'))) > 0) ) THEN
  REPEAT j := 1 to HIINDEX(applied_identification_assignment[i].items) BY 1 WHILE NOT violate;
	   violate := NOT  VALUE_IN(which_class(applied_identification_assignment[i].items[j]),            'versionable object');
  END_REPEAT;
 END_IF;

END_REPEAT; 
WHERE
    WR1: NOT violate; 
END_RULE;

RULE 
version_relationship_has_mandatory_attribute_description
FOR (identification_assignment_relationship);
LOCAL
    t1_set:  SET OF identification_assignment_relationship := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
t1_set := QUERY(i <* identification_assignment_relationship | 
VALUE_IN(WHICH_CLASS(i), 'version relationship')); 
violate := (SIZEOF(QUERY(k <* t1_set | NOT EXISTS (k.description))) > 0);
WHERE
    WR1: NOT violate; 
END_RULE;

RULE 
version_relationship_has_unique_versions
FOR (identification_assignment_relationship);
LOCAL
    t1_set:  SET OF identification_assignment_relationship := [];
    violate: LOGICAL := FALSE;
END_LOCAL;
   t1_set := QUERY(a <* identification_assignment_relationship | 
   VALUE_IN(WHICH_CLASS(a), 'version relationship'));
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
    violate := 
          ( t1_set[i].relating_identification_assignment.assigned_id =
            t1_set[i].related_identification_assignment.assigned_id );
END_REPEAT; 
WHERE
    WR1: NOT violate; 
END_RULE;

RULE versionable_object_has_one_version_id
FOR(APPLIED_IDENTIFICATION_ASSIGNMENT);
  LOCAL
    version_ids:         SET OF APPLIED_IDENTIFICATION_ASSIGNMENT := [];
    versionable_objects: BAG OF identification_item := [];
    duplicate:           LOGICAL := FALSE;
  END_LOCAL;
 
  version_ids := QUERY(i <* APPLIED_IDENTIFICATION_ASSIGNMENT |
                       i.ROLE.NAME = 'version identifier');
 
  REPEAT i := 1 TO HIINDEX(version_ids);
    versionable_objects := versionable_objects + version_ids[i].items;
  END_REPEAT;
   REPEAT i := 1 TO HIINDEX(versionable_objects) WHILE NOT duplicate;
    REPEAT j := i + 1 TO HIINDEX(versionable_objects) WHILE NOT duplicate;
      duplicate := versionable_objects[i] :=: versionable_objects[j];
    END_REPEAT;
  END_REPEAT;
  WHERE
    WR1: NOT duplicate;
END_RULE;

RULE versioned_action_request_with_identification_assignment
FOR (APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF versioned_action_request := [];
    t2_set:  SET OF applied_identification_assignment := [];
    arg_list:  LIST OF STRING := [ 'change request'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
        c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME =  arg_LIST[j]);
   END_REPEAT;

  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;


    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
'SHIP_MOULDED_FORM_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
      t2_set := QUERY ( j <* t2_set | 
	       	     j.role.name = 'globally unambiguous identifier');           violation := NOT (SIZEOF(T2_SET) = 1);
    END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE versions_is_referenced_by_at_least_one_version_history
FOR(applied_group_assignment, group);
  LOCAL
    t1_set:  SET OF group := [];
    a_set:  SET OF applied_group_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;

t1_set := QUERY(a <* group | VALUE_IN(WHICH_CLASS(a), 'versions'));

REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;

   a_set := QUERY(b <* applied_group_assignment | 
       (b.assigned_group = t1_set[i]) AND (b.role.name = 'version history'));

    violate := SIZEOF(a_set) < 1;
  END_REPEAT;

WHERE
    wr1: NOT violate;
END_RULE;

FUNCTION WHICH_CLASS(T: GENERIC): LIST OF STRING;
  LOCAL
     elements: BAG OF APPLIED_CLASSIFICATION_ASSIGNMENT;
     class_list: LIST OF STRING :=[];
  END_LOCAL;

  elements :=
      USEDIN(T,
      'SHIP_MOULDED_FORM_SCHEMA.APPLIED_CLASSIFICATION_ASSIGNMENT.ITEMS');

  REPEAT i:=1 TO HIINDEX(elements);
 IF (elements[i]\classification_assignment.role.name = 'class membership') THEN
  class_list := class_list + 
  elements[i]\classification_assignment.assigned_class\group.name;
 END_IF;
  END_REPEAT;

  RETURN(class_list);
END_FUNCTION;

END_SCHEMA;
